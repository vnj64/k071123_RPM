// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain/repositories.SessionUpdates -o session_updates_mock_test.go -n SessionUpdatesMock -p mocks

import (
	mm_repositories "k071123/internal/services/parking_service/domain/repositories"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// SessionUpdatesMock implements mm_repositories.SessionUpdates
type SessionUpdatesMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcHaveUpdates          func() (b1 bool)
	funcHaveUpdatesOrigin    string
	inspectFuncHaveUpdates   func()
	afterHaveUpdatesCounter  uint64
	beforeHaveUpdatesCounter uint64
	HaveUpdatesMock          mSessionUpdatesMockHaveUpdates

	funcSetCarUUID          func(value uuid.UUID) (s1 mm_repositories.SessionUpdates)
	funcSetCarUUIDOrigin    string
	inspectFuncSetCarUUID   func(value uuid.UUID)
	afterSetCarUUIDCounter  uint64
	beforeSetCarUUIDCounter uint64
	SetCarUUIDMock          mSessionUpdatesMockSetCarUUID

	funcSetCost          func(cost float64) (s1 mm_repositories.SessionUpdates)
	funcSetCostOrigin    string
	inspectFuncSetCost   func(cost float64)
	afterSetCostCounter  uint64
	beforeSetCostCounter uint64
	SetCostMock          mSessionUpdatesMockSetCost

	funcSetFinishAt          func(finishAt *time.Time) (s1 mm_repositories.SessionUpdates)
	funcSetFinishAtOrigin    string
	inspectFuncSetFinishAt   func(finishAt *time.Time)
	afterSetFinishAtCounter  uint64
	beforeSetFinishAtCounter uint64
	SetFinishAtMock          mSessionUpdatesMockSetFinishAt

	funcSetParkingUUID          func(value uuid.UUID) (s1 mm_repositories.SessionUpdates)
	funcSetParkingUUIDOrigin    string
	inspectFuncSetParkingUUID   func(value uuid.UUID)
	afterSetParkingUUIDCounter  uint64
	beforeSetParkingUUIDCounter uint64
	SetParkingUUIDMock          mSessionUpdatesMockSetParkingUUID

	funcSetStatus          func(status string) (s1 mm_repositories.SessionUpdates)
	funcSetStatusOrigin    string
	inspectFuncSetStatus   func(status string)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mSessionUpdatesMockSetStatus

	funcSetUnitUUID          func(value uuid.UUID) (s1 mm_repositories.SessionUpdates)
	funcSetUnitUUIDOrigin    string
	inspectFuncSetUnitUUID   func(value uuid.UUID)
	afterSetUnitUUIDCounter  uint64
	beforeSetUnitUUIDCounter uint64
	SetUnitUUIDMock          mSessionUpdatesMockSetUnitUUID

	funcSetUserUUID          func(value uuid.UUID) (s1 mm_repositories.SessionUpdates)
	funcSetUserUUIDOrigin    string
	inspectFuncSetUserUUID   func(value uuid.UUID)
	afterSetUserUUIDCounter  uint64
	beforeSetUserUUIDCounter uint64
	SetUserUUIDMock          mSessionUpdatesMockSetUserUUID
}

// NewSessionUpdatesMock returns a mock for mm_repositories.SessionUpdates
func NewSessionUpdatesMock(t minimock.Tester) *SessionUpdatesMock {
	m := &SessionUpdatesMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.HaveUpdatesMock = mSessionUpdatesMockHaveUpdates{mock: m}

	m.SetCarUUIDMock = mSessionUpdatesMockSetCarUUID{mock: m}
	m.SetCarUUIDMock.callArgs = []*SessionUpdatesMockSetCarUUIDParams{}

	m.SetCostMock = mSessionUpdatesMockSetCost{mock: m}
	m.SetCostMock.callArgs = []*SessionUpdatesMockSetCostParams{}

	m.SetFinishAtMock = mSessionUpdatesMockSetFinishAt{mock: m}
	m.SetFinishAtMock.callArgs = []*SessionUpdatesMockSetFinishAtParams{}

	m.SetParkingUUIDMock = mSessionUpdatesMockSetParkingUUID{mock: m}
	m.SetParkingUUIDMock.callArgs = []*SessionUpdatesMockSetParkingUUIDParams{}

	m.SetStatusMock = mSessionUpdatesMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*SessionUpdatesMockSetStatusParams{}

	m.SetUnitUUIDMock = mSessionUpdatesMockSetUnitUUID{mock: m}
	m.SetUnitUUIDMock.callArgs = []*SessionUpdatesMockSetUnitUUIDParams{}

	m.SetUserUUIDMock = mSessionUpdatesMockSetUserUUID{mock: m}
	m.SetUserUUIDMock.callArgs = []*SessionUpdatesMockSetUserUUIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSessionUpdatesMockHaveUpdates struct {
	optional           bool
	mock               *SessionUpdatesMock
	defaultExpectation *SessionUpdatesMockHaveUpdatesExpectation
	expectations       []*SessionUpdatesMockHaveUpdatesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUpdatesMockHaveUpdatesExpectation specifies expectation struct of the SessionUpdates.HaveUpdates
type SessionUpdatesMockHaveUpdatesExpectation struct {
	mock *SessionUpdatesMock

	results      *SessionUpdatesMockHaveUpdatesResults
	returnOrigin string
	Counter      uint64
}

// SessionUpdatesMockHaveUpdatesResults contains results of the SessionUpdates.HaveUpdates
type SessionUpdatesMockHaveUpdatesResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHaveUpdates *mSessionUpdatesMockHaveUpdates) Optional() *mSessionUpdatesMockHaveUpdates {
	mmHaveUpdates.optional = true
	return mmHaveUpdates
}

// Expect sets up expected params for SessionUpdates.HaveUpdates
func (mmHaveUpdates *mSessionUpdatesMockHaveUpdates) Expect() *mSessionUpdatesMockHaveUpdates {
	if mmHaveUpdates.mock.funcHaveUpdates != nil {
		mmHaveUpdates.mock.t.Fatalf("SessionUpdatesMock.HaveUpdates mock is already set by Set")
	}

	if mmHaveUpdates.defaultExpectation == nil {
		mmHaveUpdates.defaultExpectation = &SessionUpdatesMockHaveUpdatesExpectation{}
	}

	return mmHaveUpdates
}

// Inspect accepts an inspector function that has same arguments as the SessionUpdates.HaveUpdates
func (mmHaveUpdates *mSessionUpdatesMockHaveUpdates) Inspect(f func()) *mSessionUpdatesMockHaveUpdates {
	if mmHaveUpdates.mock.inspectFuncHaveUpdates != nil {
		mmHaveUpdates.mock.t.Fatalf("Inspect function is already set for SessionUpdatesMock.HaveUpdates")
	}

	mmHaveUpdates.mock.inspectFuncHaveUpdates = f

	return mmHaveUpdates
}

// Return sets up results that will be returned by SessionUpdates.HaveUpdates
func (mmHaveUpdates *mSessionUpdatesMockHaveUpdates) Return(b1 bool) *SessionUpdatesMock {
	if mmHaveUpdates.mock.funcHaveUpdates != nil {
		mmHaveUpdates.mock.t.Fatalf("SessionUpdatesMock.HaveUpdates mock is already set by Set")
	}

	if mmHaveUpdates.defaultExpectation == nil {
		mmHaveUpdates.defaultExpectation = &SessionUpdatesMockHaveUpdatesExpectation{mock: mmHaveUpdates.mock}
	}
	mmHaveUpdates.defaultExpectation.results = &SessionUpdatesMockHaveUpdatesResults{b1}
	mmHaveUpdates.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHaveUpdates.mock
}

// Set uses given function f to mock the SessionUpdates.HaveUpdates method
func (mmHaveUpdates *mSessionUpdatesMockHaveUpdates) Set(f func() (b1 bool)) *SessionUpdatesMock {
	if mmHaveUpdates.defaultExpectation != nil {
		mmHaveUpdates.mock.t.Fatalf("Default expectation is already set for the SessionUpdates.HaveUpdates method")
	}

	if len(mmHaveUpdates.expectations) > 0 {
		mmHaveUpdates.mock.t.Fatalf("Some expectations are already set for the SessionUpdates.HaveUpdates method")
	}

	mmHaveUpdates.mock.funcHaveUpdates = f
	mmHaveUpdates.mock.funcHaveUpdatesOrigin = minimock.CallerInfo(1)
	return mmHaveUpdates.mock
}

// Times sets number of times SessionUpdates.HaveUpdates should be invoked
func (mmHaveUpdates *mSessionUpdatesMockHaveUpdates) Times(n uint64) *mSessionUpdatesMockHaveUpdates {
	if n == 0 {
		mmHaveUpdates.mock.t.Fatalf("Times of SessionUpdatesMock.HaveUpdates mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHaveUpdates.expectedInvocations, n)
	mmHaveUpdates.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHaveUpdates
}

func (mmHaveUpdates *mSessionUpdatesMockHaveUpdates) invocationsDone() bool {
	if len(mmHaveUpdates.expectations) == 0 && mmHaveUpdates.defaultExpectation == nil && mmHaveUpdates.mock.funcHaveUpdates == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHaveUpdates.mock.afterHaveUpdatesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHaveUpdates.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HaveUpdates implements mm_repositories.SessionUpdates
func (mmHaveUpdates *SessionUpdatesMock) HaveUpdates() (b1 bool) {
	mm_atomic.AddUint64(&mmHaveUpdates.beforeHaveUpdatesCounter, 1)
	defer mm_atomic.AddUint64(&mmHaveUpdates.afterHaveUpdatesCounter, 1)

	mmHaveUpdates.t.Helper()

	if mmHaveUpdates.inspectFuncHaveUpdates != nil {
		mmHaveUpdates.inspectFuncHaveUpdates()
	}

	if mmHaveUpdates.HaveUpdatesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHaveUpdates.HaveUpdatesMock.defaultExpectation.Counter, 1)

		mm_results := mmHaveUpdates.HaveUpdatesMock.defaultExpectation.results
		if mm_results == nil {
			mmHaveUpdates.t.Fatal("No results are set for the SessionUpdatesMock.HaveUpdates")
		}
		return (*mm_results).b1
	}
	if mmHaveUpdates.funcHaveUpdates != nil {
		return mmHaveUpdates.funcHaveUpdates()
	}
	mmHaveUpdates.t.Fatalf("Unexpected call to SessionUpdatesMock.HaveUpdates.")
	return
}

// HaveUpdatesAfterCounter returns a count of finished SessionUpdatesMock.HaveUpdates invocations
func (mmHaveUpdates *SessionUpdatesMock) HaveUpdatesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHaveUpdates.afterHaveUpdatesCounter)
}

// HaveUpdatesBeforeCounter returns a count of SessionUpdatesMock.HaveUpdates invocations
func (mmHaveUpdates *SessionUpdatesMock) HaveUpdatesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHaveUpdates.beforeHaveUpdatesCounter)
}

// MinimockHaveUpdatesDone returns true if the count of the HaveUpdates invocations corresponds
// the number of defined expectations
func (m *SessionUpdatesMock) MinimockHaveUpdatesDone() bool {
	if m.HaveUpdatesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HaveUpdatesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HaveUpdatesMock.invocationsDone()
}

// MinimockHaveUpdatesInspect logs each unmet expectation
func (m *SessionUpdatesMock) MinimockHaveUpdatesInspect() {
	for _, e := range m.HaveUpdatesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SessionUpdatesMock.HaveUpdates")
		}
	}

	afterHaveUpdatesCounter := mm_atomic.LoadUint64(&m.afterHaveUpdatesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HaveUpdatesMock.defaultExpectation != nil && afterHaveUpdatesCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.HaveUpdates at\n%s", m.HaveUpdatesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHaveUpdates != nil && afterHaveUpdatesCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.HaveUpdates at\n%s", m.funcHaveUpdatesOrigin)
	}

	if !m.HaveUpdatesMock.invocationsDone() && afterHaveUpdatesCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUpdatesMock.HaveUpdates at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HaveUpdatesMock.expectedInvocations), m.HaveUpdatesMock.expectedInvocationsOrigin, afterHaveUpdatesCounter)
	}
}

type mSessionUpdatesMockSetCarUUID struct {
	optional           bool
	mock               *SessionUpdatesMock
	defaultExpectation *SessionUpdatesMockSetCarUUIDExpectation
	expectations       []*SessionUpdatesMockSetCarUUIDExpectation

	callArgs []*SessionUpdatesMockSetCarUUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUpdatesMockSetCarUUIDExpectation specifies expectation struct of the SessionUpdates.SetCarUUID
type SessionUpdatesMockSetCarUUIDExpectation struct {
	mock               *SessionUpdatesMock
	params             *SessionUpdatesMockSetCarUUIDParams
	paramPtrs          *SessionUpdatesMockSetCarUUIDParamPtrs
	expectationOrigins SessionUpdatesMockSetCarUUIDExpectationOrigins
	results            *SessionUpdatesMockSetCarUUIDResults
	returnOrigin       string
	Counter            uint64
}

// SessionUpdatesMockSetCarUUIDParams contains parameters of the SessionUpdates.SetCarUUID
type SessionUpdatesMockSetCarUUIDParams struct {
	value uuid.UUID
}

// SessionUpdatesMockSetCarUUIDParamPtrs contains pointers to parameters of the SessionUpdates.SetCarUUID
type SessionUpdatesMockSetCarUUIDParamPtrs struct {
	value *uuid.UUID
}

// SessionUpdatesMockSetCarUUIDResults contains results of the SessionUpdates.SetCarUUID
type SessionUpdatesMockSetCarUUIDResults struct {
	s1 mm_repositories.SessionUpdates
}

// SessionUpdatesMockSetCarUUIDOrigins contains origins of expectations of the SessionUpdates.SetCarUUID
type SessionUpdatesMockSetCarUUIDExpectationOrigins struct {
	origin      string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) Optional() *mSessionUpdatesMockSetCarUUID {
	mmSetCarUUID.optional = true
	return mmSetCarUUID
}

// Expect sets up expected params for SessionUpdates.SetCarUUID
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) Expect(value uuid.UUID) *mSessionUpdatesMockSetCarUUID {
	if mmSetCarUUID.mock.funcSetCarUUID != nil {
		mmSetCarUUID.mock.t.Fatalf("SessionUpdatesMock.SetCarUUID mock is already set by Set")
	}

	if mmSetCarUUID.defaultExpectation == nil {
		mmSetCarUUID.defaultExpectation = &SessionUpdatesMockSetCarUUIDExpectation{}
	}

	if mmSetCarUUID.defaultExpectation.paramPtrs != nil {
		mmSetCarUUID.mock.t.Fatalf("SessionUpdatesMock.SetCarUUID mock is already set by ExpectParams functions")
	}

	mmSetCarUUID.defaultExpectation.params = &SessionUpdatesMockSetCarUUIDParams{value}
	mmSetCarUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetCarUUID.expectations {
		if minimock.Equal(e.params, mmSetCarUUID.defaultExpectation.params) {
			mmSetCarUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetCarUUID.defaultExpectation.params)
		}
	}

	return mmSetCarUUID
}

// ExpectValueParam1 sets up expected param value for SessionUpdates.SetCarUUID
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) ExpectValueParam1(value uuid.UUID) *mSessionUpdatesMockSetCarUUID {
	if mmSetCarUUID.mock.funcSetCarUUID != nil {
		mmSetCarUUID.mock.t.Fatalf("SessionUpdatesMock.SetCarUUID mock is already set by Set")
	}

	if mmSetCarUUID.defaultExpectation == nil {
		mmSetCarUUID.defaultExpectation = &SessionUpdatesMockSetCarUUIDExpectation{}
	}

	if mmSetCarUUID.defaultExpectation.params != nil {
		mmSetCarUUID.mock.t.Fatalf("SessionUpdatesMock.SetCarUUID mock is already set by Expect")
	}

	if mmSetCarUUID.defaultExpectation.paramPtrs == nil {
		mmSetCarUUID.defaultExpectation.paramPtrs = &SessionUpdatesMockSetCarUUIDParamPtrs{}
	}
	mmSetCarUUID.defaultExpectation.paramPtrs.value = &value
	mmSetCarUUID.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSetCarUUID
}

// Inspect accepts an inspector function that has same arguments as the SessionUpdates.SetCarUUID
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) Inspect(f func(value uuid.UUID)) *mSessionUpdatesMockSetCarUUID {
	if mmSetCarUUID.mock.inspectFuncSetCarUUID != nil {
		mmSetCarUUID.mock.t.Fatalf("Inspect function is already set for SessionUpdatesMock.SetCarUUID")
	}

	mmSetCarUUID.mock.inspectFuncSetCarUUID = f

	return mmSetCarUUID
}

// Return sets up results that will be returned by SessionUpdates.SetCarUUID
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) Return(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	if mmSetCarUUID.mock.funcSetCarUUID != nil {
		mmSetCarUUID.mock.t.Fatalf("SessionUpdatesMock.SetCarUUID mock is already set by Set")
	}

	if mmSetCarUUID.defaultExpectation == nil {
		mmSetCarUUID.defaultExpectation = &SessionUpdatesMockSetCarUUIDExpectation{mock: mmSetCarUUID.mock}
	}
	mmSetCarUUID.defaultExpectation.results = &SessionUpdatesMockSetCarUUIDResults{s1}
	mmSetCarUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetCarUUID.mock
}

// Set uses given function f to mock the SessionUpdates.SetCarUUID method
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) Set(f func(value uuid.UUID) (s1 mm_repositories.SessionUpdates)) *SessionUpdatesMock {
	if mmSetCarUUID.defaultExpectation != nil {
		mmSetCarUUID.mock.t.Fatalf("Default expectation is already set for the SessionUpdates.SetCarUUID method")
	}

	if len(mmSetCarUUID.expectations) > 0 {
		mmSetCarUUID.mock.t.Fatalf("Some expectations are already set for the SessionUpdates.SetCarUUID method")
	}

	mmSetCarUUID.mock.funcSetCarUUID = f
	mmSetCarUUID.mock.funcSetCarUUIDOrigin = minimock.CallerInfo(1)
	return mmSetCarUUID.mock
}

// When sets expectation for the SessionUpdates.SetCarUUID which will trigger the result defined by the following
// Then helper
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) When(value uuid.UUID) *SessionUpdatesMockSetCarUUIDExpectation {
	if mmSetCarUUID.mock.funcSetCarUUID != nil {
		mmSetCarUUID.mock.t.Fatalf("SessionUpdatesMock.SetCarUUID mock is already set by Set")
	}

	expectation := &SessionUpdatesMockSetCarUUIDExpectation{
		mock:               mmSetCarUUID.mock,
		params:             &SessionUpdatesMockSetCarUUIDParams{value},
		expectationOrigins: SessionUpdatesMockSetCarUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetCarUUID.expectations = append(mmSetCarUUID.expectations, expectation)
	return expectation
}

// Then sets up SessionUpdates.SetCarUUID return parameters for the expectation previously defined by the When method
func (e *SessionUpdatesMockSetCarUUIDExpectation) Then(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	e.results = &SessionUpdatesMockSetCarUUIDResults{s1}
	return e.mock
}

// Times sets number of times SessionUpdates.SetCarUUID should be invoked
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) Times(n uint64) *mSessionUpdatesMockSetCarUUID {
	if n == 0 {
		mmSetCarUUID.mock.t.Fatalf("Times of SessionUpdatesMock.SetCarUUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetCarUUID.expectedInvocations, n)
	mmSetCarUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetCarUUID
}

func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) invocationsDone() bool {
	if len(mmSetCarUUID.expectations) == 0 && mmSetCarUUID.defaultExpectation == nil && mmSetCarUUID.mock.funcSetCarUUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetCarUUID.mock.afterSetCarUUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetCarUUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetCarUUID implements mm_repositories.SessionUpdates
func (mmSetCarUUID *SessionUpdatesMock) SetCarUUID(value uuid.UUID) (s1 mm_repositories.SessionUpdates) {
	mm_atomic.AddUint64(&mmSetCarUUID.beforeSetCarUUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetCarUUID.afterSetCarUUIDCounter, 1)

	mmSetCarUUID.t.Helper()

	if mmSetCarUUID.inspectFuncSetCarUUID != nil {
		mmSetCarUUID.inspectFuncSetCarUUID(value)
	}

	mm_params := SessionUpdatesMockSetCarUUIDParams{value}

	// Record call args
	mmSetCarUUID.SetCarUUIDMock.mutex.Lock()
	mmSetCarUUID.SetCarUUIDMock.callArgs = append(mmSetCarUUID.SetCarUUIDMock.callArgs, &mm_params)
	mmSetCarUUID.SetCarUUIDMock.mutex.Unlock()

	for _, e := range mmSetCarUUID.SetCarUUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetCarUUID.SetCarUUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetCarUUID.SetCarUUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetCarUUID.SetCarUUIDMock.defaultExpectation.params
		mm_want_ptrs := mmSetCarUUID.SetCarUUIDMock.defaultExpectation.paramPtrs

		mm_got := SessionUpdatesMockSetCarUUIDParams{value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetCarUUID.t.Errorf("SessionUpdatesMock.SetCarUUID got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCarUUID.SetCarUUIDMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetCarUUID.t.Errorf("SessionUpdatesMock.SetCarUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetCarUUID.SetCarUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetCarUUID.SetCarUUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSetCarUUID.t.Fatal("No results are set for the SessionUpdatesMock.SetCarUUID")
		}
		return (*mm_results).s1
	}
	if mmSetCarUUID.funcSetCarUUID != nil {
		return mmSetCarUUID.funcSetCarUUID(value)
	}
	mmSetCarUUID.t.Fatalf("Unexpected call to SessionUpdatesMock.SetCarUUID. %v", value)
	return
}

// SetCarUUIDAfterCounter returns a count of finished SessionUpdatesMock.SetCarUUID invocations
func (mmSetCarUUID *SessionUpdatesMock) SetCarUUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCarUUID.afterSetCarUUIDCounter)
}

// SetCarUUIDBeforeCounter returns a count of SessionUpdatesMock.SetCarUUID invocations
func (mmSetCarUUID *SessionUpdatesMock) SetCarUUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCarUUID.beforeSetCarUUIDCounter)
}

// Calls returns a list of arguments used in each call to SessionUpdatesMock.SetCarUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetCarUUID *mSessionUpdatesMockSetCarUUID) Calls() []*SessionUpdatesMockSetCarUUIDParams {
	mmSetCarUUID.mutex.RLock()

	argCopy := make([]*SessionUpdatesMockSetCarUUIDParams, len(mmSetCarUUID.callArgs))
	copy(argCopy, mmSetCarUUID.callArgs)

	mmSetCarUUID.mutex.RUnlock()

	return argCopy
}

// MinimockSetCarUUIDDone returns true if the count of the SetCarUUID invocations corresponds
// the number of defined expectations
func (m *SessionUpdatesMock) MinimockSetCarUUIDDone() bool {
	if m.SetCarUUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetCarUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetCarUUIDMock.invocationsDone()
}

// MinimockSetCarUUIDInspect logs each unmet expectation
func (m *SessionUpdatesMock) MinimockSetCarUUIDInspect() {
	for _, e := range m.SetCarUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetCarUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCarUUIDCounter := mm_atomic.LoadUint64(&m.afterSetCarUUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetCarUUIDMock.defaultExpectation != nil && afterSetCarUUIDCounter < 1 {
		if m.SetCarUUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetCarUUID at\n%s", m.SetCarUUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetCarUUID at\n%s with params: %#v", m.SetCarUUIDMock.defaultExpectation.expectationOrigins.origin, *m.SetCarUUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCarUUID != nil && afterSetCarUUIDCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.SetCarUUID at\n%s", m.funcSetCarUUIDOrigin)
	}

	if !m.SetCarUUIDMock.invocationsDone() && afterSetCarUUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUpdatesMock.SetCarUUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetCarUUIDMock.expectedInvocations), m.SetCarUUIDMock.expectedInvocationsOrigin, afterSetCarUUIDCounter)
	}
}

type mSessionUpdatesMockSetCost struct {
	optional           bool
	mock               *SessionUpdatesMock
	defaultExpectation *SessionUpdatesMockSetCostExpectation
	expectations       []*SessionUpdatesMockSetCostExpectation

	callArgs []*SessionUpdatesMockSetCostParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUpdatesMockSetCostExpectation specifies expectation struct of the SessionUpdates.SetCost
type SessionUpdatesMockSetCostExpectation struct {
	mock               *SessionUpdatesMock
	params             *SessionUpdatesMockSetCostParams
	paramPtrs          *SessionUpdatesMockSetCostParamPtrs
	expectationOrigins SessionUpdatesMockSetCostExpectationOrigins
	results            *SessionUpdatesMockSetCostResults
	returnOrigin       string
	Counter            uint64
}

// SessionUpdatesMockSetCostParams contains parameters of the SessionUpdates.SetCost
type SessionUpdatesMockSetCostParams struct {
	cost float64
}

// SessionUpdatesMockSetCostParamPtrs contains pointers to parameters of the SessionUpdates.SetCost
type SessionUpdatesMockSetCostParamPtrs struct {
	cost *float64
}

// SessionUpdatesMockSetCostResults contains results of the SessionUpdates.SetCost
type SessionUpdatesMockSetCostResults struct {
	s1 mm_repositories.SessionUpdates
}

// SessionUpdatesMockSetCostOrigins contains origins of expectations of the SessionUpdates.SetCost
type SessionUpdatesMockSetCostExpectationOrigins struct {
	origin     string
	originCost string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetCost *mSessionUpdatesMockSetCost) Optional() *mSessionUpdatesMockSetCost {
	mmSetCost.optional = true
	return mmSetCost
}

// Expect sets up expected params for SessionUpdates.SetCost
func (mmSetCost *mSessionUpdatesMockSetCost) Expect(cost float64) *mSessionUpdatesMockSetCost {
	if mmSetCost.mock.funcSetCost != nil {
		mmSetCost.mock.t.Fatalf("SessionUpdatesMock.SetCost mock is already set by Set")
	}

	if mmSetCost.defaultExpectation == nil {
		mmSetCost.defaultExpectation = &SessionUpdatesMockSetCostExpectation{}
	}

	if mmSetCost.defaultExpectation.paramPtrs != nil {
		mmSetCost.mock.t.Fatalf("SessionUpdatesMock.SetCost mock is already set by ExpectParams functions")
	}

	mmSetCost.defaultExpectation.params = &SessionUpdatesMockSetCostParams{cost}
	mmSetCost.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetCost.expectations {
		if minimock.Equal(e.params, mmSetCost.defaultExpectation.params) {
			mmSetCost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetCost.defaultExpectation.params)
		}
	}

	return mmSetCost
}

// ExpectCostParam1 sets up expected param cost for SessionUpdates.SetCost
func (mmSetCost *mSessionUpdatesMockSetCost) ExpectCostParam1(cost float64) *mSessionUpdatesMockSetCost {
	if mmSetCost.mock.funcSetCost != nil {
		mmSetCost.mock.t.Fatalf("SessionUpdatesMock.SetCost mock is already set by Set")
	}

	if mmSetCost.defaultExpectation == nil {
		mmSetCost.defaultExpectation = &SessionUpdatesMockSetCostExpectation{}
	}

	if mmSetCost.defaultExpectation.params != nil {
		mmSetCost.mock.t.Fatalf("SessionUpdatesMock.SetCost mock is already set by Expect")
	}

	if mmSetCost.defaultExpectation.paramPtrs == nil {
		mmSetCost.defaultExpectation.paramPtrs = &SessionUpdatesMockSetCostParamPtrs{}
	}
	mmSetCost.defaultExpectation.paramPtrs.cost = &cost
	mmSetCost.defaultExpectation.expectationOrigins.originCost = minimock.CallerInfo(1)

	return mmSetCost
}

// Inspect accepts an inspector function that has same arguments as the SessionUpdates.SetCost
func (mmSetCost *mSessionUpdatesMockSetCost) Inspect(f func(cost float64)) *mSessionUpdatesMockSetCost {
	if mmSetCost.mock.inspectFuncSetCost != nil {
		mmSetCost.mock.t.Fatalf("Inspect function is already set for SessionUpdatesMock.SetCost")
	}

	mmSetCost.mock.inspectFuncSetCost = f

	return mmSetCost
}

// Return sets up results that will be returned by SessionUpdates.SetCost
func (mmSetCost *mSessionUpdatesMockSetCost) Return(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	if mmSetCost.mock.funcSetCost != nil {
		mmSetCost.mock.t.Fatalf("SessionUpdatesMock.SetCost mock is already set by Set")
	}

	if mmSetCost.defaultExpectation == nil {
		mmSetCost.defaultExpectation = &SessionUpdatesMockSetCostExpectation{mock: mmSetCost.mock}
	}
	mmSetCost.defaultExpectation.results = &SessionUpdatesMockSetCostResults{s1}
	mmSetCost.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetCost.mock
}

// Set uses given function f to mock the SessionUpdates.SetCost method
func (mmSetCost *mSessionUpdatesMockSetCost) Set(f func(cost float64) (s1 mm_repositories.SessionUpdates)) *SessionUpdatesMock {
	if mmSetCost.defaultExpectation != nil {
		mmSetCost.mock.t.Fatalf("Default expectation is already set for the SessionUpdates.SetCost method")
	}

	if len(mmSetCost.expectations) > 0 {
		mmSetCost.mock.t.Fatalf("Some expectations are already set for the SessionUpdates.SetCost method")
	}

	mmSetCost.mock.funcSetCost = f
	mmSetCost.mock.funcSetCostOrigin = minimock.CallerInfo(1)
	return mmSetCost.mock
}

// When sets expectation for the SessionUpdates.SetCost which will trigger the result defined by the following
// Then helper
func (mmSetCost *mSessionUpdatesMockSetCost) When(cost float64) *SessionUpdatesMockSetCostExpectation {
	if mmSetCost.mock.funcSetCost != nil {
		mmSetCost.mock.t.Fatalf("SessionUpdatesMock.SetCost mock is already set by Set")
	}

	expectation := &SessionUpdatesMockSetCostExpectation{
		mock:               mmSetCost.mock,
		params:             &SessionUpdatesMockSetCostParams{cost},
		expectationOrigins: SessionUpdatesMockSetCostExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetCost.expectations = append(mmSetCost.expectations, expectation)
	return expectation
}

// Then sets up SessionUpdates.SetCost return parameters for the expectation previously defined by the When method
func (e *SessionUpdatesMockSetCostExpectation) Then(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	e.results = &SessionUpdatesMockSetCostResults{s1}
	return e.mock
}

// Times sets number of times SessionUpdates.SetCost should be invoked
func (mmSetCost *mSessionUpdatesMockSetCost) Times(n uint64) *mSessionUpdatesMockSetCost {
	if n == 0 {
		mmSetCost.mock.t.Fatalf("Times of SessionUpdatesMock.SetCost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetCost.expectedInvocations, n)
	mmSetCost.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetCost
}

func (mmSetCost *mSessionUpdatesMockSetCost) invocationsDone() bool {
	if len(mmSetCost.expectations) == 0 && mmSetCost.defaultExpectation == nil && mmSetCost.mock.funcSetCost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetCost.mock.afterSetCostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetCost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetCost implements mm_repositories.SessionUpdates
func (mmSetCost *SessionUpdatesMock) SetCost(cost float64) (s1 mm_repositories.SessionUpdates) {
	mm_atomic.AddUint64(&mmSetCost.beforeSetCostCounter, 1)
	defer mm_atomic.AddUint64(&mmSetCost.afterSetCostCounter, 1)

	mmSetCost.t.Helper()

	if mmSetCost.inspectFuncSetCost != nil {
		mmSetCost.inspectFuncSetCost(cost)
	}

	mm_params := SessionUpdatesMockSetCostParams{cost}

	// Record call args
	mmSetCost.SetCostMock.mutex.Lock()
	mmSetCost.SetCostMock.callArgs = append(mmSetCost.SetCostMock.callArgs, &mm_params)
	mmSetCost.SetCostMock.mutex.Unlock()

	for _, e := range mmSetCost.SetCostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetCost.SetCostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetCost.SetCostMock.defaultExpectation.Counter, 1)
		mm_want := mmSetCost.SetCostMock.defaultExpectation.params
		mm_want_ptrs := mmSetCost.SetCostMock.defaultExpectation.paramPtrs

		mm_got := SessionUpdatesMockSetCostParams{cost}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.cost != nil && !minimock.Equal(*mm_want_ptrs.cost, mm_got.cost) {
				mmSetCost.t.Errorf("SessionUpdatesMock.SetCost got unexpected parameter cost, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCost.SetCostMock.defaultExpectation.expectationOrigins.originCost, *mm_want_ptrs.cost, mm_got.cost, minimock.Diff(*mm_want_ptrs.cost, mm_got.cost))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetCost.t.Errorf("SessionUpdatesMock.SetCost got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetCost.SetCostMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetCost.SetCostMock.defaultExpectation.results
		if mm_results == nil {
			mmSetCost.t.Fatal("No results are set for the SessionUpdatesMock.SetCost")
		}
		return (*mm_results).s1
	}
	if mmSetCost.funcSetCost != nil {
		return mmSetCost.funcSetCost(cost)
	}
	mmSetCost.t.Fatalf("Unexpected call to SessionUpdatesMock.SetCost. %v", cost)
	return
}

// SetCostAfterCounter returns a count of finished SessionUpdatesMock.SetCost invocations
func (mmSetCost *SessionUpdatesMock) SetCostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCost.afterSetCostCounter)
}

// SetCostBeforeCounter returns a count of SessionUpdatesMock.SetCost invocations
func (mmSetCost *SessionUpdatesMock) SetCostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCost.beforeSetCostCounter)
}

// Calls returns a list of arguments used in each call to SessionUpdatesMock.SetCost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetCost *mSessionUpdatesMockSetCost) Calls() []*SessionUpdatesMockSetCostParams {
	mmSetCost.mutex.RLock()

	argCopy := make([]*SessionUpdatesMockSetCostParams, len(mmSetCost.callArgs))
	copy(argCopy, mmSetCost.callArgs)

	mmSetCost.mutex.RUnlock()

	return argCopy
}

// MinimockSetCostDone returns true if the count of the SetCost invocations corresponds
// the number of defined expectations
func (m *SessionUpdatesMock) MinimockSetCostDone() bool {
	if m.SetCostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetCostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetCostMock.invocationsDone()
}

// MinimockSetCostInspect logs each unmet expectation
func (m *SessionUpdatesMock) MinimockSetCostInspect() {
	for _, e := range m.SetCostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetCost at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCostCounter := mm_atomic.LoadUint64(&m.afterSetCostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetCostMock.defaultExpectation != nil && afterSetCostCounter < 1 {
		if m.SetCostMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetCost at\n%s", m.SetCostMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetCost at\n%s with params: %#v", m.SetCostMock.defaultExpectation.expectationOrigins.origin, *m.SetCostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCost != nil && afterSetCostCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.SetCost at\n%s", m.funcSetCostOrigin)
	}

	if !m.SetCostMock.invocationsDone() && afterSetCostCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUpdatesMock.SetCost at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetCostMock.expectedInvocations), m.SetCostMock.expectedInvocationsOrigin, afterSetCostCounter)
	}
}

type mSessionUpdatesMockSetFinishAt struct {
	optional           bool
	mock               *SessionUpdatesMock
	defaultExpectation *SessionUpdatesMockSetFinishAtExpectation
	expectations       []*SessionUpdatesMockSetFinishAtExpectation

	callArgs []*SessionUpdatesMockSetFinishAtParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUpdatesMockSetFinishAtExpectation specifies expectation struct of the SessionUpdates.SetFinishAt
type SessionUpdatesMockSetFinishAtExpectation struct {
	mock               *SessionUpdatesMock
	params             *SessionUpdatesMockSetFinishAtParams
	paramPtrs          *SessionUpdatesMockSetFinishAtParamPtrs
	expectationOrigins SessionUpdatesMockSetFinishAtExpectationOrigins
	results            *SessionUpdatesMockSetFinishAtResults
	returnOrigin       string
	Counter            uint64
}

// SessionUpdatesMockSetFinishAtParams contains parameters of the SessionUpdates.SetFinishAt
type SessionUpdatesMockSetFinishAtParams struct {
	finishAt *time.Time
}

// SessionUpdatesMockSetFinishAtParamPtrs contains pointers to parameters of the SessionUpdates.SetFinishAt
type SessionUpdatesMockSetFinishAtParamPtrs struct {
	finishAt **time.Time
}

// SessionUpdatesMockSetFinishAtResults contains results of the SessionUpdates.SetFinishAt
type SessionUpdatesMockSetFinishAtResults struct {
	s1 mm_repositories.SessionUpdates
}

// SessionUpdatesMockSetFinishAtOrigins contains origins of expectations of the SessionUpdates.SetFinishAt
type SessionUpdatesMockSetFinishAtExpectationOrigins struct {
	origin         string
	originFinishAt string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) Optional() *mSessionUpdatesMockSetFinishAt {
	mmSetFinishAt.optional = true
	return mmSetFinishAt
}

// Expect sets up expected params for SessionUpdates.SetFinishAt
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) Expect(finishAt *time.Time) *mSessionUpdatesMockSetFinishAt {
	if mmSetFinishAt.mock.funcSetFinishAt != nil {
		mmSetFinishAt.mock.t.Fatalf("SessionUpdatesMock.SetFinishAt mock is already set by Set")
	}

	if mmSetFinishAt.defaultExpectation == nil {
		mmSetFinishAt.defaultExpectation = &SessionUpdatesMockSetFinishAtExpectation{}
	}

	if mmSetFinishAt.defaultExpectation.paramPtrs != nil {
		mmSetFinishAt.mock.t.Fatalf("SessionUpdatesMock.SetFinishAt mock is already set by ExpectParams functions")
	}

	mmSetFinishAt.defaultExpectation.params = &SessionUpdatesMockSetFinishAtParams{finishAt}
	mmSetFinishAt.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetFinishAt.expectations {
		if minimock.Equal(e.params, mmSetFinishAt.defaultExpectation.params) {
			mmSetFinishAt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetFinishAt.defaultExpectation.params)
		}
	}

	return mmSetFinishAt
}

// ExpectFinishAtParam1 sets up expected param finishAt for SessionUpdates.SetFinishAt
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) ExpectFinishAtParam1(finishAt *time.Time) *mSessionUpdatesMockSetFinishAt {
	if mmSetFinishAt.mock.funcSetFinishAt != nil {
		mmSetFinishAt.mock.t.Fatalf("SessionUpdatesMock.SetFinishAt mock is already set by Set")
	}

	if mmSetFinishAt.defaultExpectation == nil {
		mmSetFinishAt.defaultExpectation = &SessionUpdatesMockSetFinishAtExpectation{}
	}

	if mmSetFinishAt.defaultExpectation.params != nil {
		mmSetFinishAt.mock.t.Fatalf("SessionUpdatesMock.SetFinishAt mock is already set by Expect")
	}

	if mmSetFinishAt.defaultExpectation.paramPtrs == nil {
		mmSetFinishAt.defaultExpectation.paramPtrs = &SessionUpdatesMockSetFinishAtParamPtrs{}
	}
	mmSetFinishAt.defaultExpectation.paramPtrs.finishAt = &finishAt
	mmSetFinishAt.defaultExpectation.expectationOrigins.originFinishAt = minimock.CallerInfo(1)

	return mmSetFinishAt
}

// Inspect accepts an inspector function that has same arguments as the SessionUpdates.SetFinishAt
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) Inspect(f func(finishAt *time.Time)) *mSessionUpdatesMockSetFinishAt {
	if mmSetFinishAt.mock.inspectFuncSetFinishAt != nil {
		mmSetFinishAt.mock.t.Fatalf("Inspect function is already set for SessionUpdatesMock.SetFinishAt")
	}

	mmSetFinishAt.mock.inspectFuncSetFinishAt = f

	return mmSetFinishAt
}

// Return sets up results that will be returned by SessionUpdates.SetFinishAt
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) Return(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	if mmSetFinishAt.mock.funcSetFinishAt != nil {
		mmSetFinishAt.mock.t.Fatalf("SessionUpdatesMock.SetFinishAt mock is already set by Set")
	}

	if mmSetFinishAt.defaultExpectation == nil {
		mmSetFinishAt.defaultExpectation = &SessionUpdatesMockSetFinishAtExpectation{mock: mmSetFinishAt.mock}
	}
	mmSetFinishAt.defaultExpectation.results = &SessionUpdatesMockSetFinishAtResults{s1}
	mmSetFinishAt.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetFinishAt.mock
}

// Set uses given function f to mock the SessionUpdates.SetFinishAt method
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) Set(f func(finishAt *time.Time) (s1 mm_repositories.SessionUpdates)) *SessionUpdatesMock {
	if mmSetFinishAt.defaultExpectation != nil {
		mmSetFinishAt.mock.t.Fatalf("Default expectation is already set for the SessionUpdates.SetFinishAt method")
	}

	if len(mmSetFinishAt.expectations) > 0 {
		mmSetFinishAt.mock.t.Fatalf("Some expectations are already set for the SessionUpdates.SetFinishAt method")
	}

	mmSetFinishAt.mock.funcSetFinishAt = f
	mmSetFinishAt.mock.funcSetFinishAtOrigin = minimock.CallerInfo(1)
	return mmSetFinishAt.mock
}

// When sets expectation for the SessionUpdates.SetFinishAt which will trigger the result defined by the following
// Then helper
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) When(finishAt *time.Time) *SessionUpdatesMockSetFinishAtExpectation {
	if mmSetFinishAt.mock.funcSetFinishAt != nil {
		mmSetFinishAt.mock.t.Fatalf("SessionUpdatesMock.SetFinishAt mock is already set by Set")
	}

	expectation := &SessionUpdatesMockSetFinishAtExpectation{
		mock:               mmSetFinishAt.mock,
		params:             &SessionUpdatesMockSetFinishAtParams{finishAt},
		expectationOrigins: SessionUpdatesMockSetFinishAtExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetFinishAt.expectations = append(mmSetFinishAt.expectations, expectation)
	return expectation
}

// Then sets up SessionUpdates.SetFinishAt return parameters for the expectation previously defined by the When method
func (e *SessionUpdatesMockSetFinishAtExpectation) Then(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	e.results = &SessionUpdatesMockSetFinishAtResults{s1}
	return e.mock
}

// Times sets number of times SessionUpdates.SetFinishAt should be invoked
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) Times(n uint64) *mSessionUpdatesMockSetFinishAt {
	if n == 0 {
		mmSetFinishAt.mock.t.Fatalf("Times of SessionUpdatesMock.SetFinishAt mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetFinishAt.expectedInvocations, n)
	mmSetFinishAt.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetFinishAt
}

func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) invocationsDone() bool {
	if len(mmSetFinishAt.expectations) == 0 && mmSetFinishAt.defaultExpectation == nil && mmSetFinishAt.mock.funcSetFinishAt == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetFinishAt.mock.afterSetFinishAtCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetFinishAt.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetFinishAt implements mm_repositories.SessionUpdates
func (mmSetFinishAt *SessionUpdatesMock) SetFinishAt(finishAt *time.Time) (s1 mm_repositories.SessionUpdates) {
	mm_atomic.AddUint64(&mmSetFinishAt.beforeSetFinishAtCounter, 1)
	defer mm_atomic.AddUint64(&mmSetFinishAt.afterSetFinishAtCounter, 1)

	mmSetFinishAt.t.Helper()

	if mmSetFinishAt.inspectFuncSetFinishAt != nil {
		mmSetFinishAt.inspectFuncSetFinishAt(finishAt)
	}

	mm_params := SessionUpdatesMockSetFinishAtParams{finishAt}

	// Record call args
	mmSetFinishAt.SetFinishAtMock.mutex.Lock()
	mmSetFinishAt.SetFinishAtMock.callArgs = append(mmSetFinishAt.SetFinishAtMock.callArgs, &mm_params)
	mmSetFinishAt.SetFinishAtMock.mutex.Unlock()

	for _, e := range mmSetFinishAt.SetFinishAtMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetFinishAt.SetFinishAtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetFinishAt.SetFinishAtMock.defaultExpectation.Counter, 1)
		mm_want := mmSetFinishAt.SetFinishAtMock.defaultExpectation.params
		mm_want_ptrs := mmSetFinishAt.SetFinishAtMock.defaultExpectation.paramPtrs

		mm_got := SessionUpdatesMockSetFinishAtParams{finishAt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.finishAt != nil && !minimock.Equal(*mm_want_ptrs.finishAt, mm_got.finishAt) {
				mmSetFinishAt.t.Errorf("SessionUpdatesMock.SetFinishAt got unexpected parameter finishAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetFinishAt.SetFinishAtMock.defaultExpectation.expectationOrigins.originFinishAt, *mm_want_ptrs.finishAt, mm_got.finishAt, minimock.Diff(*mm_want_ptrs.finishAt, mm_got.finishAt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetFinishAt.t.Errorf("SessionUpdatesMock.SetFinishAt got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetFinishAt.SetFinishAtMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetFinishAt.SetFinishAtMock.defaultExpectation.results
		if mm_results == nil {
			mmSetFinishAt.t.Fatal("No results are set for the SessionUpdatesMock.SetFinishAt")
		}
		return (*mm_results).s1
	}
	if mmSetFinishAt.funcSetFinishAt != nil {
		return mmSetFinishAt.funcSetFinishAt(finishAt)
	}
	mmSetFinishAt.t.Fatalf("Unexpected call to SessionUpdatesMock.SetFinishAt. %v", finishAt)
	return
}

// SetFinishAtAfterCounter returns a count of finished SessionUpdatesMock.SetFinishAt invocations
func (mmSetFinishAt *SessionUpdatesMock) SetFinishAtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFinishAt.afterSetFinishAtCounter)
}

// SetFinishAtBeforeCounter returns a count of SessionUpdatesMock.SetFinishAt invocations
func (mmSetFinishAt *SessionUpdatesMock) SetFinishAtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFinishAt.beforeSetFinishAtCounter)
}

// Calls returns a list of arguments used in each call to SessionUpdatesMock.SetFinishAt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetFinishAt *mSessionUpdatesMockSetFinishAt) Calls() []*SessionUpdatesMockSetFinishAtParams {
	mmSetFinishAt.mutex.RLock()

	argCopy := make([]*SessionUpdatesMockSetFinishAtParams, len(mmSetFinishAt.callArgs))
	copy(argCopy, mmSetFinishAt.callArgs)

	mmSetFinishAt.mutex.RUnlock()

	return argCopy
}

// MinimockSetFinishAtDone returns true if the count of the SetFinishAt invocations corresponds
// the number of defined expectations
func (m *SessionUpdatesMock) MinimockSetFinishAtDone() bool {
	if m.SetFinishAtMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetFinishAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetFinishAtMock.invocationsDone()
}

// MinimockSetFinishAtInspect logs each unmet expectation
func (m *SessionUpdatesMock) MinimockSetFinishAtInspect() {
	for _, e := range m.SetFinishAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetFinishAt at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetFinishAtCounter := mm_atomic.LoadUint64(&m.afterSetFinishAtCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetFinishAtMock.defaultExpectation != nil && afterSetFinishAtCounter < 1 {
		if m.SetFinishAtMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetFinishAt at\n%s", m.SetFinishAtMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetFinishAt at\n%s with params: %#v", m.SetFinishAtMock.defaultExpectation.expectationOrigins.origin, *m.SetFinishAtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetFinishAt != nil && afterSetFinishAtCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.SetFinishAt at\n%s", m.funcSetFinishAtOrigin)
	}

	if !m.SetFinishAtMock.invocationsDone() && afterSetFinishAtCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUpdatesMock.SetFinishAt at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetFinishAtMock.expectedInvocations), m.SetFinishAtMock.expectedInvocationsOrigin, afterSetFinishAtCounter)
	}
}

type mSessionUpdatesMockSetParkingUUID struct {
	optional           bool
	mock               *SessionUpdatesMock
	defaultExpectation *SessionUpdatesMockSetParkingUUIDExpectation
	expectations       []*SessionUpdatesMockSetParkingUUIDExpectation

	callArgs []*SessionUpdatesMockSetParkingUUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUpdatesMockSetParkingUUIDExpectation specifies expectation struct of the SessionUpdates.SetParkingUUID
type SessionUpdatesMockSetParkingUUIDExpectation struct {
	mock               *SessionUpdatesMock
	params             *SessionUpdatesMockSetParkingUUIDParams
	paramPtrs          *SessionUpdatesMockSetParkingUUIDParamPtrs
	expectationOrigins SessionUpdatesMockSetParkingUUIDExpectationOrigins
	results            *SessionUpdatesMockSetParkingUUIDResults
	returnOrigin       string
	Counter            uint64
}

// SessionUpdatesMockSetParkingUUIDParams contains parameters of the SessionUpdates.SetParkingUUID
type SessionUpdatesMockSetParkingUUIDParams struct {
	value uuid.UUID
}

// SessionUpdatesMockSetParkingUUIDParamPtrs contains pointers to parameters of the SessionUpdates.SetParkingUUID
type SessionUpdatesMockSetParkingUUIDParamPtrs struct {
	value *uuid.UUID
}

// SessionUpdatesMockSetParkingUUIDResults contains results of the SessionUpdates.SetParkingUUID
type SessionUpdatesMockSetParkingUUIDResults struct {
	s1 mm_repositories.SessionUpdates
}

// SessionUpdatesMockSetParkingUUIDOrigins contains origins of expectations of the SessionUpdates.SetParkingUUID
type SessionUpdatesMockSetParkingUUIDExpectationOrigins struct {
	origin      string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) Optional() *mSessionUpdatesMockSetParkingUUID {
	mmSetParkingUUID.optional = true
	return mmSetParkingUUID
}

// Expect sets up expected params for SessionUpdates.SetParkingUUID
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) Expect(value uuid.UUID) *mSessionUpdatesMockSetParkingUUID {
	if mmSetParkingUUID.mock.funcSetParkingUUID != nil {
		mmSetParkingUUID.mock.t.Fatalf("SessionUpdatesMock.SetParkingUUID mock is already set by Set")
	}

	if mmSetParkingUUID.defaultExpectation == nil {
		mmSetParkingUUID.defaultExpectation = &SessionUpdatesMockSetParkingUUIDExpectation{}
	}

	if mmSetParkingUUID.defaultExpectation.paramPtrs != nil {
		mmSetParkingUUID.mock.t.Fatalf("SessionUpdatesMock.SetParkingUUID mock is already set by ExpectParams functions")
	}

	mmSetParkingUUID.defaultExpectation.params = &SessionUpdatesMockSetParkingUUIDParams{value}
	mmSetParkingUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetParkingUUID.expectations {
		if minimock.Equal(e.params, mmSetParkingUUID.defaultExpectation.params) {
			mmSetParkingUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetParkingUUID.defaultExpectation.params)
		}
	}

	return mmSetParkingUUID
}

// ExpectValueParam1 sets up expected param value for SessionUpdates.SetParkingUUID
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) ExpectValueParam1(value uuid.UUID) *mSessionUpdatesMockSetParkingUUID {
	if mmSetParkingUUID.mock.funcSetParkingUUID != nil {
		mmSetParkingUUID.mock.t.Fatalf("SessionUpdatesMock.SetParkingUUID mock is already set by Set")
	}

	if mmSetParkingUUID.defaultExpectation == nil {
		mmSetParkingUUID.defaultExpectation = &SessionUpdatesMockSetParkingUUIDExpectation{}
	}

	if mmSetParkingUUID.defaultExpectation.params != nil {
		mmSetParkingUUID.mock.t.Fatalf("SessionUpdatesMock.SetParkingUUID mock is already set by Expect")
	}

	if mmSetParkingUUID.defaultExpectation.paramPtrs == nil {
		mmSetParkingUUID.defaultExpectation.paramPtrs = &SessionUpdatesMockSetParkingUUIDParamPtrs{}
	}
	mmSetParkingUUID.defaultExpectation.paramPtrs.value = &value
	mmSetParkingUUID.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSetParkingUUID
}

// Inspect accepts an inspector function that has same arguments as the SessionUpdates.SetParkingUUID
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) Inspect(f func(value uuid.UUID)) *mSessionUpdatesMockSetParkingUUID {
	if mmSetParkingUUID.mock.inspectFuncSetParkingUUID != nil {
		mmSetParkingUUID.mock.t.Fatalf("Inspect function is already set for SessionUpdatesMock.SetParkingUUID")
	}

	mmSetParkingUUID.mock.inspectFuncSetParkingUUID = f

	return mmSetParkingUUID
}

// Return sets up results that will be returned by SessionUpdates.SetParkingUUID
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) Return(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	if mmSetParkingUUID.mock.funcSetParkingUUID != nil {
		mmSetParkingUUID.mock.t.Fatalf("SessionUpdatesMock.SetParkingUUID mock is already set by Set")
	}

	if mmSetParkingUUID.defaultExpectation == nil {
		mmSetParkingUUID.defaultExpectation = &SessionUpdatesMockSetParkingUUIDExpectation{mock: mmSetParkingUUID.mock}
	}
	mmSetParkingUUID.defaultExpectation.results = &SessionUpdatesMockSetParkingUUIDResults{s1}
	mmSetParkingUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetParkingUUID.mock
}

// Set uses given function f to mock the SessionUpdates.SetParkingUUID method
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) Set(f func(value uuid.UUID) (s1 mm_repositories.SessionUpdates)) *SessionUpdatesMock {
	if mmSetParkingUUID.defaultExpectation != nil {
		mmSetParkingUUID.mock.t.Fatalf("Default expectation is already set for the SessionUpdates.SetParkingUUID method")
	}

	if len(mmSetParkingUUID.expectations) > 0 {
		mmSetParkingUUID.mock.t.Fatalf("Some expectations are already set for the SessionUpdates.SetParkingUUID method")
	}

	mmSetParkingUUID.mock.funcSetParkingUUID = f
	mmSetParkingUUID.mock.funcSetParkingUUIDOrigin = minimock.CallerInfo(1)
	return mmSetParkingUUID.mock
}

// When sets expectation for the SessionUpdates.SetParkingUUID which will trigger the result defined by the following
// Then helper
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) When(value uuid.UUID) *SessionUpdatesMockSetParkingUUIDExpectation {
	if mmSetParkingUUID.mock.funcSetParkingUUID != nil {
		mmSetParkingUUID.mock.t.Fatalf("SessionUpdatesMock.SetParkingUUID mock is already set by Set")
	}

	expectation := &SessionUpdatesMockSetParkingUUIDExpectation{
		mock:               mmSetParkingUUID.mock,
		params:             &SessionUpdatesMockSetParkingUUIDParams{value},
		expectationOrigins: SessionUpdatesMockSetParkingUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetParkingUUID.expectations = append(mmSetParkingUUID.expectations, expectation)
	return expectation
}

// Then sets up SessionUpdates.SetParkingUUID return parameters for the expectation previously defined by the When method
func (e *SessionUpdatesMockSetParkingUUIDExpectation) Then(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	e.results = &SessionUpdatesMockSetParkingUUIDResults{s1}
	return e.mock
}

// Times sets number of times SessionUpdates.SetParkingUUID should be invoked
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) Times(n uint64) *mSessionUpdatesMockSetParkingUUID {
	if n == 0 {
		mmSetParkingUUID.mock.t.Fatalf("Times of SessionUpdatesMock.SetParkingUUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetParkingUUID.expectedInvocations, n)
	mmSetParkingUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetParkingUUID
}

func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) invocationsDone() bool {
	if len(mmSetParkingUUID.expectations) == 0 && mmSetParkingUUID.defaultExpectation == nil && mmSetParkingUUID.mock.funcSetParkingUUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetParkingUUID.mock.afterSetParkingUUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetParkingUUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetParkingUUID implements mm_repositories.SessionUpdates
func (mmSetParkingUUID *SessionUpdatesMock) SetParkingUUID(value uuid.UUID) (s1 mm_repositories.SessionUpdates) {
	mm_atomic.AddUint64(&mmSetParkingUUID.beforeSetParkingUUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetParkingUUID.afterSetParkingUUIDCounter, 1)

	mmSetParkingUUID.t.Helper()

	if mmSetParkingUUID.inspectFuncSetParkingUUID != nil {
		mmSetParkingUUID.inspectFuncSetParkingUUID(value)
	}

	mm_params := SessionUpdatesMockSetParkingUUIDParams{value}

	// Record call args
	mmSetParkingUUID.SetParkingUUIDMock.mutex.Lock()
	mmSetParkingUUID.SetParkingUUIDMock.callArgs = append(mmSetParkingUUID.SetParkingUUIDMock.callArgs, &mm_params)
	mmSetParkingUUID.SetParkingUUIDMock.mutex.Unlock()

	for _, e := range mmSetParkingUUID.SetParkingUUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetParkingUUID.SetParkingUUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetParkingUUID.SetParkingUUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetParkingUUID.SetParkingUUIDMock.defaultExpectation.params
		mm_want_ptrs := mmSetParkingUUID.SetParkingUUIDMock.defaultExpectation.paramPtrs

		mm_got := SessionUpdatesMockSetParkingUUIDParams{value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetParkingUUID.t.Errorf("SessionUpdatesMock.SetParkingUUID got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetParkingUUID.SetParkingUUIDMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetParkingUUID.t.Errorf("SessionUpdatesMock.SetParkingUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetParkingUUID.SetParkingUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetParkingUUID.SetParkingUUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSetParkingUUID.t.Fatal("No results are set for the SessionUpdatesMock.SetParkingUUID")
		}
		return (*mm_results).s1
	}
	if mmSetParkingUUID.funcSetParkingUUID != nil {
		return mmSetParkingUUID.funcSetParkingUUID(value)
	}
	mmSetParkingUUID.t.Fatalf("Unexpected call to SessionUpdatesMock.SetParkingUUID. %v", value)
	return
}

// SetParkingUUIDAfterCounter returns a count of finished SessionUpdatesMock.SetParkingUUID invocations
func (mmSetParkingUUID *SessionUpdatesMock) SetParkingUUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetParkingUUID.afterSetParkingUUIDCounter)
}

// SetParkingUUIDBeforeCounter returns a count of SessionUpdatesMock.SetParkingUUID invocations
func (mmSetParkingUUID *SessionUpdatesMock) SetParkingUUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetParkingUUID.beforeSetParkingUUIDCounter)
}

// Calls returns a list of arguments used in each call to SessionUpdatesMock.SetParkingUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetParkingUUID *mSessionUpdatesMockSetParkingUUID) Calls() []*SessionUpdatesMockSetParkingUUIDParams {
	mmSetParkingUUID.mutex.RLock()

	argCopy := make([]*SessionUpdatesMockSetParkingUUIDParams, len(mmSetParkingUUID.callArgs))
	copy(argCopy, mmSetParkingUUID.callArgs)

	mmSetParkingUUID.mutex.RUnlock()

	return argCopy
}

// MinimockSetParkingUUIDDone returns true if the count of the SetParkingUUID invocations corresponds
// the number of defined expectations
func (m *SessionUpdatesMock) MinimockSetParkingUUIDDone() bool {
	if m.SetParkingUUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetParkingUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetParkingUUIDMock.invocationsDone()
}

// MinimockSetParkingUUIDInspect logs each unmet expectation
func (m *SessionUpdatesMock) MinimockSetParkingUUIDInspect() {
	for _, e := range m.SetParkingUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetParkingUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetParkingUUIDCounter := mm_atomic.LoadUint64(&m.afterSetParkingUUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetParkingUUIDMock.defaultExpectation != nil && afterSetParkingUUIDCounter < 1 {
		if m.SetParkingUUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetParkingUUID at\n%s", m.SetParkingUUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetParkingUUID at\n%s with params: %#v", m.SetParkingUUIDMock.defaultExpectation.expectationOrigins.origin, *m.SetParkingUUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetParkingUUID != nil && afterSetParkingUUIDCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.SetParkingUUID at\n%s", m.funcSetParkingUUIDOrigin)
	}

	if !m.SetParkingUUIDMock.invocationsDone() && afterSetParkingUUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUpdatesMock.SetParkingUUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetParkingUUIDMock.expectedInvocations), m.SetParkingUUIDMock.expectedInvocationsOrigin, afterSetParkingUUIDCounter)
	}
}

type mSessionUpdatesMockSetStatus struct {
	optional           bool
	mock               *SessionUpdatesMock
	defaultExpectation *SessionUpdatesMockSetStatusExpectation
	expectations       []*SessionUpdatesMockSetStatusExpectation

	callArgs []*SessionUpdatesMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUpdatesMockSetStatusExpectation specifies expectation struct of the SessionUpdates.SetStatus
type SessionUpdatesMockSetStatusExpectation struct {
	mock               *SessionUpdatesMock
	params             *SessionUpdatesMockSetStatusParams
	paramPtrs          *SessionUpdatesMockSetStatusParamPtrs
	expectationOrigins SessionUpdatesMockSetStatusExpectationOrigins
	results            *SessionUpdatesMockSetStatusResults
	returnOrigin       string
	Counter            uint64
}

// SessionUpdatesMockSetStatusParams contains parameters of the SessionUpdates.SetStatus
type SessionUpdatesMockSetStatusParams struct {
	status string
}

// SessionUpdatesMockSetStatusParamPtrs contains pointers to parameters of the SessionUpdates.SetStatus
type SessionUpdatesMockSetStatusParamPtrs struct {
	status *string
}

// SessionUpdatesMockSetStatusResults contains results of the SessionUpdates.SetStatus
type SessionUpdatesMockSetStatusResults struct {
	s1 mm_repositories.SessionUpdates
}

// SessionUpdatesMockSetStatusOrigins contains origins of expectations of the SessionUpdates.SetStatus
type SessionUpdatesMockSetStatusExpectationOrigins struct {
	origin       string
	originStatus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mSessionUpdatesMockSetStatus) Optional() *mSessionUpdatesMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for SessionUpdates.SetStatus
func (mmSetStatus *mSessionUpdatesMockSetStatus) Expect(status string) *mSessionUpdatesMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("SessionUpdatesMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &SessionUpdatesMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("SessionUpdatesMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &SessionUpdatesMockSetStatusParams{status}
	mmSetStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectStatusParam1 sets up expected param status for SessionUpdates.SetStatus
func (mmSetStatus *mSessionUpdatesMockSetStatus) ExpectStatusParam1(status string) *mSessionUpdatesMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("SessionUpdatesMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &SessionUpdatesMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("SessionUpdatesMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &SessionUpdatesMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status
	mmSetStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the SessionUpdates.SetStatus
func (mmSetStatus *mSessionUpdatesMockSetStatus) Inspect(f func(status string)) *mSessionUpdatesMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for SessionUpdatesMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by SessionUpdates.SetStatus
func (mmSetStatus *mSessionUpdatesMockSetStatus) Return(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("SessionUpdatesMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &SessionUpdatesMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &SessionUpdatesMockSetStatusResults{s1}
	mmSetStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// Set uses given function f to mock the SessionUpdates.SetStatus method
func (mmSetStatus *mSessionUpdatesMockSetStatus) Set(f func(status string) (s1 mm_repositories.SessionUpdates)) *SessionUpdatesMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the SessionUpdates.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the SessionUpdates.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	mmSetStatus.mock.funcSetStatusOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// When sets expectation for the SessionUpdates.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mSessionUpdatesMockSetStatus) When(status string) *SessionUpdatesMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("SessionUpdatesMock.SetStatus mock is already set by Set")
	}

	expectation := &SessionUpdatesMockSetStatusExpectation{
		mock:               mmSetStatus.mock,
		params:             &SessionUpdatesMockSetStatusParams{status},
		expectationOrigins: SessionUpdatesMockSetStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up SessionUpdates.SetStatus return parameters for the expectation previously defined by the When method
func (e *SessionUpdatesMockSetStatusExpectation) Then(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	e.results = &SessionUpdatesMockSetStatusResults{s1}
	return e.mock
}

// Times sets number of times SessionUpdates.SetStatus should be invoked
func (mmSetStatus *mSessionUpdatesMockSetStatus) Times(n uint64) *mSessionUpdatesMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of SessionUpdatesMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	mmSetStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatus
}

func (mmSetStatus *mSessionUpdatesMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements mm_repositories.SessionUpdates
func (mmSetStatus *SessionUpdatesMock) SetStatus(status string) (s1 mm_repositories.SessionUpdates) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	mmSetStatus.t.Helper()

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(status)
	}

	mm_params := SessionUpdatesMockSetStatusParams{status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := SessionUpdatesMockSetStatusParams{status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("SessionUpdatesMock.SetStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("SessionUpdatesMock.SetStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the SessionUpdatesMock.SetStatus")
		}
		return (*mm_results).s1
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to SessionUpdatesMock.SetStatus. %v", status)
	return
}

// SetStatusAfterCounter returns a count of finished SessionUpdatesMock.SetStatus invocations
func (mmSetStatus *SessionUpdatesMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of SessionUpdatesMock.SetStatus invocations
func (mmSetStatus *SessionUpdatesMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to SessionUpdatesMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mSessionUpdatesMockSetStatus) Calls() []*SessionUpdatesMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*SessionUpdatesMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *SessionUpdatesMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *SessionUpdatesMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetStatus at\n%s", m.SetStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetStatus at\n%s with params: %#v", m.SetStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.SetStatus at\n%s", m.funcSetStatusOrigin)
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUpdatesMock.SetStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), m.SetStatusMock.expectedInvocationsOrigin, afterSetStatusCounter)
	}
}

type mSessionUpdatesMockSetUnitUUID struct {
	optional           bool
	mock               *SessionUpdatesMock
	defaultExpectation *SessionUpdatesMockSetUnitUUIDExpectation
	expectations       []*SessionUpdatesMockSetUnitUUIDExpectation

	callArgs []*SessionUpdatesMockSetUnitUUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUpdatesMockSetUnitUUIDExpectation specifies expectation struct of the SessionUpdates.SetUnitUUID
type SessionUpdatesMockSetUnitUUIDExpectation struct {
	mock               *SessionUpdatesMock
	params             *SessionUpdatesMockSetUnitUUIDParams
	paramPtrs          *SessionUpdatesMockSetUnitUUIDParamPtrs
	expectationOrigins SessionUpdatesMockSetUnitUUIDExpectationOrigins
	results            *SessionUpdatesMockSetUnitUUIDResults
	returnOrigin       string
	Counter            uint64
}

// SessionUpdatesMockSetUnitUUIDParams contains parameters of the SessionUpdates.SetUnitUUID
type SessionUpdatesMockSetUnitUUIDParams struct {
	value uuid.UUID
}

// SessionUpdatesMockSetUnitUUIDParamPtrs contains pointers to parameters of the SessionUpdates.SetUnitUUID
type SessionUpdatesMockSetUnitUUIDParamPtrs struct {
	value *uuid.UUID
}

// SessionUpdatesMockSetUnitUUIDResults contains results of the SessionUpdates.SetUnitUUID
type SessionUpdatesMockSetUnitUUIDResults struct {
	s1 mm_repositories.SessionUpdates
}

// SessionUpdatesMockSetUnitUUIDOrigins contains origins of expectations of the SessionUpdates.SetUnitUUID
type SessionUpdatesMockSetUnitUUIDExpectationOrigins struct {
	origin      string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) Optional() *mSessionUpdatesMockSetUnitUUID {
	mmSetUnitUUID.optional = true
	return mmSetUnitUUID
}

// Expect sets up expected params for SessionUpdates.SetUnitUUID
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) Expect(value uuid.UUID) *mSessionUpdatesMockSetUnitUUID {
	if mmSetUnitUUID.mock.funcSetUnitUUID != nil {
		mmSetUnitUUID.mock.t.Fatalf("SessionUpdatesMock.SetUnitUUID mock is already set by Set")
	}

	if mmSetUnitUUID.defaultExpectation == nil {
		mmSetUnitUUID.defaultExpectation = &SessionUpdatesMockSetUnitUUIDExpectation{}
	}

	if mmSetUnitUUID.defaultExpectation.paramPtrs != nil {
		mmSetUnitUUID.mock.t.Fatalf("SessionUpdatesMock.SetUnitUUID mock is already set by ExpectParams functions")
	}

	mmSetUnitUUID.defaultExpectation.params = &SessionUpdatesMockSetUnitUUIDParams{value}
	mmSetUnitUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetUnitUUID.expectations {
		if minimock.Equal(e.params, mmSetUnitUUID.defaultExpectation.params) {
			mmSetUnitUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetUnitUUID.defaultExpectation.params)
		}
	}

	return mmSetUnitUUID
}

// ExpectValueParam1 sets up expected param value for SessionUpdates.SetUnitUUID
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) ExpectValueParam1(value uuid.UUID) *mSessionUpdatesMockSetUnitUUID {
	if mmSetUnitUUID.mock.funcSetUnitUUID != nil {
		mmSetUnitUUID.mock.t.Fatalf("SessionUpdatesMock.SetUnitUUID mock is already set by Set")
	}

	if mmSetUnitUUID.defaultExpectation == nil {
		mmSetUnitUUID.defaultExpectation = &SessionUpdatesMockSetUnitUUIDExpectation{}
	}

	if mmSetUnitUUID.defaultExpectation.params != nil {
		mmSetUnitUUID.mock.t.Fatalf("SessionUpdatesMock.SetUnitUUID mock is already set by Expect")
	}

	if mmSetUnitUUID.defaultExpectation.paramPtrs == nil {
		mmSetUnitUUID.defaultExpectation.paramPtrs = &SessionUpdatesMockSetUnitUUIDParamPtrs{}
	}
	mmSetUnitUUID.defaultExpectation.paramPtrs.value = &value
	mmSetUnitUUID.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSetUnitUUID
}

// Inspect accepts an inspector function that has same arguments as the SessionUpdates.SetUnitUUID
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) Inspect(f func(value uuid.UUID)) *mSessionUpdatesMockSetUnitUUID {
	if mmSetUnitUUID.mock.inspectFuncSetUnitUUID != nil {
		mmSetUnitUUID.mock.t.Fatalf("Inspect function is already set for SessionUpdatesMock.SetUnitUUID")
	}

	mmSetUnitUUID.mock.inspectFuncSetUnitUUID = f

	return mmSetUnitUUID
}

// Return sets up results that will be returned by SessionUpdates.SetUnitUUID
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) Return(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	if mmSetUnitUUID.mock.funcSetUnitUUID != nil {
		mmSetUnitUUID.mock.t.Fatalf("SessionUpdatesMock.SetUnitUUID mock is already set by Set")
	}

	if mmSetUnitUUID.defaultExpectation == nil {
		mmSetUnitUUID.defaultExpectation = &SessionUpdatesMockSetUnitUUIDExpectation{mock: mmSetUnitUUID.mock}
	}
	mmSetUnitUUID.defaultExpectation.results = &SessionUpdatesMockSetUnitUUIDResults{s1}
	mmSetUnitUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetUnitUUID.mock
}

// Set uses given function f to mock the SessionUpdates.SetUnitUUID method
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) Set(f func(value uuid.UUID) (s1 mm_repositories.SessionUpdates)) *SessionUpdatesMock {
	if mmSetUnitUUID.defaultExpectation != nil {
		mmSetUnitUUID.mock.t.Fatalf("Default expectation is already set for the SessionUpdates.SetUnitUUID method")
	}

	if len(mmSetUnitUUID.expectations) > 0 {
		mmSetUnitUUID.mock.t.Fatalf("Some expectations are already set for the SessionUpdates.SetUnitUUID method")
	}

	mmSetUnitUUID.mock.funcSetUnitUUID = f
	mmSetUnitUUID.mock.funcSetUnitUUIDOrigin = minimock.CallerInfo(1)
	return mmSetUnitUUID.mock
}

// When sets expectation for the SessionUpdates.SetUnitUUID which will trigger the result defined by the following
// Then helper
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) When(value uuid.UUID) *SessionUpdatesMockSetUnitUUIDExpectation {
	if mmSetUnitUUID.mock.funcSetUnitUUID != nil {
		mmSetUnitUUID.mock.t.Fatalf("SessionUpdatesMock.SetUnitUUID mock is already set by Set")
	}

	expectation := &SessionUpdatesMockSetUnitUUIDExpectation{
		mock:               mmSetUnitUUID.mock,
		params:             &SessionUpdatesMockSetUnitUUIDParams{value},
		expectationOrigins: SessionUpdatesMockSetUnitUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetUnitUUID.expectations = append(mmSetUnitUUID.expectations, expectation)
	return expectation
}

// Then sets up SessionUpdates.SetUnitUUID return parameters for the expectation previously defined by the When method
func (e *SessionUpdatesMockSetUnitUUIDExpectation) Then(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	e.results = &SessionUpdatesMockSetUnitUUIDResults{s1}
	return e.mock
}

// Times sets number of times SessionUpdates.SetUnitUUID should be invoked
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) Times(n uint64) *mSessionUpdatesMockSetUnitUUID {
	if n == 0 {
		mmSetUnitUUID.mock.t.Fatalf("Times of SessionUpdatesMock.SetUnitUUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetUnitUUID.expectedInvocations, n)
	mmSetUnitUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetUnitUUID
}

func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) invocationsDone() bool {
	if len(mmSetUnitUUID.expectations) == 0 && mmSetUnitUUID.defaultExpectation == nil && mmSetUnitUUID.mock.funcSetUnitUUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetUnitUUID.mock.afterSetUnitUUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetUnitUUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetUnitUUID implements mm_repositories.SessionUpdates
func (mmSetUnitUUID *SessionUpdatesMock) SetUnitUUID(value uuid.UUID) (s1 mm_repositories.SessionUpdates) {
	mm_atomic.AddUint64(&mmSetUnitUUID.beforeSetUnitUUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetUnitUUID.afterSetUnitUUIDCounter, 1)

	mmSetUnitUUID.t.Helper()

	if mmSetUnitUUID.inspectFuncSetUnitUUID != nil {
		mmSetUnitUUID.inspectFuncSetUnitUUID(value)
	}

	mm_params := SessionUpdatesMockSetUnitUUIDParams{value}

	// Record call args
	mmSetUnitUUID.SetUnitUUIDMock.mutex.Lock()
	mmSetUnitUUID.SetUnitUUIDMock.callArgs = append(mmSetUnitUUID.SetUnitUUIDMock.callArgs, &mm_params)
	mmSetUnitUUID.SetUnitUUIDMock.mutex.Unlock()

	for _, e := range mmSetUnitUUID.SetUnitUUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetUnitUUID.SetUnitUUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetUnitUUID.SetUnitUUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetUnitUUID.SetUnitUUIDMock.defaultExpectation.params
		mm_want_ptrs := mmSetUnitUUID.SetUnitUUIDMock.defaultExpectation.paramPtrs

		mm_got := SessionUpdatesMockSetUnitUUIDParams{value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetUnitUUID.t.Errorf("SessionUpdatesMock.SetUnitUUID got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetUnitUUID.SetUnitUUIDMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetUnitUUID.t.Errorf("SessionUpdatesMock.SetUnitUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetUnitUUID.SetUnitUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetUnitUUID.SetUnitUUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSetUnitUUID.t.Fatal("No results are set for the SessionUpdatesMock.SetUnitUUID")
		}
		return (*mm_results).s1
	}
	if mmSetUnitUUID.funcSetUnitUUID != nil {
		return mmSetUnitUUID.funcSetUnitUUID(value)
	}
	mmSetUnitUUID.t.Fatalf("Unexpected call to SessionUpdatesMock.SetUnitUUID. %v", value)
	return
}

// SetUnitUUIDAfterCounter returns a count of finished SessionUpdatesMock.SetUnitUUID invocations
func (mmSetUnitUUID *SessionUpdatesMock) SetUnitUUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetUnitUUID.afterSetUnitUUIDCounter)
}

// SetUnitUUIDBeforeCounter returns a count of SessionUpdatesMock.SetUnitUUID invocations
func (mmSetUnitUUID *SessionUpdatesMock) SetUnitUUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetUnitUUID.beforeSetUnitUUIDCounter)
}

// Calls returns a list of arguments used in each call to SessionUpdatesMock.SetUnitUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetUnitUUID *mSessionUpdatesMockSetUnitUUID) Calls() []*SessionUpdatesMockSetUnitUUIDParams {
	mmSetUnitUUID.mutex.RLock()

	argCopy := make([]*SessionUpdatesMockSetUnitUUIDParams, len(mmSetUnitUUID.callArgs))
	copy(argCopy, mmSetUnitUUID.callArgs)

	mmSetUnitUUID.mutex.RUnlock()

	return argCopy
}

// MinimockSetUnitUUIDDone returns true if the count of the SetUnitUUID invocations corresponds
// the number of defined expectations
func (m *SessionUpdatesMock) MinimockSetUnitUUIDDone() bool {
	if m.SetUnitUUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetUnitUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetUnitUUIDMock.invocationsDone()
}

// MinimockSetUnitUUIDInspect logs each unmet expectation
func (m *SessionUpdatesMock) MinimockSetUnitUUIDInspect() {
	for _, e := range m.SetUnitUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetUnitUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetUnitUUIDCounter := mm_atomic.LoadUint64(&m.afterSetUnitUUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetUnitUUIDMock.defaultExpectation != nil && afterSetUnitUUIDCounter < 1 {
		if m.SetUnitUUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetUnitUUID at\n%s", m.SetUnitUUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetUnitUUID at\n%s with params: %#v", m.SetUnitUUIDMock.defaultExpectation.expectationOrigins.origin, *m.SetUnitUUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetUnitUUID != nil && afterSetUnitUUIDCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.SetUnitUUID at\n%s", m.funcSetUnitUUIDOrigin)
	}

	if !m.SetUnitUUIDMock.invocationsDone() && afterSetUnitUUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUpdatesMock.SetUnitUUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetUnitUUIDMock.expectedInvocations), m.SetUnitUUIDMock.expectedInvocationsOrigin, afterSetUnitUUIDCounter)
	}
}

type mSessionUpdatesMockSetUserUUID struct {
	optional           bool
	mock               *SessionUpdatesMock
	defaultExpectation *SessionUpdatesMockSetUserUUIDExpectation
	expectations       []*SessionUpdatesMockSetUserUUIDExpectation

	callArgs []*SessionUpdatesMockSetUserUUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionUpdatesMockSetUserUUIDExpectation specifies expectation struct of the SessionUpdates.SetUserUUID
type SessionUpdatesMockSetUserUUIDExpectation struct {
	mock               *SessionUpdatesMock
	params             *SessionUpdatesMockSetUserUUIDParams
	paramPtrs          *SessionUpdatesMockSetUserUUIDParamPtrs
	expectationOrigins SessionUpdatesMockSetUserUUIDExpectationOrigins
	results            *SessionUpdatesMockSetUserUUIDResults
	returnOrigin       string
	Counter            uint64
}

// SessionUpdatesMockSetUserUUIDParams contains parameters of the SessionUpdates.SetUserUUID
type SessionUpdatesMockSetUserUUIDParams struct {
	value uuid.UUID
}

// SessionUpdatesMockSetUserUUIDParamPtrs contains pointers to parameters of the SessionUpdates.SetUserUUID
type SessionUpdatesMockSetUserUUIDParamPtrs struct {
	value *uuid.UUID
}

// SessionUpdatesMockSetUserUUIDResults contains results of the SessionUpdates.SetUserUUID
type SessionUpdatesMockSetUserUUIDResults struct {
	s1 mm_repositories.SessionUpdates
}

// SessionUpdatesMockSetUserUUIDOrigins contains origins of expectations of the SessionUpdates.SetUserUUID
type SessionUpdatesMockSetUserUUIDExpectationOrigins struct {
	origin      string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) Optional() *mSessionUpdatesMockSetUserUUID {
	mmSetUserUUID.optional = true
	return mmSetUserUUID
}

// Expect sets up expected params for SessionUpdates.SetUserUUID
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) Expect(value uuid.UUID) *mSessionUpdatesMockSetUserUUID {
	if mmSetUserUUID.mock.funcSetUserUUID != nil {
		mmSetUserUUID.mock.t.Fatalf("SessionUpdatesMock.SetUserUUID mock is already set by Set")
	}

	if mmSetUserUUID.defaultExpectation == nil {
		mmSetUserUUID.defaultExpectation = &SessionUpdatesMockSetUserUUIDExpectation{}
	}

	if mmSetUserUUID.defaultExpectation.paramPtrs != nil {
		mmSetUserUUID.mock.t.Fatalf("SessionUpdatesMock.SetUserUUID mock is already set by ExpectParams functions")
	}

	mmSetUserUUID.defaultExpectation.params = &SessionUpdatesMockSetUserUUIDParams{value}
	mmSetUserUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetUserUUID.expectations {
		if minimock.Equal(e.params, mmSetUserUUID.defaultExpectation.params) {
			mmSetUserUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetUserUUID.defaultExpectation.params)
		}
	}

	return mmSetUserUUID
}

// ExpectValueParam1 sets up expected param value for SessionUpdates.SetUserUUID
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) ExpectValueParam1(value uuid.UUID) *mSessionUpdatesMockSetUserUUID {
	if mmSetUserUUID.mock.funcSetUserUUID != nil {
		mmSetUserUUID.mock.t.Fatalf("SessionUpdatesMock.SetUserUUID mock is already set by Set")
	}

	if mmSetUserUUID.defaultExpectation == nil {
		mmSetUserUUID.defaultExpectation = &SessionUpdatesMockSetUserUUIDExpectation{}
	}

	if mmSetUserUUID.defaultExpectation.params != nil {
		mmSetUserUUID.mock.t.Fatalf("SessionUpdatesMock.SetUserUUID mock is already set by Expect")
	}

	if mmSetUserUUID.defaultExpectation.paramPtrs == nil {
		mmSetUserUUID.defaultExpectation.paramPtrs = &SessionUpdatesMockSetUserUUIDParamPtrs{}
	}
	mmSetUserUUID.defaultExpectation.paramPtrs.value = &value
	mmSetUserUUID.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSetUserUUID
}

// Inspect accepts an inspector function that has same arguments as the SessionUpdates.SetUserUUID
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) Inspect(f func(value uuid.UUID)) *mSessionUpdatesMockSetUserUUID {
	if mmSetUserUUID.mock.inspectFuncSetUserUUID != nil {
		mmSetUserUUID.mock.t.Fatalf("Inspect function is already set for SessionUpdatesMock.SetUserUUID")
	}

	mmSetUserUUID.mock.inspectFuncSetUserUUID = f

	return mmSetUserUUID
}

// Return sets up results that will be returned by SessionUpdates.SetUserUUID
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) Return(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	if mmSetUserUUID.mock.funcSetUserUUID != nil {
		mmSetUserUUID.mock.t.Fatalf("SessionUpdatesMock.SetUserUUID mock is already set by Set")
	}

	if mmSetUserUUID.defaultExpectation == nil {
		mmSetUserUUID.defaultExpectation = &SessionUpdatesMockSetUserUUIDExpectation{mock: mmSetUserUUID.mock}
	}
	mmSetUserUUID.defaultExpectation.results = &SessionUpdatesMockSetUserUUIDResults{s1}
	mmSetUserUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetUserUUID.mock
}

// Set uses given function f to mock the SessionUpdates.SetUserUUID method
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) Set(f func(value uuid.UUID) (s1 mm_repositories.SessionUpdates)) *SessionUpdatesMock {
	if mmSetUserUUID.defaultExpectation != nil {
		mmSetUserUUID.mock.t.Fatalf("Default expectation is already set for the SessionUpdates.SetUserUUID method")
	}

	if len(mmSetUserUUID.expectations) > 0 {
		mmSetUserUUID.mock.t.Fatalf("Some expectations are already set for the SessionUpdates.SetUserUUID method")
	}

	mmSetUserUUID.mock.funcSetUserUUID = f
	mmSetUserUUID.mock.funcSetUserUUIDOrigin = minimock.CallerInfo(1)
	return mmSetUserUUID.mock
}

// When sets expectation for the SessionUpdates.SetUserUUID which will trigger the result defined by the following
// Then helper
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) When(value uuid.UUID) *SessionUpdatesMockSetUserUUIDExpectation {
	if mmSetUserUUID.mock.funcSetUserUUID != nil {
		mmSetUserUUID.mock.t.Fatalf("SessionUpdatesMock.SetUserUUID mock is already set by Set")
	}

	expectation := &SessionUpdatesMockSetUserUUIDExpectation{
		mock:               mmSetUserUUID.mock,
		params:             &SessionUpdatesMockSetUserUUIDParams{value},
		expectationOrigins: SessionUpdatesMockSetUserUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetUserUUID.expectations = append(mmSetUserUUID.expectations, expectation)
	return expectation
}

// Then sets up SessionUpdates.SetUserUUID return parameters for the expectation previously defined by the When method
func (e *SessionUpdatesMockSetUserUUIDExpectation) Then(s1 mm_repositories.SessionUpdates) *SessionUpdatesMock {
	e.results = &SessionUpdatesMockSetUserUUIDResults{s1}
	return e.mock
}

// Times sets number of times SessionUpdates.SetUserUUID should be invoked
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) Times(n uint64) *mSessionUpdatesMockSetUserUUID {
	if n == 0 {
		mmSetUserUUID.mock.t.Fatalf("Times of SessionUpdatesMock.SetUserUUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetUserUUID.expectedInvocations, n)
	mmSetUserUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetUserUUID
}

func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) invocationsDone() bool {
	if len(mmSetUserUUID.expectations) == 0 && mmSetUserUUID.defaultExpectation == nil && mmSetUserUUID.mock.funcSetUserUUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetUserUUID.mock.afterSetUserUUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetUserUUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetUserUUID implements mm_repositories.SessionUpdates
func (mmSetUserUUID *SessionUpdatesMock) SetUserUUID(value uuid.UUID) (s1 mm_repositories.SessionUpdates) {
	mm_atomic.AddUint64(&mmSetUserUUID.beforeSetUserUUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetUserUUID.afterSetUserUUIDCounter, 1)

	mmSetUserUUID.t.Helper()

	if mmSetUserUUID.inspectFuncSetUserUUID != nil {
		mmSetUserUUID.inspectFuncSetUserUUID(value)
	}

	mm_params := SessionUpdatesMockSetUserUUIDParams{value}

	// Record call args
	mmSetUserUUID.SetUserUUIDMock.mutex.Lock()
	mmSetUserUUID.SetUserUUIDMock.callArgs = append(mmSetUserUUID.SetUserUUIDMock.callArgs, &mm_params)
	mmSetUserUUID.SetUserUUIDMock.mutex.Unlock()

	for _, e := range mmSetUserUUID.SetUserUUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetUserUUID.SetUserUUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetUserUUID.SetUserUUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetUserUUID.SetUserUUIDMock.defaultExpectation.params
		mm_want_ptrs := mmSetUserUUID.SetUserUUIDMock.defaultExpectation.paramPtrs

		mm_got := SessionUpdatesMockSetUserUUIDParams{value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetUserUUID.t.Errorf("SessionUpdatesMock.SetUserUUID got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetUserUUID.SetUserUUIDMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetUserUUID.t.Errorf("SessionUpdatesMock.SetUserUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetUserUUID.SetUserUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetUserUUID.SetUserUUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSetUserUUID.t.Fatal("No results are set for the SessionUpdatesMock.SetUserUUID")
		}
		return (*mm_results).s1
	}
	if mmSetUserUUID.funcSetUserUUID != nil {
		return mmSetUserUUID.funcSetUserUUID(value)
	}
	mmSetUserUUID.t.Fatalf("Unexpected call to SessionUpdatesMock.SetUserUUID. %v", value)
	return
}

// SetUserUUIDAfterCounter returns a count of finished SessionUpdatesMock.SetUserUUID invocations
func (mmSetUserUUID *SessionUpdatesMock) SetUserUUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetUserUUID.afterSetUserUUIDCounter)
}

// SetUserUUIDBeforeCounter returns a count of SessionUpdatesMock.SetUserUUID invocations
func (mmSetUserUUID *SessionUpdatesMock) SetUserUUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetUserUUID.beforeSetUserUUIDCounter)
}

// Calls returns a list of arguments used in each call to SessionUpdatesMock.SetUserUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetUserUUID *mSessionUpdatesMockSetUserUUID) Calls() []*SessionUpdatesMockSetUserUUIDParams {
	mmSetUserUUID.mutex.RLock()

	argCopy := make([]*SessionUpdatesMockSetUserUUIDParams, len(mmSetUserUUID.callArgs))
	copy(argCopy, mmSetUserUUID.callArgs)

	mmSetUserUUID.mutex.RUnlock()

	return argCopy
}

// MinimockSetUserUUIDDone returns true if the count of the SetUserUUID invocations corresponds
// the number of defined expectations
func (m *SessionUpdatesMock) MinimockSetUserUUIDDone() bool {
	if m.SetUserUUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetUserUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetUserUUIDMock.invocationsDone()
}

// MinimockSetUserUUIDInspect logs each unmet expectation
func (m *SessionUpdatesMock) MinimockSetUserUUIDInspect() {
	for _, e := range m.SetUserUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetUserUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetUserUUIDCounter := mm_atomic.LoadUint64(&m.afterSetUserUUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetUserUUIDMock.defaultExpectation != nil && afterSetUserUUIDCounter < 1 {
		if m.SetUserUUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetUserUUID at\n%s", m.SetUserUUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionUpdatesMock.SetUserUUID at\n%s with params: %#v", m.SetUserUUIDMock.defaultExpectation.expectationOrigins.origin, *m.SetUserUUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetUserUUID != nil && afterSetUserUUIDCounter < 1 {
		m.t.Errorf("Expected call to SessionUpdatesMock.SetUserUUID at\n%s", m.funcSetUserUUIDOrigin)
	}

	if !m.SetUserUUIDMock.invocationsDone() && afterSetUserUUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionUpdatesMock.SetUserUUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetUserUUIDMock.expectedInvocations), m.SetUserUUIDMock.expectedInvocationsOrigin, afterSetUserUUIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SessionUpdatesMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockHaveUpdatesInspect()

			m.MinimockSetCarUUIDInspect()

			m.MinimockSetCostInspect()

			m.MinimockSetFinishAtInspect()

			m.MinimockSetParkingUUIDInspect()

			m.MinimockSetStatusInspect()

			m.MinimockSetUnitUUIDInspect()

			m.MinimockSetUserUUIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SessionUpdatesMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SessionUpdatesMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockHaveUpdatesDone() &&
		m.MinimockSetCarUUIDDone() &&
		m.MinimockSetCostDone() &&
		m.MinimockSetFinishAtDone() &&
		m.MinimockSetParkingUUIDDone() &&
		m.MinimockSetStatusDone() &&
		m.MinimockSetUnitUUIDDone() &&
		m.MinimockSetUserUUIDDone()
}
