// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain/repositories.SessionFilter -o session_filter_mock_test.go -n SessionFilterMock -p mocks

import (
	mm_repositories "k071123/internal/services/parking_service/domain/repositories"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SessionFilterMock implements mm_repositories.SessionFilter
type SessionFilterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcSetCarUUIDs          func(sa1 []string) (s1 mm_repositories.SessionFilter)
	funcSetCarUUIDsOrigin    string
	inspectFuncSetCarUUIDs   func(sa1 []string)
	afterSetCarUUIDsCounter  uint64
	beforeSetCarUUIDsCounter uint64
	SetCarUUIDsMock          mSessionFilterMockSetCarUUIDs

	funcSetStatuses          func(sa1 []string) (s1 mm_repositories.SessionFilter)
	funcSetStatusesOrigin    string
	inspectFuncSetStatuses   func(sa1 []string)
	afterSetStatusesCounter  uint64
	beforeSetStatusesCounter uint64
	SetStatusesMock          mSessionFilterMockSetStatuses

	funcSetUUIDs          func(sa1 []string) (s1 mm_repositories.SessionFilter)
	funcSetUUIDsOrigin    string
	inspectFuncSetUUIDs   func(sa1 []string)
	afterSetUUIDsCounter  uint64
	beforeSetUUIDsCounter uint64
	SetUUIDsMock          mSessionFilterMockSetUUIDs
}

// NewSessionFilterMock returns a mock for mm_repositories.SessionFilter
func NewSessionFilterMock(t minimock.Tester) *SessionFilterMock {
	m := &SessionFilterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SetCarUUIDsMock = mSessionFilterMockSetCarUUIDs{mock: m}
	m.SetCarUUIDsMock.callArgs = []*SessionFilterMockSetCarUUIDsParams{}

	m.SetStatusesMock = mSessionFilterMockSetStatuses{mock: m}
	m.SetStatusesMock.callArgs = []*SessionFilterMockSetStatusesParams{}

	m.SetUUIDsMock = mSessionFilterMockSetUUIDs{mock: m}
	m.SetUUIDsMock.callArgs = []*SessionFilterMockSetUUIDsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSessionFilterMockSetCarUUIDs struct {
	optional           bool
	mock               *SessionFilterMock
	defaultExpectation *SessionFilterMockSetCarUUIDsExpectation
	expectations       []*SessionFilterMockSetCarUUIDsExpectation

	callArgs []*SessionFilterMockSetCarUUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionFilterMockSetCarUUIDsExpectation specifies expectation struct of the SessionFilter.SetCarUUIDs
type SessionFilterMockSetCarUUIDsExpectation struct {
	mock               *SessionFilterMock
	params             *SessionFilterMockSetCarUUIDsParams
	paramPtrs          *SessionFilterMockSetCarUUIDsParamPtrs
	expectationOrigins SessionFilterMockSetCarUUIDsExpectationOrigins
	results            *SessionFilterMockSetCarUUIDsResults
	returnOrigin       string
	Counter            uint64
}

// SessionFilterMockSetCarUUIDsParams contains parameters of the SessionFilter.SetCarUUIDs
type SessionFilterMockSetCarUUIDsParams struct {
	sa1 []string
}

// SessionFilterMockSetCarUUIDsParamPtrs contains pointers to parameters of the SessionFilter.SetCarUUIDs
type SessionFilterMockSetCarUUIDsParamPtrs struct {
	sa1 *[]string
}

// SessionFilterMockSetCarUUIDsResults contains results of the SessionFilter.SetCarUUIDs
type SessionFilterMockSetCarUUIDsResults struct {
	s1 mm_repositories.SessionFilter
}

// SessionFilterMockSetCarUUIDsOrigins contains origins of expectations of the SessionFilter.SetCarUUIDs
type SessionFilterMockSetCarUUIDsExpectationOrigins struct {
	origin    string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) Optional() *mSessionFilterMockSetCarUUIDs {
	mmSetCarUUIDs.optional = true
	return mmSetCarUUIDs
}

// Expect sets up expected params for SessionFilter.SetCarUUIDs
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) Expect(sa1 []string) *mSessionFilterMockSetCarUUIDs {
	if mmSetCarUUIDs.mock.funcSetCarUUIDs != nil {
		mmSetCarUUIDs.mock.t.Fatalf("SessionFilterMock.SetCarUUIDs mock is already set by Set")
	}

	if mmSetCarUUIDs.defaultExpectation == nil {
		mmSetCarUUIDs.defaultExpectation = &SessionFilterMockSetCarUUIDsExpectation{}
	}

	if mmSetCarUUIDs.defaultExpectation.paramPtrs != nil {
		mmSetCarUUIDs.mock.t.Fatalf("SessionFilterMock.SetCarUUIDs mock is already set by ExpectParams functions")
	}

	mmSetCarUUIDs.defaultExpectation.params = &SessionFilterMockSetCarUUIDsParams{sa1}
	mmSetCarUUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetCarUUIDs.expectations {
		if minimock.Equal(e.params, mmSetCarUUIDs.defaultExpectation.params) {
			mmSetCarUUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetCarUUIDs.defaultExpectation.params)
		}
	}

	return mmSetCarUUIDs
}

// ExpectSa1Param1 sets up expected param sa1 for SessionFilter.SetCarUUIDs
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) ExpectSa1Param1(sa1 []string) *mSessionFilterMockSetCarUUIDs {
	if mmSetCarUUIDs.mock.funcSetCarUUIDs != nil {
		mmSetCarUUIDs.mock.t.Fatalf("SessionFilterMock.SetCarUUIDs mock is already set by Set")
	}

	if mmSetCarUUIDs.defaultExpectation == nil {
		mmSetCarUUIDs.defaultExpectation = &SessionFilterMockSetCarUUIDsExpectation{}
	}

	if mmSetCarUUIDs.defaultExpectation.params != nil {
		mmSetCarUUIDs.mock.t.Fatalf("SessionFilterMock.SetCarUUIDs mock is already set by Expect")
	}

	if mmSetCarUUIDs.defaultExpectation.paramPtrs == nil {
		mmSetCarUUIDs.defaultExpectation.paramPtrs = &SessionFilterMockSetCarUUIDsParamPtrs{}
	}
	mmSetCarUUIDs.defaultExpectation.paramPtrs.sa1 = &sa1
	mmSetCarUUIDs.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmSetCarUUIDs
}

// Inspect accepts an inspector function that has same arguments as the SessionFilter.SetCarUUIDs
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) Inspect(f func(sa1 []string)) *mSessionFilterMockSetCarUUIDs {
	if mmSetCarUUIDs.mock.inspectFuncSetCarUUIDs != nil {
		mmSetCarUUIDs.mock.t.Fatalf("Inspect function is already set for SessionFilterMock.SetCarUUIDs")
	}

	mmSetCarUUIDs.mock.inspectFuncSetCarUUIDs = f

	return mmSetCarUUIDs
}

// Return sets up results that will be returned by SessionFilter.SetCarUUIDs
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) Return(s1 mm_repositories.SessionFilter) *SessionFilterMock {
	if mmSetCarUUIDs.mock.funcSetCarUUIDs != nil {
		mmSetCarUUIDs.mock.t.Fatalf("SessionFilterMock.SetCarUUIDs mock is already set by Set")
	}

	if mmSetCarUUIDs.defaultExpectation == nil {
		mmSetCarUUIDs.defaultExpectation = &SessionFilterMockSetCarUUIDsExpectation{mock: mmSetCarUUIDs.mock}
	}
	mmSetCarUUIDs.defaultExpectation.results = &SessionFilterMockSetCarUUIDsResults{s1}
	mmSetCarUUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetCarUUIDs.mock
}

// Set uses given function f to mock the SessionFilter.SetCarUUIDs method
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) Set(f func(sa1 []string) (s1 mm_repositories.SessionFilter)) *SessionFilterMock {
	if mmSetCarUUIDs.defaultExpectation != nil {
		mmSetCarUUIDs.mock.t.Fatalf("Default expectation is already set for the SessionFilter.SetCarUUIDs method")
	}

	if len(mmSetCarUUIDs.expectations) > 0 {
		mmSetCarUUIDs.mock.t.Fatalf("Some expectations are already set for the SessionFilter.SetCarUUIDs method")
	}

	mmSetCarUUIDs.mock.funcSetCarUUIDs = f
	mmSetCarUUIDs.mock.funcSetCarUUIDsOrigin = minimock.CallerInfo(1)
	return mmSetCarUUIDs.mock
}

// When sets expectation for the SessionFilter.SetCarUUIDs which will trigger the result defined by the following
// Then helper
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) When(sa1 []string) *SessionFilterMockSetCarUUIDsExpectation {
	if mmSetCarUUIDs.mock.funcSetCarUUIDs != nil {
		mmSetCarUUIDs.mock.t.Fatalf("SessionFilterMock.SetCarUUIDs mock is already set by Set")
	}

	expectation := &SessionFilterMockSetCarUUIDsExpectation{
		mock:               mmSetCarUUIDs.mock,
		params:             &SessionFilterMockSetCarUUIDsParams{sa1},
		expectationOrigins: SessionFilterMockSetCarUUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetCarUUIDs.expectations = append(mmSetCarUUIDs.expectations, expectation)
	return expectation
}

// Then sets up SessionFilter.SetCarUUIDs return parameters for the expectation previously defined by the When method
func (e *SessionFilterMockSetCarUUIDsExpectation) Then(s1 mm_repositories.SessionFilter) *SessionFilterMock {
	e.results = &SessionFilterMockSetCarUUIDsResults{s1}
	return e.mock
}

// Times sets number of times SessionFilter.SetCarUUIDs should be invoked
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) Times(n uint64) *mSessionFilterMockSetCarUUIDs {
	if n == 0 {
		mmSetCarUUIDs.mock.t.Fatalf("Times of SessionFilterMock.SetCarUUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetCarUUIDs.expectedInvocations, n)
	mmSetCarUUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetCarUUIDs
}

func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) invocationsDone() bool {
	if len(mmSetCarUUIDs.expectations) == 0 && mmSetCarUUIDs.defaultExpectation == nil && mmSetCarUUIDs.mock.funcSetCarUUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetCarUUIDs.mock.afterSetCarUUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetCarUUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetCarUUIDs implements mm_repositories.SessionFilter
func (mmSetCarUUIDs *SessionFilterMock) SetCarUUIDs(sa1 []string) (s1 mm_repositories.SessionFilter) {
	mm_atomic.AddUint64(&mmSetCarUUIDs.beforeSetCarUUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetCarUUIDs.afterSetCarUUIDsCounter, 1)

	mmSetCarUUIDs.t.Helper()

	if mmSetCarUUIDs.inspectFuncSetCarUUIDs != nil {
		mmSetCarUUIDs.inspectFuncSetCarUUIDs(sa1)
	}

	mm_params := SessionFilterMockSetCarUUIDsParams{sa1}

	// Record call args
	mmSetCarUUIDs.SetCarUUIDsMock.mutex.Lock()
	mmSetCarUUIDs.SetCarUUIDsMock.callArgs = append(mmSetCarUUIDs.SetCarUUIDsMock.callArgs, &mm_params)
	mmSetCarUUIDs.SetCarUUIDsMock.mutex.Unlock()

	for _, e := range mmSetCarUUIDs.SetCarUUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetCarUUIDs.SetCarUUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetCarUUIDs.SetCarUUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetCarUUIDs.SetCarUUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmSetCarUUIDs.SetCarUUIDsMock.defaultExpectation.paramPtrs

		mm_got := SessionFilterMockSetCarUUIDsParams{sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmSetCarUUIDs.t.Errorf("SessionFilterMock.SetCarUUIDs got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCarUUIDs.SetCarUUIDsMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetCarUUIDs.t.Errorf("SessionFilterMock.SetCarUUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetCarUUIDs.SetCarUUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetCarUUIDs.SetCarUUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmSetCarUUIDs.t.Fatal("No results are set for the SessionFilterMock.SetCarUUIDs")
		}
		return (*mm_results).s1
	}
	if mmSetCarUUIDs.funcSetCarUUIDs != nil {
		return mmSetCarUUIDs.funcSetCarUUIDs(sa1)
	}
	mmSetCarUUIDs.t.Fatalf("Unexpected call to SessionFilterMock.SetCarUUIDs. %v", sa1)
	return
}

// SetCarUUIDsAfterCounter returns a count of finished SessionFilterMock.SetCarUUIDs invocations
func (mmSetCarUUIDs *SessionFilterMock) SetCarUUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCarUUIDs.afterSetCarUUIDsCounter)
}

// SetCarUUIDsBeforeCounter returns a count of SessionFilterMock.SetCarUUIDs invocations
func (mmSetCarUUIDs *SessionFilterMock) SetCarUUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCarUUIDs.beforeSetCarUUIDsCounter)
}

// Calls returns a list of arguments used in each call to SessionFilterMock.SetCarUUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetCarUUIDs *mSessionFilterMockSetCarUUIDs) Calls() []*SessionFilterMockSetCarUUIDsParams {
	mmSetCarUUIDs.mutex.RLock()

	argCopy := make([]*SessionFilterMockSetCarUUIDsParams, len(mmSetCarUUIDs.callArgs))
	copy(argCopy, mmSetCarUUIDs.callArgs)

	mmSetCarUUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockSetCarUUIDsDone returns true if the count of the SetCarUUIDs invocations corresponds
// the number of defined expectations
func (m *SessionFilterMock) MinimockSetCarUUIDsDone() bool {
	if m.SetCarUUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetCarUUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetCarUUIDsMock.invocationsDone()
}

// MinimockSetCarUUIDsInspect logs each unmet expectation
func (m *SessionFilterMock) MinimockSetCarUUIDsInspect() {
	for _, e := range m.SetCarUUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionFilterMock.SetCarUUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCarUUIDsCounter := mm_atomic.LoadUint64(&m.afterSetCarUUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetCarUUIDsMock.defaultExpectation != nil && afterSetCarUUIDsCounter < 1 {
		if m.SetCarUUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionFilterMock.SetCarUUIDs at\n%s", m.SetCarUUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionFilterMock.SetCarUUIDs at\n%s with params: %#v", m.SetCarUUIDsMock.defaultExpectation.expectationOrigins.origin, *m.SetCarUUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCarUUIDs != nil && afterSetCarUUIDsCounter < 1 {
		m.t.Errorf("Expected call to SessionFilterMock.SetCarUUIDs at\n%s", m.funcSetCarUUIDsOrigin)
	}

	if !m.SetCarUUIDsMock.invocationsDone() && afterSetCarUUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionFilterMock.SetCarUUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetCarUUIDsMock.expectedInvocations), m.SetCarUUIDsMock.expectedInvocationsOrigin, afterSetCarUUIDsCounter)
	}
}

type mSessionFilterMockSetStatuses struct {
	optional           bool
	mock               *SessionFilterMock
	defaultExpectation *SessionFilterMockSetStatusesExpectation
	expectations       []*SessionFilterMockSetStatusesExpectation

	callArgs []*SessionFilterMockSetStatusesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionFilterMockSetStatusesExpectation specifies expectation struct of the SessionFilter.SetStatuses
type SessionFilterMockSetStatusesExpectation struct {
	mock               *SessionFilterMock
	params             *SessionFilterMockSetStatusesParams
	paramPtrs          *SessionFilterMockSetStatusesParamPtrs
	expectationOrigins SessionFilterMockSetStatusesExpectationOrigins
	results            *SessionFilterMockSetStatusesResults
	returnOrigin       string
	Counter            uint64
}

// SessionFilterMockSetStatusesParams contains parameters of the SessionFilter.SetStatuses
type SessionFilterMockSetStatusesParams struct {
	sa1 []string
}

// SessionFilterMockSetStatusesParamPtrs contains pointers to parameters of the SessionFilter.SetStatuses
type SessionFilterMockSetStatusesParamPtrs struct {
	sa1 *[]string
}

// SessionFilterMockSetStatusesResults contains results of the SessionFilter.SetStatuses
type SessionFilterMockSetStatusesResults struct {
	s1 mm_repositories.SessionFilter
}

// SessionFilterMockSetStatusesOrigins contains origins of expectations of the SessionFilter.SetStatuses
type SessionFilterMockSetStatusesExpectationOrigins struct {
	origin    string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatuses *mSessionFilterMockSetStatuses) Optional() *mSessionFilterMockSetStatuses {
	mmSetStatuses.optional = true
	return mmSetStatuses
}

// Expect sets up expected params for SessionFilter.SetStatuses
func (mmSetStatuses *mSessionFilterMockSetStatuses) Expect(sa1 []string) *mSessionFilterMockSetStatuses {
	if mmSetStatuses.mock.funcSetStatuses != nil {
		mmSetStatuses.mock.t.Fatalf("SessionFilterMock.SetStatuses mock is already set by Set")
	}

	if mmSetStatuses.defaultExpectation == nil {
		mmSetStatuses.defaultExpectation = &SessionFilterMockSetStatusesExpectation{}
	}

	if mmSetStatuses.defaultExpectation.paramPtrs != nil {
		mmSetStatuses.mock.t.Fatalf("SessionFilterMock.SetStatuses mock is already set by ExpectParams functions")
	}

	mmSetStatuses.defaultExpectation.params = &SessionFilterMockSetStatusesParams{sa1}
	mmSetStatuses.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatuses.expectations {
		if minimock.Equal(e.params, mmSetStatuses.defaultExpectation.params) {
			mmSetStatuses.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatuses.defaultExpectation.params)
		}
	}

	return mmSetStatuses
}

// ExpectSa1Param1 sets up expected param sa1 for SessionFilter.SetStatuses
func (mmSetStatuses *mSessionFilterMockSetStatuses) ExpectSa1Param1(sa1 []string) *mSessionFilterMockSetStatuses {
	if mmSetStatuses.mock.funcSetStatuses != nil {
		mmSetStatuses.mock.t.Fatalf("SessionFilterMock.SetStatuses mock is already set by Set")
	}

	if mmSetStatuses.defaultExpectation == nil {
		mmSetStatuses.defaultExpectation = &SessionFilterMockSetStatusesExpectation{}
	}

	if mmSetStatuses.defaultExpectation.params != nil {
		mmSetStatuses.mock.t.Fatalf("SessionFilterMock.SetStatuses mock is already set by Expect")
	}

	if mmSetStatuses.defaultExpectation.paramPtrs == nil {
		mmSetStatuses.defaultExpectation.paramPtrs = &SessionFilterMockSetStatusesParamPtrs{}
	}
	mmSetStatuses.defaultExpectation.paramPtrs.sa1 = &sa1
	mmSetStatuses.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmSetStatuses
}

// Inspect accepts an inspector function that has same arguments as the SessionFilter.SetStatuses
func (mmSetStatuses *mSessionFilterMockSetStatuses) Inspect(f func(sa1 []string)) *mSessionFilterMockSetStatuses {
	if mmSetStatuses.mock.inspectFuncSetStatuses != nil {
		mmSetStatuses.mock.t.Fatalf("Inspect function is already set for SessionFilterMock.SetStatuses")
	}

	mmSetStatuses.mock.inspectFuncSetStatuses = f

	return mmSetStatuses
}

// Return sets up results that will be returned by SessionFilter.SetStatuses
func (mmSetStatuses *mSessionFilterMockSetStatuses) Return(s1 mm_repositories.SessionFilter) *SessionFilterMock {
	if mmSetStatuses.mock.funcSetStatuses != nil {
		mmSetStatuses.mock.t.Fatalf("SessionFilterMock.SetStatuses mock is already set by Set")
	}

	if mmSetStatuses.defaultExpectation == nil {
		mmSetStatuses.defaultExpectation = &SessionFilterMockSetStatusesExpectation{mock: mmSetStatuses.mock}
	}
	mmSetStatuses.defaultExpectation.results = &SessionFilterMockSetStatusesResults{s1}
	mmSetStatuses.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatuses.mock
}

// Set uses given function f to mock the SessionFilter.SetStatuses method
func (mmSetStatuses *mSessionFilterMockSetStatuses) Set(f func(sa1 []string) (s1 mm_repositories.SessionFilter)) *SessionFilterMock {
	if mmSetStatuses.defaultExpectation != nil {
		mmSetStatuses.mock.t.Fatalf("Default expectation is already set for the SessionFilter.SetStatuses method")
	}

	if len(mmSetStatuses.expectations) > 0 {
		mmSetStatuses.mock.t.Fatalf("Some expectations are already set for the SessionFilter.SetStatuses method")
	}

	mmSetStatuses.mock.funcSetStatuses = f
	mmSetStatuses.mock.funcSetStatusesOrigin = minimock.CallerInfo(1)
	return mmSetStatuses.mock
}

// When sets expectation for the SessionFilter.SetStatuses which will trigger the result defined by the following
// Then helper
func (mmSetStatuses *mSessionFilterMockSetStatuses) When(sa1 []string) *SessionFilterMockSetStatusesExpectation {
	if mmSetStatuses.mock.funcSetStatuses != nil {
		mmSetStatuses.mock.t.Fatalf("SessionFilterMock.SetStatuses mock is already set by Set")
	}

	expectation := &SessionFilterMockSetStatusesExpectation{
		mock:               mmSetStatuses.mock,
		params:             &SessionFilterMockSetStatusesParams{sa1},
		expectationOrigins: SessionFilterMockSetStatusesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatuses.expectations = append(mmSetStatuses.expectations, expectation)
	return expectation
}

// Then sets up SessionFilter.SetStatuses return parameters for the expectation previously defined by the When method
func (e *SessionFilterMockSetStatusesExpectation) Then(s1 mm_repositories.SessionFilter) *SessionFilterMock {
	e.results = &SessionFilterMockSetStatusesResults{s1}
	return e.mock
}

// Times sets number of times SessionFilter.SetStatuses should be invoked
func (mmSetStatuses *mSessionFilterMockSetStatuses) Times(n uint64) *mSessionFilterMockSetStatuses {
	if n == 0 {
		mmSetStatuses.mock.t.Fatalf("Times of SessionFilterMock.SetStatuses mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatuses.expectedInvocations, n)
	mmSetStatuses.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatuses
}

func (mmSetStatuses *mSessionFilterMockSetStatuses) invocationsDone() bool {
	if len(mmSetStatuses.expectations) == 0 && mmSetStatuses.defaultExpectation == nil && mmSetStatuses.mock.funcSetStatuses == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatuses.mock.afterSetStatusesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatuses.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatuses implements mm_repositories.SessionFilter
func (mmSetStatuses *SessionFilterMock) SetStatuses(sa1 []string) (s1 mm_repositories.SessionFilter) {
	mm_atomic.AddUint64(&mmSetStatuses.beforeSetStatusesCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatuses.afterSetStatusesCounter, 1)

	mmSetStatuses.t.Helper()

	if mmSetStatuses.inspectFuncSetStatuses != nil {
		mmSetStatuses.inspectFuncSetStatuses(sa1)
	}

	mm_params := SessionFilterMockSetStatusesParams{sa1}

	// Record call args
	mmSetStatuses.SetStatusesMock.mutex.Lock()
	mmSetStatuses.SetStatusesMock.callArgs = append(mmSetStatuses.SetStatusesMock.callArgs, &mm_params)
	mmSetStatuses.SetStatusesMock.mutex.Unlock()

	for _, e := range mmSetStatuses.SetStatusesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetStatuses.SetStatusesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatuses.SetStatusesMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatuses.SetStatusesMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatuses.SetStatusesMock.defaultExpectation.paramPtrs

		mm_got := SessionFilterMockSetStatusesParams{sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmSetStatuses.t.Errorf("SessionFilterMock.SetStatuses got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatuses.SetStatusesMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatuses.t.Errorf("SessionFilterMock.SetStatuses got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatuses.SetStatusesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatuses.SetStatusesMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatuses.t.Fatal("No results are set for the SessionFilterMock.SetStatuses")
		}
		return (*mm_results).s1
	}
	if mmSetStatuses.funcSetStatuses != nil {
		return mmSetStatuses.funcSetStatuses(sa1)
	}
	mmSetStatuses.t.Fatalf("Unexpected call to SessionFilterMock.SetStatuses. %v", sa1)
	return
}

// SetStatusesAfterCounter returns a count of finished SessionFilterMock.SetStatuses invocations
func (mmSetStatuses *SessionFilterMock) SetStatusesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatuses.afterSetStatusesCounter)
}

// SetStatusesBeforeCounter returns a count of SessionFilterMock.SetStatuses invocations
func (mmSetStatuses *SessionFilterMock) SetStatusesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatuses.beforeSetStatusesCounter)
}

// Calls returns a list of arguments used in each call to SessionFilterMock.SetStatuses.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatuses *mSessionFilterMockSetStatuses) Calls() []*SessionFilterMockSetStatusesParams {
	mmSetStatuses.mutex.RLock()

	argCopy := make([]*SessionFilterMockSetStatusesParams, len(mmSetStatuses.callArgs))
	copy(argCopy, mmSetStatuses.callArgs)

	mmSetStatuses.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusesDone returns true if the count of the SetStatuses invocations corresponds
// the number of defined expectations
func (m *SessionFilterMock) MinimockSetStatusesDone() bool {
	if m.SetStatusesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusesMock.invocationsDone()
}

// MinimockSetStatusesInspect logs each unmet expectation
func (m *SessionFilterMock) MinimockSetStatusesInspect() {
	for _, e := range m.SetStatusesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionFilterMock.SetStatuses at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusesCounter := mm_atomic.LoadUint64(&m.afterSetStatusesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusesMock.defaultExpectation != nil && afterSetStatusesCounter < 1 {
		if m.SetStatusesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionFilterMock.SetStatuses at\n%s", m.SetStatusesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionFilterMock.SetStatuses at\n%s with params: %#v", m.SetStatusesMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatuses != nil && afterSetStatusesCounter < 1 {
		m.t.Errorf("Expected call to SessionFilterMock.SetStatuses at\n%s", m.funcSetStatusesOrigin)
	}

	if !m.SetStatusesMock.invocationsDone() && afterSetStatusesCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionFilterMock.SetStatuses at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusesMock.expectedInvocations), m.SetStatusesMock.expectedInvocationsOrigin, afterSetStatusesCounter)
	}
}

type mSessionFilterMockSetUUIDs struct {
	optional           bool
	mock               *SessionFilterMock
	defaultExpectation *SessionFilterMockSetUUIDsExpectation
	expectations       []*SessionFilterMockSetUUIDsExpectation

	callArgs []*SessionFilterMockSetUUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SessionFilterMockSetUUIDsExpectation specifies expectation struct of the SessionFilter.SetUUIDs
type SessionFilterMockSetUUIDsExpectation struct {
	mock               *SessionFilterMock
	params             *SessionFilterMockSetUUIDsParams
	paramPtrs          *SessionFilterMockSetUUIDsParamPtrs
	expectationOrigins SessionFilterMockSetUUIDsExpectationOrigins
	results            *SessionFilterMockSetUUIDsResults
	returnOrigin       string
	Counter            uint64
}

// SessionFilterMockSetUUIDsParams contains parameters of the SessionFilter.SetUUIDs
type SessionFilterMockSetUUIDsParams struct {
	sa1 []string
}

// SessionFilterMockSetUUIDsParamPtrs contains pointers to parameters of the SessionFilter.SetUUIDs
type SessionFilterMockSetUUIDsParamPtrs struct {
	sa1 *[]string
}

// SessionFilterMockSetUUIDsResults contains results of the SessionFilter.SetUUIDs
type SessionFilterMockSetUUIDsResults struct {
	s1 mm_repositories.SessionFilter
}

// SessionFilterMockSetUUIDsOrigins contains origins of expectations of the SessionFilter.SetUUIDs
type SessionFilterMockSetUUIDsExpectationOrigins struct {
	origin    string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) Optional() *mSessionFilterMockSetUUIDs {
	mmSetUUIDs.optional = true
	return mmSetUUIDs
}

// Expect sets up expected params for SessionFilter.SetUUIDs
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) Expect(sa1 []string) *mSessionFilterMockSetUUIDs {
	if mmSetUUIDs.mock.funcSetUUIDs != nil {
		mmSetUUIDs.mock.t.Fatalf("SessionFilterMock.SetUUIDs mock is already set by Set")
	}

	if mmSetUUIDs.defaultExpectation == nil {
		mmSetUUIDs.defaultExpectation = &SessionFilterMockSetUUIDsExpectation{}
	}

	if mmSetUUIDs.defaultExpectation.paramPtrs != nil {
		mmSetUUIDs.mock.t.Fatalf("SessionFilterMock.SetUUIDs mock is already set by ExpectParams functions")
	}

	mmSetUUIDs.defaultExpectation.params = &SessionFilterMockSetUUIDsParams{sa1}
	mmSetUUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetUUIDs.expectations {
		if minimock.Equal(e.params, mmSetUUIDs.defaultExpectation.params) {
			mmSetUUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetUUIDs.defaultExpectation.params)
		}
	}

	return mmSetUUIDs
}

// ExpectSa1Param1 sets up expected param sa1 for SessionFilter.SetUUIDs
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) ExpectSa1Param1(sa1 []string) *mSessionFilterMockSetUUIDs {
	if mmSetUUIDs.mock.funcSetUUIDs != nil {
		mmSetUUIDs.mock.t.Fatalf("SessionFilterMock.SetUUIDs mock is already set by Set")
	}

	if mmSetUUIDs.defaultExpectation == nil {
		mmSetUUIDs.defaultExpectation = &SessionFilterMockSetUUIDsExpectation{}
	}

	if mmSetUUIDs.defaultExpectation.params != nil {
		mmSetUUIDs.mock.t.Fatalf("SessionFilterMock.SetUUIDs mock is already set by Expect")
	}

	if mmSetUUIDs.defaultExpectation.paramPtrs == nil {
		mmSetUUIDs.defaultExpectation.paramPtrs = &SessionFilterMockSetUUIDsParamPtrs{}
	}
	mmSetUUIDs.defaultExpectation.paramPtrs.sa1 = &sa1
	mmSetUUIDs.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmSetUUIDs
}

// Inspect accepts an inspector function that has same arguments as the SessionFilter.SetUUIDs
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) Inspect(f func(sa1 []string)) *mSessionFilterMockSetUUIDs {
	if mmSetUUIDs.mock.inspectFuncSetUUIDs != nil {
		mmSetUUIDs.mock.t.Fatalf("Inspect function is already set for SessionFilterMock.SetUUIDs")
	}

	mmSetUUIDs.mock.inspectFuncSetUUIDs = f

	return mmSetUUIDs
}

// Return sets up results that will be returned by SessionFilter.SetUUIDs
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) Return(s1 mm_repositories.SessionFilter) *SessionFilterMock {
	if mmSetUUIDs.mock.funcSetUUIDs != nil {
		mmSetUUIDs.mock.t.Fatalf("SessionFilterMock.SetUUIDs mock is already set by Set")
	}

	if mmSetUUIDs.defaultExpectation == nil {
		mmSetUUIDs.defaultExpectation = &SessionFilterMockSetUUIDsExpectation{mock: mmSetUUIDs.mock}
	}
	mmSetUUIDs.defaultExpectation.results = &SessionFilterMockSetUUIDsResults{s1}
	mmSetUUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetUUIDs.mock
}

// Set uses given function f to mock the SessionFilter.SetUUIDs method
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) Set(f func(sa1 []string) (s1 mm_repositories.SessionFilter)) *SessionFilterMock {
	if mmSetUUIDs.defaultExpectation != nil {
		mmSetUUIDs.mock.t.Fatalf("Default expectation is already set for the SessionFilter.SetUUIDs method")
	}

	if len(mmSetUUIDs.expectations) > 0 {
		mmSetUUIDs.mock.t.Fatalf("Some expectations are already set for the SessionFilter.SetUUIDs method")
	}

	mmSetUUIDs.mock.funcSetUUIDs = f
	mmSetUUIDs.mock.funcSetUUIDsOrigin = minimock.CallerInfo(1)
	return mmSetUUIDs.mock
}

// When sets expectation for the SessionFilter.SetUUIDs which will trigger the result defined by the following
// Then helper
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) When(sa1 []string) *SessionFilterMockSetUUIDsExpectation {
	if mmSetUUIDs.mock.funcSetUUIDs != nil {
		mmSetUUIDs.mock.t.Fatalf("SessionFilterMock.SetUUIDs mock is already set by Set")
	}

	expectation := &SessionFilterMockSetUUIDsExpectation{
		mock:               mmSetUUIDs.mock,
		params:             &SessionFilterMockSetUUIDsParams{sa1},
		expectationOrigins: SessionFilterMockSetUUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetUUIDs.expectations = append(mmSetUUIDs.expectations, expectation)
	return expectation
}

// Then sets up SessionFilter.SetUUIDs return parameters for the expectation previously defined by the When method
func (e *SessionFilterMockSetUUIDsExpectation) Then(s1 mm_repositories.SessionFilter) *SessionFilterMock {
	e.results = &SessionFilterMockSetUUIDsResults{s1}
	return e.mock
}

// Times sets number of times SessionFilter.SetUUIDs should be invoked
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) Times(n uint64) *mSessionFilterMockSetUUIDs {
	if n == 0 {
		mmSetUUIDs.mock.t.Fatalf("Times of SessionFilterMock.SetUUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetUUIDs.expectedInvocations, n)
	mmSetUUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetUUIDs
}

func (mmSetUUIDs *mSessionFilterMockSetUUIDs) invocationsDone() bool {
	if len(mmSetUUIDs.expectations) == 0 && mmSetUUIDs.defaultExpectation == nil && mmSetUUIDs.mock.funcSetUUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetUUIDs.mock.afterSetUUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetUUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetUUIDs implements mm_repositories.SessionFilter
func (mmSetUUIDs *SessionFilterMock) SetUUIDs(sa1 []string) (s1 mm_repositories.SessionFilter) {
	mm_atomic.AddUint64(&mmSetUUIDs.beforeSetUUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetUUIDs.afterSetUUIDsCounter, 1)

	mmSetUUIDs.t.Helper()

	if mmSetUUIDs.inspectFuncSetUUIDs != nil {
		mmSetUUIDs.inspectFuncSetUUIDs(sa1)
	}

	mm_params := SessionFilterMockSetUUIDsParams{sa1}

	// Record call args
	mmSetUUIDs.SetUUIDsMock.mutex.Lock()
	mmSetUUIDs.SetUUIDsMock.callArgs = append(mmSetUUIDs.SetUUIDsMock.callArgs, &mm_params)
	mmSetUUIDs.SetUUIDsMock.mutex.Unlock()

	for _, e := range mmSetUUIDs.SetUUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSetUUIDs.SetUUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetUUIDs.SetUUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetUUIDs.SetUUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmSetUUIDs.SetUUIDsMock.defaultExpectation.paramPtrs

		mm_got := SessionFilterMockSetUUIDsParams{sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmSetUUIDs.t.Errorf("SessionFilterMock.SetUUIDs got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetUUIDs.SetUUIDsMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetUUIDs.t.Errorf("SessionFilterMock.SetUUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetUUIDs.SetUUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetUUIDs.SetUUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmSetUUIDs.t.Fatal("No results are set for the SessionFilterMock.SetUUIDs")
		}
		return (*mm_results).s1
	}
	if mmSetUUIDs.funcSetUUIDs != nil {
		return mmSetUUIDs.funcSetUUIDs(sa1)
	}
	mmSetUUIDs.t.Fatalf("Unexpected call to SessionFilterMock.SetUUIDs. %v", sa1)
	return
}

// SetUUIDsAfterCounter returns a count of finished SessionFilterMock.SetUUIDs invocations
func (mmSetUUIDs *SessionFilterMock) SetUUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetUUIDs.afterSetUUIDsCounter)
}

// SetUUIDsBeforeCounter returns a count of SessionFilterMock.SetUUIDs invocations
func (mmSetUUIDs *SessionFilterMock) SetUUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetUUIDs.beforeSetUUIDsCounter)
}

// Calls returns a list of arguments used in each call to SessionFilterMock.SetUUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetUUIDs *mSessionFilterMockSetUUIDs) Calls() []*SessionFilterMockSetUUIDsParams {
	mmSetUUIDs.mutex.RLock()

	argCopy := make([]*SessionFilterMockSetUUIDsParams, len(mmSetUUIDs.callArgs))
	copy(argCopy, mmSetUUIDs.callArgs)

	mmSetUUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockSetUUIDsDone returns true if the count of the SetUUIDs invocations corresponds
// the number of defined expectations
func (m *SessionFilterMock) MinimockSetUUIDsDone() bool {
	if m.SetUUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetUUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetUUIDsMock.invocationsDone()
}

// MinimockSetUUIDsInspect logs each unmet expectation
func (m *SessionFilterMock) MinimockSetUUIDsInspect() {
	for _, e := range m.SetUUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SessionFilterMock.SetUUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetUUIDsCounter := mm_atomic.LoadUint64(&m.afterSetUUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetUUIDsMock.defaultExpectation != nil && afterSetUUIDsCounter < 1 {
		if m.SetUUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SessionFilterMock.SetUUIDs at\n%s", m.SetUUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SessionFilterMock.SetUUIDs at\n%s with params: %#v", m.SetUUIDsMock.defaultExpectation.expectationOrigins.origin, *m.SetUUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetUUIDs != nil && afterSetUUIDsCounter < 1 {
		m.t.Errorf("Expected call to SessionFilterMock.SetUUIDs at\n%s", m.funcSetUUIDsOrigin)
	}

	if !m.SetUUIDsMock.invocationsDone() && afterSetUUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to SessionFilterMock.SetUUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetUUIDsMock.expectedInvocations), m.SetUUIDsMock.expectedInvocationsOrigin, afterSetUUIDsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SessionFilterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockSetCarUUIDsInspect()

			m.MinimockSetStatusesInspect()

			m.MinimockSetUUIDsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SessionFilterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SessionFilterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSetCarUUIDsDone() &&
		m.MinimockSetStatusesDone() &&
		m.MinimockSetUUIDsDone()
}
