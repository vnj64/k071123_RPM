// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain.Connection -o connection_mock_test.go -n ConnectionMock -p mocks

import (
	mm_domain "k071123/internal/services/parking_service/domain"
	"k071123/internal/services/parking_service/domain/repositories"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gorm.io/gorm"
)

// ConnectionMock implements mm_domain.Connection
type ConnectionMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBegin          func() (t1 mm_domain.TransactionalConnection, err error)
	funcBeginOrigin    string
	inspectFuncBegin   func()
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mConnectionMockBegin

	funcCarRepository          func() (c1 repositories.CarRepository)
	funcCarRepositoryOrigin    string
	inspectFuncCarRepository   func()
	afterCarRepositoryCounter  uint64
	beforeCarRepositoryCounter uint64
	CarRepositoryMock          mConnectionMockCarRepository

	funcDB          func() (dp1 *gorm.DB)
	funcDBOrigin    string
	inspectFuncDB   func()
	afterDBCounter  uint64
	beforeDBCounter uint64
	DBMock          mConnectionMockDB

	funcParkingRepository          func() (p1 repositories.ParkingRepository)
	funcParkingRepositoryOrigin    string
	inspectFuncParkingRepository   func()
	afterParkingRepositoryCounter  uint64
	beforeParkingRepositoryCounter uint64
	ParkingRepositoryMock          mConnectionMockParkingRepository

	funcSessionRepository          func() (s1 repositories.SessionRepository)
	funcSessionRepositoryOrigin    string
	inspectFuncSessionRepository   func()
	afterSessionRepositoryCounter  uint64
	beforeSessionRepositoryCounter uint64
	SessionRepositoryMock          mConnectionMockSessionRepository

	funcTariffRepository          func() (t1 repositories.TariffRepository)
	funcTariffRepositoryOrigin    string
	inspectFuncTariffRepository   func()
	afterTariffRepositoryCounter  uint64
	beforeTariffRepositoryCounter uint64
	TariffRepositoryMock          mConnectionMockTariffRepository

	funcUnitRepository          func() (u1 repositories.UnitRepository)
	funcUnitRepositoryOrigin    string
	inspectFuncUnitRepository   func()
	afterUnitRepositoryCounter  uint64
	beforeUnitRepositoryCounter uint64
	UnitRepositoryMock          mConnectionMockUnitRepository
}

// NewConnectionMock returns a mock for mm_domain.Connection
func NewConnectionMock(t minimock.Tester) *ConnectionMock {
	m := &ConnectionMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mConnectionMockBegin{mock: m}

	m.CarRepositoryMock = mConnectionMockCarRepository{mock: m}

	m.DBMock = mConnectionMockDB{mock: m}

	m.ParkingRepositoryMock = mConnectionMockParkingRepository{mock: m}

	m.SessionRepositoryMock = mConnectionMockSessionRepository{mock: m}

	m.TariffRepositoryMock = mConnectionMockTariffRepository{mock: m}

	m.UnitRepositoryMock = mConnectionMockUnitRepository{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mConnectionMockBegin struct {
	optional           bool
	mock               *ConnectionMock
	defaultExpectation *ConnectionMockBeginExpectation
	expectations       []*ConnectionMockBeginExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionMockBeginExpectation specifies expectation struct of the Connection.Begin
type ConnectionMockBeginExpectation struct {
	mock *ConnectionMock

	results      *ConnectionMockBeginResults
	returnOrigin string
	Counter      uint64
}

// ConnectionMockBeginResults contains results of the Connection.Begin
type ConnectionMockBeginResults struct {
	t1  mm_domain.TransactionalConnection
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBegin *mConnectionMockBegin) Optional() *mConnectionMockBegin {
	mmBegin.optional = true
	return mmBegin
}

// Expect sets up expected params for Connection.Begin
func (mmBegin *mConnectionMockBegin) Expect() *mConnectionMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("ConnectionMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &ConnectionMockBeginExpectation{}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the Connection.Begin
func (mmBegin *mConnectionMockBegin) Inspect(f func()) *mConnectionMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for ConnectionMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by Connection.Begin
func (mmBegin *mConnectionMockBegin) Return(t1 mm_domain.TransactionalConnection, err error) *ConnectionMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("ConnectionMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &ConnectionMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &ConnectionMockBeginResults{t1, err}
	mmBegin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// Set uses given function f to mock the Connection.Begin method
func (mmBegin *mConnectionMockBegin) Set(f func() (t1 mm_domain.TransactionalConnection, err error)) *ConnectionMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the Connection.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the Connection.Begin method")
	}

	mmBegin.mock.funcBegin = f
	mmBegin.mock.funcBeginOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// Times sets number of times Connection.Begin should be invoked
func (mmBegin *mConnectionMockBegin) Times(n uint64) *mConnectionMockBegin {
	if n == 0 {
		mmBegin.mock.t.Fatalf("Times of ConnectionMock.Begin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBegin.expectedInvocations, n)
	mmBegin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBegin
}

func (mmBegin *mConnectionMockBegin) invocationsDone() bool {
	if len(mmBegin.expectations) == 0 && mmBegin.defaultExpectation == nil && mmBegin.mock.funcBegin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBegin.mock.afterBeginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBegin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Begin implements mm_domain.Connection
func (mmBegin *ConnectionMock) Begin() (t1 mm_domain.TransactionalConnection, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	mmBegin.t.Helper()

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin()
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the ConnectionMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin()
	}
	mmBegin.t.Fatalf("Unexpected call to ConnectionMock.Begin.")
	return
}

// BeginAfterCounter returns a count of finished ConnectionMock.Begin invocations
func (mmBegin *ConnectionMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of ConnectionMock.Begin invocations
func (mmBegin *ConnectionMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockBeginDone() bool {
	if m.BeginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginMock.invocationsDone()
}

// MinimockBeginInspect logs each unmet expectation
func (m *ConnectionMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnectionMock.Begin")
		}
	}

	afterBeginCounter := mm_atomic.LoadUint64(&m.afterBeginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && afterBeginCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.Begin at\n%s", m.BeginMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && afterBeginCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.Begin at\n%s", m.funcBeginOrigin)
	}

	if !m.BeginMock.invocationsDone() && afterBeginCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionMock.Begin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginMock.expectedInvocations), m.BeginMock.expectedInvocationsOrigin, afterBeginCounter)
	}
}

type mConnectionMockCarRepository struct {
	optional           bool
	mock               *ConnectionMock
	defaultExpectation *ConnectionMockCarRepositoryExpectation
	expectations       []*ConnectionMockCarRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionMockCarRepositoryExpectation specifies expectation struct of the Connection.CarRepository
type ConnectionMockCarRepositoryExpectation struct {
	mock *ConnectionMock

	results      *ConnectionMockCarRepositoryResults
	returnOrigin string
	Counter      uint64
}

// ConnectionMockCarRepositoryResults contains results of the Connection.CarRepository
type ConnectionMockCarRepositoryResults struct {
	c1 repositories.CarRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCarRepository *mConnectionMockCarRepository) Optional() *mConnectionMockCarRepository {
	mmCarRepository.optional = true
	return mmCarRepository
}

// Expect sets up expected params for Connection.CarRepository
func (mmCarRepository *mConnectionMockCarRepository) Expect() *mConnectionMockCarRepository {
	if mmCarRepository.mock.funcCarRepository != nil {
		mmCarRepository.mock.t.Fatalf("ConnectionMock.CarRepository mock is already set by Set")
	}

	if mmCarRepository.defaultExpectation == nil {
		mmCarRepository.defaultExpectation = &ConnectionMockCarRepositoryExpectation{}
	}

	return mmCarRepository
}

// Inspect accepts an inspector function that has same arguments as the Connection.CarRepository
func (mmCarRepository *mConnectionMockCarRepository) Inspect(f func()) *mConnectionMockCarRepository {
	if mmCarRepository.mock.inspectFuncCarRepository != nil {
		mmCarRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.CarRepository")
	}

	mmCarRepository.mock.inspectFuncCarRepository = f

	return mmCarRepository
}

// Return sets up results that will be returned by Connection.CarRepository
func (mmCarRepository *mConnectionMockCarRepository) Return(c1 repositories.CarRepository) *ConnectionMock {
	if mmCarRepository.mock.funcCarRepository != nil {
		mmCarRepository.mock.t.Fatalf("ConnectionMock.CarRepository mock is already set by Set")
	}

	if mmCarRepository.defaultExpectation == nil {
		mmCarRepository.defaultExpectation = &ConnectionMockCarRepositoryExpectation{mock: mmCarRepository.mock}
	}
	mmCarRepository.defaultExpectation.results = &ConnectionMockCarRepositoryResults{c1}
	mmCarRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCarRepository.mock
}

// Set uses given function f to mock the Connection.CarRepository method
func (mmCarRepository *mConnectionMockCarRepository) Set(f func() (c1 repositories.CarRepository)) *ConnectionMock {
	if mmCarRepository.defaultExpectation != nil {
		mmCarRepository.mock.t.Fatalf("Default expectation is already set for the Connection.CarRepository method")
	}

	if len(mmCarRepository.expectations) > 0 {
		mmCarRepository.mock.t.Fatalf("Some expectations are already set for the Connection.CarRepository method")
	}

	mmCarRepository.mock.funcCarRepository = f
	mmCarRepository.mock.funcCarRepositoryOrigin = minimock.CallerInfo(1)
	return mmCarRepository.mock
}

// Times sets number of times Connection.CarRepository should be invoked
func (mmCarRepository *mConnectionMockCarRepository) Times(n uint64) *mConnectionMockCarRepository {
	if n == 0 {
		mmCarRepository.mock.t.Fatalf("Times of ConnectionMock.CarRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCarRepository.expectedInvocations, n)
	mmCarRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCarRepository
}

func (mmCarRepository *mConnectionMockCarRepository) invocationsDone() bool {
	if len(mmCarRepository.expectations) == 0 && mmCarRepository.defaultExpectation == nil && mmCarRepository.mock.funcCarRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCarRepository.mock.afterCarRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCarRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CarRepository implements mm_domain.Connection
func (mmCarRepository *ConnectionMock) CarRepository() (c1 repositories.CarRepository) {
	mm_atomic.AddUint64(&mmCarRepository.beforeCarRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmCarRepository.afterCarRepositoryCounter, 1)

	mmCarRepository.t.Helper()

	if mmCarRepository.inspectFuncCarRepository != nil {
		mmCarRepository.inspectFuncCarRepository()
	}

	if mmCarRepository.CarRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCarRepository.CarRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmCarRepository.CarRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmCarRepository.t.Fatal("No results are set for the ConnectionMock.CarRepository")
		}
		return (*mm_results).c1
	}
	if mmCarRepository.funcCarRepository != nil {
		return mmCarRepository.funcCarRepository()
	}
	mmCarRepository.t.Fatalf("Unexpected call to ConnectionMock.CarRepository.")
	return
}

// CarRepositoryAfterCounter returns a count of finished ConnectionMock.CarRepository invocations
func (mmCarRepository *ConnectionMock) CarRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCarRepository.afterCarRepositoryCounter)
}

// CarRepositoryBeforeCounter returns a count of ConnectionMock.CarRepository invocations
func (mmCarRepository *ConnectionMock) CarRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCarRepository.beforeCarRepositoryCounter)
}

// MinimockCarRepositoryDone returns true if the count of the CarRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockCarRepositoryDone() bool {
	if m.CarRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CarRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CarRepositoryMock.invocationsDone()
}

// MinimockCarRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockCarRepositoryInspect() {
	for _, e := range m.CarRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnectionMock.CarRepository")
		}
	}

	afterCarRepositoryCounter := mm_atomic.LoadUint64(&m.afterCarRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CarRepositoryMock.defaultExpectation != nil && afterCarRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.CarRepository at\n%s", m.CarRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCarRepository != nil && afterCarRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.CarRepository at\n%s", m.funcCarRepositoryOrigin)
	}

	if !m.CarRepositoryMock.invocationsDone() && afterCarRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionMock.CarRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CarRepositoryMock.expectedInvocations), m.CarRepositoryMock.expectedInvocationsOrigin, afterCarRepositoryCounter)
	}
}

type mConnectionMockDB struct {
	optional           bool
	mock               *ConnectionMock
	defaultExpectation *ConnectionMockDBExpectation
	expectations       []*ConnectionMockDBExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionMockDBExpectation specifies expectation struct of the Connection.DB
type ConnectionMockDBExpectation struct {
	mock *ConnectionMock

	results      *ConnectionMockDBResults
	returnOrigin string
	Counter      uint64
}

// ConnectionMockDBResults contains results of the Connection.DB
type ConnectionMockDBResults struct {
	dp1 *gorm.DB
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDB *mConnectionMockDB) Optional() *mConnectionMockDB {
	mmDB.optional = true
	return mmDB
}

// Expect sets up expected params for Connection.DB
func (mmDB *mConnectionMockDB) Expect() *mConnectionMockDB {
	if mmDB.mock.funcDB != nil {
		mmDB.mock.t.Fatalf("ConnectionMock.DB mock is already set by Set")
	}

	if mmDB.defaultExpectation == nil {
		mmDB.defaultExpectation = &ConnectionMockDBExpectation{}
	}

	return mmDB
}

// Inspect accepts an inspector function that has same arguments as the Connection.DB
func (mmDB *mConnectionMockDB) Inspect(f func()) *mConnectionMockDB {
	if mmDB.mock.inspectFuncDB != nil {
		mmDB.mock.t.Fatalf("Inspect function is already set for ConnectionMock.DB")
	}

	mmDB.mock.inspectFuncDB = f

	return mmDB
}

// Return sets up results that will be returned by Connection.DB
func (mmDB *mConnectionMockDB) Return(dp1 *gorm.DB) *ConnectionMock {
	if mmDB.mock.funcDB != nil {
		mmDB.mock.t.Fatalf("ConnectionMock.DB mock is already set by Set")
	}

	if mmDB.defaultExpectation == nil {
		mmDB.defaultExpectation = &ConnectionMockDBExpectation{mock: mmDB.mock}
	}
	mmDB.defaultExpectation.results = &ConnectionMockDBResults{dp1}
	mmDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDB.mock
}

// Set uses given function f to mock the Connection.DB method
func (mmDB *mConnectionMockDB) Set(f func() (dp1 *gorm.DB)) *ConnectionMock {
	if mmDB.defaultExpectation != nil {
		mmDB.mock.t.Fatalf("Default expectation is already set for the Connection.DB method")
	}

	if len(mmDB.expectations) > 0 {
		mmDB.mock.t.Fatalf("Some expectations are already set for the Connection.DB method")
	}

	mmDB.mock.funcDB = f
	mmDB.mock.funcDBOrigin = minimock.CallerInfo(1)
	return mmDB.mock
}

// Times sets number of times Connection.DB should be invoked
func (mmDB *mConnectionMockDB) Times(n uint64) *mConnectionMockDB {
	if n == 0 {
		mmDB.mock.t.Fatalf("Times of ConnectionMock.DB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDB.expectedInvocations, n)
	mmDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDB
}

func (mmDB *mConnectionMockDB) invocationsDone() bool {
	if len(mmDB.expectations) == 0 && mmDB.defaultExpectation == nil && mmDB.mock.funcDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDB.mock.afterDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DB implements mm_domain.Connection
func (mmDB *ConnectionMock) DB() (dp1 *gorm.DB) {
	mm_atomic.AddUint64(&mmDB.beforeDBCounter, 1)
	defer mm_atomic.AddUint64(&mmDB.afterDBCounter, 1)

	mmDB.t.Helper()

	if mmDB.inspectFuncDB != nil {
		mmDB.inspectFuncDB()
	}

	if mmDB.DBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDB.DBMock.defaultExpectation.Counter, 1)

		mm_results := mmDB.DBMock.defaultExpectation.results
		if mm_results == nil {
			mmDB.t.Fatal("No results are set for the ConnectionMock.DB")
		}
		return (*mm_results).dp1
	}
	if mmDB.funcDB != nil {
		return mmDB.funcDB()
	}
	mmDB.t.Fatalf("Unexpected call to ConnectionMock.DB.")
	return
}

// DBAfterCounter returns a count of finished ConnectionMock.DB invocations
func (mmDB *ConnectionMock) DBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDB.afterDBCounter)
}

// DBBeforeCounter returns a count of ConnectionMock.DB invocations
func (mmDB *ConnectionMock) DBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDB.beforeDBCounter)
}

// MinimockDBDone returns true if the count of the DB invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockDBDone() bool {
	if m.DBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DBMock.invocationsDone()
}

// MinimockDBInspect logs each unmet expectation
func (m *ConnectionMock) MinimockDBInspect() {
	for _, e := range m.DBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnectionMock.DB")
		}
	}

	afterDBCounter := mm_atomic.LoadUint64(&m.afterDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DBMock.defaultExpectation != nil && afterDBCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.DB at\n%s", m.DBMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDB != nil && afterDBCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.DB at\n%s", m.funcDBOrigin)
	}

	if !m.DBMock.invocationsDone() && afterDBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionMock.DB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DBMock.expectedInvocations), m.DBMock.expectedInvocationsOrigin, afterDBCounter)
	}
}

type mConnectionMockParkingRepository struct {
	optional           bool
	mock               *ConnectionMock
	defaultExpectation *ConnectionMockParkingRepositoryExpectation
	expectations       []*ConnectionMockParkingRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionMockParkingRepositoryExpectation specifies expectation struct of the Connection.ParkingRepository
type ConnectionMockParkingRepositoryExpectation struct {
	mock *ConnectionMock

	results      *ConnectionMockParkingRepositoryResults
	returnOrigin string
	Counter      uint64
}

// ConnectionMockParkingRepositoryResults contains results of the Connection.ParkingRepository
type ConnectionMockParkingRepositoryResults struct {
	p1 repositories.ParkingRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmParkingRepository *mConnectionMockParkingRepository) Optional() *mConnectionMockParkingRepository {
	mmParkingRepository.optional = true
	return mmParkingRepository
}

// Expect sets up expected params for Connection.ParkingRepository
func (mmParkingRepository *mConnectionMockParkingRepository) Expect() *mConnectionMockParkingRepository {
	if mmParkingRepository.mock.funcParkingRepository != nil {
		mmParkingRepository.mock.t.Fatalf("ConnectionMock.ParkingRepository mock is already set by Set")
	}

	if mmParkingRepository.defaultExpectation == nil {
		mmParkingRepository.defaultExpectation = &ConnectionMockParkingRepositoryExpectation{}
	}

	return mmParkingRepository
}

// Inspect accepts an inspector function that has same arguments as the Connection.ParkingRepository
func (mmParkingRepository *mConnectionMockParkingRepository) Inspect(f func()) *mConnectionMockParkingRepository {
	if mmParkingRepository.mock.inspectFuncParkingRepository != nil {
		mmParkingRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.ParkingRepository")
	}

	mmParkingRepository.mock.inspectFuncParkingRepository = f

	return mmParkingRepository
}

// Return sets up results that will be returned by Connection.ParkingRepository
func (mmParkingRepository *mConnectionMockParkingRepository) Return(p1 repositories.ParkingRepository) *ConnectionMock {
	if mmParkingRepository.mock.funcParkingRepository != nil {
		mmParkingRepository.mock.t.Fatalf("ConnectionMock.ParkingRepository mock is already set by Set")
	}

	if mmParkingRepository.defaultExpectation == nil {
		mmParkingRepository.defaultExpectation = &ConnectionMockParkingRepositoryExpectation{mock: mmParkingRepository.mock}
	}
	mmParkingRepository.defaultExpectation.results = &ConnectionMockParkingRepositoryResults{p1}
	mmParkingRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmParkingRepository.mock
}

// Set uses given function f to mock the Connection.ParkingRepository method
func (mmParkingRepository *mConnectionMockParkingRepository) Set(f func() (p1 repositories.ParkingRepository)) *ConnectionMock {
	if mmParkingRepository.defaultExpectation != nil {
		mmParkingRepository.mock.t.Fatalf("Default expectation is already set for the Connection.ParkingRepository method")
	}

	if len(mmParkingRepository.expectations) > 0 {
		mmParkingRepository.mock.t.Fatalf("Some expectations are already set for the Connection.ParkingRepository method")
	}

	mmParkingRepository.mock.funcParkingRepository = f
	mmParkingRepository.mock.funcParkingRepositoryOrigin = minimock.CallerInfo(1)
	return mmParkingRepository.mock
}

// Times sets number of times Connection.ParkingRepository should be invoked
func (mmParkingRepository *mConnectionMockParkingRepository) Times(n uint64) *mConnectionMockParkingRepository {
	if n == 0 {
		mmParkingRepository.mock.t.Fatalf("Times of ConnectionMock.ParkingRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmParkingRepository.expectedInvocations, n)
	mmParkingRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmParkingRepository
}

func (mmParkingRepository *mConnectionMockParkingRepository) invocationsDone() bool {
	if len(mmParkingRepository.expectations) == 0 && mmParkingRepository.defaultExpectation == nil && mmParkingRepository.mock.funcParkingRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmParkingRepository.mock.afterParkingRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmParkingRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ParkingRepository implements mm_domain.Connection
func (mmParkingRepository *ConnectionMock) ParkingRepository() (p1 repositories.ParkingRepository) {
	mm_atomic.AddUint64(&mmParkingRepository.beforeParkingRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmParkingRepository.afterParkingRepositoryCounter, 1)

	mmParkingRepository.t.Helper()

	if mmParkingRepository.inspectFuncParkingRepository != nil {
		mmParkingRepository.inspectFuncParkingRepository()
	}

	if mmParkingRepository.ParkingRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParkingRepository.ParkingRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmParkingRepository.ParkingRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmParkingRepository.t.Fatal("No results are set for the ConnectionMock.ParkingRepository")
		}
		return (*mm_results).p1
	}
	if mmParkingRepository.funcParkingRepository != nil {
		return mmParkingRepository.funcParkingRepository()
	}
	mmParkingRepository.t.Fatalf("Unexpected call to ConnectionMock.ParkingRepository.")
	return
}

// ParkingRepositoryAfterCounter returns a count of finished ConnectionMock.ParkingRepository invocations
func (mmParkingRepository *ConnectionMock) ParkingRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParkingRepository.afterParkingRepositoryCounter)
}

// ParkingRepositoryBeforeCounter returns a count of ConnectionMock.ParkingRepository invocations
func (mmParkingRepository *ConnectionMock) ParkingRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParkingRepository.beforeParkingRepositoryCounter)
}

// MinimockParkingRepositoryDone returns true if the count of the ParkingRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockParkingRepositoryDone() bool {
	if m.ParkingRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ParkingRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ParkingRepositoryMock.invocationsDone()
}

// MinimockParkingRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockParkingRepositoryInspect() {
	for _, e := range m.ParkingRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnectionMock.ParkingRepository")
		}
	}

	afterParkingRepositoryCounter := mm_atomic.LoadUint64(&m.afterParkingRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ParkingRepositoryMock.defaultExpectation != nil && afterParkingRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.ParkingRepository at\n%s", m.ParkingRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParkingRepository != nil && afterParkingRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.ParkingRepository at\n%s", m.funcParkingRepositoryOrigin)
	}

	if !m.ParkingRepositoryMock.invocationsDone() && afterParkingRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionMock.ParkingRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ParkingRepositoryMock.expectedInvocations), m.ParkingRepositoryMock.expectedInvocationsOrigin, afterParkingRepositoryCounter)
	}
}

type mConnectionMockSessionRepository struct {
	optional           bool
	mock               *ConnectionMock
	defaultExpectation *ConnectionMockSessionRepositoryExpectation
	expectations       []*ConnectionMockSessionRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionMockSessionRepositoryExpectation specifies expectation struct of the Connection.SessionRepository
type ConnectionMockSessionRepositoryExpectation struct {
	mock *ConnectionMock

	results      *ConnectionMockSessionRepositoryResults
	returnOrigin string
	Counter      uint64
}

// ConnectionMockSessionRepositoryResults contains results of the Connection.SessionRepository
type ConnectionMockSessionRepositoryResults struct {
	s1 repositories.SessionRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSessionRepository *mConnectionMockSessionRepository) Optional() *mConnectionMockSessionRepository {
	mmSessionRepository.optional = true
	return mmSessionRepository
}

// Expect sets up expected params for Connection.SessionRepository
func (mmSessionRepository *mConnectionMockSessionRepository) Expect() *mConnectionMockSessionRepository {
	if mmSessionRepository.mock.funcSessionRepository != nil {
		mmSessionRepository.mock.t.Fatalf("ConnectionMock.SessionRepository mock is already set by Set")
	}

	if mmSessionRepository.defaultExpectation == nil {
		mmSessionRepository.defaultExpectation = &ConnectionMockSessionRepositoryExpectation{}
	}

	return mmSessionRepository
}

// Inspect accepts an inspector function that has same arguments as the Connection.SessionRepository
func (mmSessionRepository *mConnectionMockSessionRepository) Inspect(f func()) *mConnectionMockSessionRepository {
	if mmSessionRepository.mock.inspectFuncSessionRepository != nil {
		mmSessionRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.SessionRepository")
	}

	mmSessionRepository.mock.inspectFuncSessionRepository = f

	return mmSessionRepository
}

// Return sets up results that will be returned by Connection.SessionRepository
func (mmSessionRepository *mConnectionMockSessionRepository) Return(s1 repositories.SessionRepository) *ConnectionMock {
	if mmSessionRepository.mock.funcSessionRepository != nil {
		mmSessionRepository.mock.t.Fatalf("ConnectionMock.SessionRepository mock is already set by Set")
	}

	if mmSessionRepository.defaultExpectation == nil {
		mmSessionRepository.defaultExpectation = &ConnectionMockSessionRepositoryExpectation{mock: mmSessionRepository.mock}
	}
	mmSessionRepository.defaultExpectation.results = &ConnectionMockSessionRepositoryResults{s1}
	mmSessionRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSessionRepository.mock
}

// Set uses given function f to mock the Connection.SessionRepository method
func (mmSessionRepository *mConnectionMockSessionRepository) Set(f func() (s1 repositories.SessionRepository)) *ConnectionMock {
	if mmSessionRepository.defaultExpectation != nil {
		mmSessionRepository.mock.t.Fatalf("Default expectation is already set for the Connection.SessionRepository method")
	}

	if len(mmSessionRepository.expectations) > 0 {
		mmSessionRepository.mock.t.Fatalf("Some expectations are already set for the Connection.SessionRepository method")
	}

	mmSessionRepository.mock.funcSessionRepository = f
	mmSessionRepository.mock.funcSessionRepositoryOrigin = minimock.CallerInfo(1)
	return mmSessionRepository.mock
}

// Times sets number of times Connection.SessionRepository should be invoked
func (mmSessionRepository *mConnectionMockSessionRepository) Times(n uint64) *mConnectionMockSessionRepository {
	if n == 0 {
		mmSessionRepository.mock.t.Fatalf("Times of ConnectionMock.SessionRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSessionRepository.expectedInvocations, n)
	mmSessionRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSessionRepository
}

func (mmSessionRepository *mConnectionMockSessionRepository) invocationsDone() bool {
	if len(mmSessionRepository.expectations) == 0 && mmSessionRepository.defaultExpectation == nil && mmSessionRepository.mock.funcSessionRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSessionRepository.mock.afterSessionRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSessionRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SessionRepository implements mm_domain.Connection
func (mmSessionRepository *ConnectionMock) SessionRepository() (s1 repositories.SessionRepository) {
	mm_atomic.AddUint64(&mmSessionRepository.beforeSessionRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmSessionRepository.afterSessionRepositoryCounter, 1)

	mmSessionRepository.t.Helper()

	if mmSessionRepository.inspectFuncSessionRepository != nil {
		mmSessionRepository.inspectFuncSessionRepository()
	}

	if mmSessionRepository.SessionRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSessionRepository.SessionRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmSessionRepository.SessionRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmSessionRepository.t.Fatal("No results are set for the ConnectionMock.SessionRepository")
		}
		return (*mm_results).s1
	}
	if mmSessionRepository.funcSessionRepository != nil {
		return mmSessionRepository.funcSessionRepository()
	}
	mmSessionRepository.t.Fatalf("Unexpected call to ConnectionMock.SessionRepository.")
	return
}

// SessionRepositoryAfterCounter returns a count of finished ConnectionMock.SessionRepository invocations
func (mmSessionRepository *ConnectionMock) SessionRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSessionRepository.afterSessionRepositoryCounter)
}

// SessionRepositoryBeforeCounter returns a count of ConnectionMock.SessionRepository invocations
func (mmSessionRepository *ConnectionMock) SessionRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSessionRepository.beforeSessionRepositoryCounter)
}

// MinimockSessionRepositoryDone returns true if the count of the SessionRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockSessionRepositoryDone() bool {
	if m.SessionRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SessionRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SessionRepositoryMock.invocationsDone()
}

// MinimockSessionRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockSessionRepositoryInspect() {
	for _, e := range m.SessionRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnectionMock.SessionRepository")
		}
	}

	afterSessionRepositoryCounter := mm_atomic.LoadUint64(&m.afterSessionRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SessionRepositoryMock.defaultExpectation != nil && afterSessionRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.SessionRepository at\n%s", m.SessionRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSessionRepository != nil && afterSessionRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.SessionRepository at\n%s", m.funcSessionRepositoryOrigin)
	}

	if !m.SessionRepositoryMock.invocationsDone() && afterSessionRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionMock.SessionRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SessionRepositoryMock.expectedInvocations), m.SessionRepositoryMock.expectedInvocationsOrigin, afterSessionRepositoryCounter)
	}
}

type mConnectionMockTariffRepository struct {
	optional           bool
	mock               *ConnectionMock
	defaultExpectation *ConnectionMockTariffRepositoryExpectation
	expectations       []*ConnectionMockTariffRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionMockTariffRepositoryExpectation specifies expectation struct of the Connection.TariffRepository
type ConnectionMockTariffRepositoryExpectation struct {
	mock *ConnectionMock

	results      *ConnectionMockTariffRepositoryResults
	returnOrigin string
	Counter      uint64
}

// ConnectionMockTariffRepositoryResults contains results of the Connection.TariffRepository
type ConnectionMockTariffRepositoryResults struct {
	t1 repositories.TariffRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTariffRepository *mConnectionMockTariffRepository) Optional() *mConnectionMockTariffRepository {
	mmTariffRepository.optional = true
	return mmTariffRepository
}

// Expect sets up expected params for Connection.TariffRepository
func (mmTariffRepository *mConnectionMockTariffRepository) Expect() *mConnectionMockTariffRepository {
	if mmTariffRepository.mock.funcTariffRepository != nil {
		mmTariffRepository.mock.t.Fatalf("ConnectionMock.TariffRepository mock is already set by Set")
	}

	if mmTariffRepository.defaultExpectation == nil {
		mmTariffRepository.defaultExpectation = &ConnectionMockTariffRepositoryExpectation{}
	}

	return mmTariffRepository
}

// Inspect accepts an inspector function that has same arguments as the Connection.TariffRepository
func (mmTariffRepository *mConnectionMockTariffRepository) Inspect(f func()) *mConnectionMockTariffRepository {
	if mmTariffRepository.mock.inspectFuncTariffRepository != nil {
		mmTariffRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.TariffRepository")
	}

	mmTariffRepository.mock.inspectFuncTariffRepository = f

	return mmTariffRepository
}

// Return sets up results that will be returned by Connection.TariffRepository
func (mmTariffRepository *mConnectionMockTariffRepository) Return(t1 repositories.TariffRepository) *ConnectionMock {
	if mmTariffRepository.mock.funcTariffRepository != nil {
		mmTariffRepository.mock.t.Fatalf("ConnectionMock.TariffRepository mock is already set by Set")
	}

	if mmTariffRepository.defaultExpectation == nil {
		mmTariffRepository.defaultExpectation = &ConnectionMockTariffRepositoryExpectation{mock: mmTariffRepository.mock}
	}
	mmTariffRepository.defaultExpectation.results = &ConnectionMockTariffRepositoryResults{t1}
	mmTariffRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTariffRepository.mock
}

// Set uses given function f to mock the Connection.TariffRepository method
func (mmTariffRepository *mConnectionMockTariffRepository) Set(f func() (t1 repositories.TariffRepository)) *ConnectionMock {
	if mmTariffRepository.defaultExpectation != nil {
		mmTariffRepository.mock.t.Fatalf("Default expectation is already set for the Connection.TariffRepository method")
	}

	if len(mmTariffRepository.expectations) > 0 {
		mmTariffRepository.mock.t.Fatalf("Some expectations are already set for the Connection.TariffRepository method")
	}

	mmTariffRepository.mock.funcTariffRepository = f
	mmTariffRepository.mock.funcTariffRepositoryOrigin = minimock.CallerInfo(1)
	return mmTariffRepository.mock
}

// Times sets number of times Connection.TariffRepository should be invoked
func (mmTariffRepository *mConnectionMockTariffRepository) Times(n uint64) *mConnectionMockTariffRepository {
	if n == 0 {
		mmTariffRepository.mock.t.Fatalf("Times of ConnectionMock.TariffRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTariffRepository.expectedInvocations, n)
	mmTariffRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTariffRepository
}

func (mmTariffRepository *mConnectionMockTariffRepository) invocationsDone() bool {
	if len(mmTariffRepository.expectations) == 0 && mmTariffRepository.defaultExpectation == nil && mmTariffRepository.mock.funcTariffRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTariffRepository.mock.afterTariffRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTariffRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TariffRepository implements mm_domain.Connection
func (mmTariffRepository *ConnectionMock) TariffRepository() (t1 repositories.TariffRepository) {
	mm_atomic.AddUint64(&mmTariffRepository.beforeTariffRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmTariffRepository.afterTariffRepositoryCounter, 1)

	mmTariffRepository.t.Helper()

	if mmTariffRepository.inspectFuncTariffRepository != nil {
		mmTariffRepository.inspectFuncTariffRepository()
	}

	if mmTariffRepository.TariffRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTariffRepository.TariffRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmTariffRepository.TariffRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmTariffRepository.t.Fatal("No results are set for the ConnectionMock.TariffRepository")
		}
		return (*mm_results).t1
	}
	if mmTariffRepository.funcTariffRepository != nil {
		return mmTariffRepository.funcTariffRepository()
	}
	mmTariffRepository.t.Fatalf("Unexpected call to ConnectionMock.TariffRepository.")
	return
}

// TariffRepositoryAfterCounter returns a count of finished ConnectionMock.TariffRepository invocations
func (mmTariffRepository *ConnectionMock) TariffRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTariffRepository.afterTariffRepositoryCounter)
}

// TariffRepositoryBeforeCounter returns a count of ConnectionMock.TariffRepository invocations
func (mmTariffRepository *ConnectionMock) TariffRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTariffRepository.beforeTariffRepositoryCounter)
}

// MinimockTariffRepositoryDone returns true if the count of the TariffRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockTariffRepositoryDone() bool {
	if m.TariffRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TariffRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TariffRepositoryMock.invocationsDone()
}

// MinimockTariffRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockTariffRepositoryInspect() {
	for _, e := range m.TariffRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnectionMock.TariffRepository")
		}
	}

	afterTariffRepositoryCounter := mm_atomic.LoadUint64(&m.afterTariffRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TariffRepositoryMock.defaultExpectation != nil && afterTariffRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.TariffRepository at\n%s", m.TariffRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTariffRepository != nil && afterTariffRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.TariffRepository at\n%s", m.funcTariffRepositoryOrigin)
	}

	if !m.TariffRepositoryMock.invocationsDone() && afterTariffRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionMock.TariffRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TariffRepositoryMock.expectedInvocations), m.TariffRepositoryMock.expectedInvocationsOrigin, afterTariffRepositoryCounter)
	}
}

type mConnectionMockUnitRepository struct {
	optional           bool
	mock               *ConnectionMock
	defaultExpectation *ConnectionMockUnitRepositoryExpectation
	expectations       []*ConnectionMockUnitRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnectionMockUnitRepositoryExpectation specifies expectation struct of the Connection.UnitRepository
type ConnectionMockUnitRepositoryExpectation struct {
	mock *ConnectionMock

	results      *ConnectionMockUnitRepositoryResults
	returnOrigin string
	Counter      uint64
}

// ConnectionMockUnitRepositoryResults contains results of the Connection.UnitRepository
type ConnectionMockUnitRepositoryResults struct {
	u1 repositories.UnitRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUnitRepository *mConnectionMockUnitRepository) Optional() *mConnectionMockUnitRepository {
	mmUnitRepository.optional = true
	return mmUnitRepository
}

// Expect sets up expected params for Connection.UnitRepository
func (mmUnitRepository *mConnectionMockUnitRepository) Expect() *mConnectionMockUnitRepository {
	if mmUnitRepository.mock.funcUnitRepository != nil {
		mmUnitRepository.mock.t.Fatalf("ConnectionMock.UnitRepository mock is already set by Set")
	}

	if mmUnitRepository.defaultExpectation == nil {
		mmUnitRepository.defaultExpectation = &ConnectionMockUnitRepositoryExpectation{}
	}

	return mmUnitRepository
}

// Inspect accepts an inspector function that has same arguments as the Connection.UnitRepository
func (mmUnitRepository *mConnectionMockUnitRepository) Inspect(f func()) *mConnectionMockUnitRepository {
	if mmUnitRepository.mock.inspectFuncUnitRepository != nil {
		mmUnitRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.UnitRepository")
	}

	mmUnitRepository.mock.inspectFuncUnitRepository = f

	return mmUnitRepository
}

// Return sets up results that will be returned by Connection.UnitRepository
func (mmUnitRepository *mConnectionMockUnitRepository) Return(u1 repositories.UnitRepository) *ConnectionMock {
	if mmUnitRepository.mock.funcUnitRepository != nil {
		mmUnitRepository.mock.t.Fatalf("ConnectionMock.UnitRepository mock is already set by Set")
	}

	if mmUnitRepository.defaultExpectation == nil {
		mmUnitRepository.defaultExpectation = &ConnectionMockUnitRepositoryExpectation{mock: mmUnitRepository.mock}
	}
	mmUnitRepository.defaultExpectation.results = &ConnectionMockUnitRepositoryResults{u1}
	mmUnitRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUnitRepository.mock
}

// Set uses given function f to mock the Connection.UnitRepository method
func (mmUnitRepository *mConnectionMockUnitRepository) Set(f func() (u1 repositories.UnitRepository)) *ConnectionMock {
	if mmUnitRepository.defaultExpectation != nil {
		mmUnitRepository.mock.t.Fatalf("Default expectation is already set for the Connection.UnitRepository method")
	}

	if len(mmUnitRepository.expectations) > 0 {
		mmUnitRepository.mock.t.Fatalf("Some expectations are already set for the Connection.UnitRepository method")
	}

	mmUnitRepository.mock.funcUnitRepository = f
	mmUnitRepository.mock.funcUnitRepositoryOrigin = minimock.CallerInfo(1)
	return mmUnitRepository.mock
}

// Times sets number of times Connection.UnitRepository should be invoked
func (mmUnitRepository *mConnectionMockUnitRepository) Times(n uint64) *mConnectionMockUnitRepository {
	if n == 0 {
		mmUnitRepository.mock.t.Fatalf("Times of ConnectionMock.UnitRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUnitRepository.expectedInvocations, n)
	mmUnitRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUnitRepository
}

func (mmUnitRepository *mConnectionMockUnitRepository) invocationsDone() bool {
	if len(mmUnitRepository.expectations) == 0 && mmUnitRepository.defaultExpectation == nil && mmUnitRepository.mock.funcUnitRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUnitRepository.mock.afterUnitRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUnitRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UnitRepository implements mm_domain.Connection
func (mmUnitRepository *ConnectionMock) UnitRepository() (u1 repositories.UnitRepository) {
	mm_atomic.AddUint64(&mmUnitRepository.beforeUnitRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmUnitRepository.afterUnitRepositoryCounter, 1)

	mmUnitRepository.t.Helper()

	if mmUnitRepository.inspectFuncUnitRepository != nil {
		mmUnitRepository.inspectFuncUnitRepository()
	}

	if mmUnitRepository.UnitRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnitRepository.UnitRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmUnitRepository.UnitRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmUnitRepository.t.Fatal("No results are set for the ConnectionMock.UnitRepository")
		}
		return (*mm_results).u1
	}
	if mmUnitRepository.funcUnitRepository != nil {
		return mmUnitRepository.funcUnitRepository()
	}
	mmUnitRepository.t.Fatalf("Unexpected call to ConnectionMock.UnitRepository.")
	return
}

// UnitRepositoryAfterCounter returns a count of finished ConnectionMock.UnitRepository invocations
func (mmUnitRepository *ConnectionMock) UnitRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnitRepository.afterUnitRepositoryCounter)
}

// UnitRepositoryBeforeCounter returns a count of ConnectionMock.UnitRepository invocations
func (mmUnitRepository *ConnectionMock) UnitRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnitRepository.beforeUnitRepositoryCounter)
}

// MinimockUnitRepositoryDone returns true if the count of the UnitRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockUnitRepositoryDone() bool {
	if m.UnitRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UnitRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UnitRepositoryMock.invocationsDone()
}

// MinimockUnitRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockUnitRepositoryInspect() {
	for _, e := range m.UnitRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnectionMock.UnitRepository")
		}
	}

	afterUnitRepositoryCounter := mm_atomic.LoadUint64(&m.afterUnitRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UnitRepositoryMock.defaultExpectation != nil && afterUnitRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.UnitRepository at\n%s", m.UnitRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnitRepository != nil && afterUnitRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ConnectionMock.UnitRepository at\n%s", m.funcUnitRepositoryOrigin)
	}

	if !m.UnitRepositoryMock.invocationsDone() && afterUnitRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnectionMock.UnitRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UnitRepositoryMock.expectedInvocations), m.UnitRepositoryMock.expectedInvocationsOrigin, afterUnitRepositoryCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConnectionMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginInspect()

			m.MinimockCarRepositoryInspect()

			m.MinimockDBInspect()

			m.MinimockParkingRepositoryInspect()

			m.MinimockSessionRepositoryInspect()

			m.MinimockTariffRepositoryInspect()

			m.MinimockUnitRepositoryInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConnectionMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConnectionMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockCarRepositoryDone() &&
		m.MinimockDBDone() &&
		m.MinimockParkingRepositoryDone() &&
		m.MinimockSessionRepositoryDone() &&
		m.MinimockTariffRepositoryDone() &&
		m.MinimockUnitRepositoryDone()
}
