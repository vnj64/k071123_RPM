// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain.Context -o context_mock_test.go -n ContextMock -p mocks

import (
	mm_domain "k071123/internal/services/parking_service/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ContextMock implements mm_domain.Context
type ContextMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConnection          func() (c1 mm_domain.Connection)
	funcConnectionOrigin    string
	inspectFuncConnection   func()
	afterConnectionCounter  uint64
	beforeConnectionCounter uint64
	ConnectionMock          mContextMockConnection

	funcMake          func() (c1 mm_domain.Context)
	funcMakeOrigin    string
	inspectFuncMake   func()
	afterMakeCounter  uint64
	beforeMakeCounter uint64
	MakeMock          mContextMockMake

	funcServices          func() (s1 mm_domain.Services)
	funcServicesOrigin    string
	inspectFuncServices   func()
	afterServicesCounter  uint64
	beforeServicesCounter uint64
	ServicesMock          mContextMockServices
}

// NewContextMock returns a mock for mm_domain.Context
func NewContextMock(t minimock.Tester) *ContextMock {
	m := &ContextMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConnectionMock = mContextMockConnection{mock: m}

	m.MakeMock = mContextMockMake{mock: m}

	m.ServicesMock = mContextMockServices{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mContextMockConnection struct {
	optional           bool
	mock               *ContextMock
	defaultExpectation *ContextMockConnectionExpectation
	expectations       []*ContextMockConnectionExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ContextMockConnectionExpectation specifies expectation struct of the Context.Connection
type ContextMockConnectionExpectation struct {
	mock *ContextMock

	results      *ContextMockConnectionResults
	returnOrigin string
	Counter      uint64
}

// ContextMockConnectionResults contains results of the Context.Connection
type ContextMockConnectionResults struct {
	c1 mm_domain.Connection
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConnection *mContextMockConnection) Optional() *mContextMockConnection {
	mmConnection.optional = true
	return mmConnection
}

// Expect sets up expected params for Context.Connection
func (mmConnection *mContextMockConnection) Expect() *mContextMockConnection {
	if mmConnection.mock.funcConnection != nil {
		mmConnection.mock.t.Fatalf("ContextMock.Connection mock is already set by Set")
	}

	if mmConnection.defaultExpectation == nil {
		mmConnection.defaultExpectation = &ContextMockConnectionExpectation{}
	}

	return mmConnection
}

// Inspect accepts an inspector function that has same arguments as the Context.Connection
func (mmConnection *mContextMockConnection) Inspect(f func()) *mContextMockConnection {
	if mmConnection.mock.inspectFuncConnection != nil {
		mmConnection.mock.t.Fatalf("Inspect function is already set for ContextMock.Connection")
	}

	mmConnection.mock.inspectFuncConnection = f

	return mmConnection
}

// Return sets up results that will be returned by Context.Connection
func (mmConnection *mContextMockConnection) Return(c1 mm_domain.Connection) *ContextMock {
	if mmConnection.mock.funcConnection != nil {
		mmConnection.mock.t.Fatalf("ContextMock.Connection mock is already set by Set")
	}

	if mmConnection.defaultExpectation == nil {
		mmConnection.defaultExpectation = &ContextMockConnectionExpectation{mock: mmConnection.mock}
	}
	mmConnection.defaultExpectation.results = &ContextMockConnectionResults{c1}
	mmConnection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConnection.mock
}

// Set uses given function f to mock the Context.Connection method
func (mmConnection *mContextMockConnection) Set(f func() (c1 mm_domain.Connection)) *ContextMock {
	if mmConnection.defaultExpectation != nil {
		mmConnection.mock.t.Fatalf("Default expectation is already set for the Context.Connection method")
	}

	if len(mmConnection.expectations) > 0 {
		mmConnection.mock.t.Fatalf("Some expectations are already set for the Context.Connection method")
	}

	mmConnection.mock.funcConnection = f
	mmConnection.mock.funcConnectionOrigin = minimock.CallerInfo(1)
	return mmConnection.mock
}

// Times sets number of times Context.Connection should be invoked
func (mmConnection *mContextMockConnection) Times(n uint64) *mContextMockConnection {
	if n == 0 {
		mmConnection.mock.t.Fatalf("Times of ContextMock.Connection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConnection.expectedInvocations, n)
	mmConnection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConnection
}

func (mmConnection *mContextMockConnection) invocationsDone() bool {
	if len(mmConnection.expectations) == 0 && mmConnection.defaultExpectation == nil && mmConnection.mock.funcConnection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConnection.mock.afterConnectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConnection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Connection implements mm_domain.Context
func (mmConnection *ContextMock) Connection() (c1 mm_domain.Connection) {
	mm_atomic.AddUint64(&mmConnection.beforeConnectionCounter, 1)
	defer mm_atomic.AddUint64(&mmConnection.afterConnectionCounter, 1)

	mmConnection.t.Helper()

	if mmConnection.inspectFuncConnection != nil {
		mmConnection.inspectFuncConnection()
	}

	if mmConnection.ConnectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnection.ConnectionMock.defaultExpectation.Counter, 1)

		mm_results := mmConnection.ConnectionMock.defaultExpectation.results
		if mm_results == nil {
			mmConnection.t.Fatal("No results are set for the ContextMock.Connection")
		}
		return (*mm_results).c1
	}
	if mmConnection.funcConnection != nil {
		return mmConnection.funcConnection()
	}
	mmConnection.t.Fatalf("Unexpected call to ContextMock.Connection.")
	return
}

// ConnectionAfterCounter returns a count of finished ContextMock.Connection invocations
func (mmConnection *ContextMock) ConnectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnection.afterConnectionCounter)
}

// ConnectionBeforeCounter returns a count of ContextMock.Connection invocations
func (mmConnection *ContextMock) ConnectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnection.beforeConnectionCounter)
}

// MinimockConnectionDone returns true if the count of the Connection invocations corresponds
// the number of defined expectations
func (m *ContextMock) MinimockConnectionDone() bool {
	if m.ConnectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnectionMock.invocationsDone()
}

// MinimockConnectionInspect logs each unmet expectation
func (m *ContextMock) MinimockConnectionInspect() {
	for _, e := range m.ConnectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContextMock.Connection")
		}
	}

	afterConnectionCounter := mm_atomic.LoadUint64(&m.afterConnectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectionMock.defaultExpectation != nil && afterConnectionCounter < 1 {
		m.t.Errorf("Expected call to ContextMock.Connection at\n%s", m.ConnectionMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnection != nil && afterConnectionCounter < 1 {
		m.t.Errorf("Expected call to ContextMock.Connection at\n%s", m.funcConnectionOrigin)
	}

	if !m.ConnectionMock.invocationsDone() && afterConnectionCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextMock.Connection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConnectionMock.expectedInvocations), m.ConnectionMock.expectedInvocationsOrigin, afterConnectionCounter)
	}
}

type mContextMockMake struct {
	optional           bool
	mock               *ContextMock
	defaultExpectation *ContextMockMakeExpectation
	expectations       []*ContextMockMakeExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ContextMockMakeExpectation specifies expectation struct of the Context.Make
type ContextMockMakeExpectation struct {
	mock *ContextMock

	results      *ContextMockMakeResults
	returnOrigin string
	Counter      uint64
}

// ContextMockMakeResults contains results of the Context.Make
type ContextMockMakeResults struct {
	c1 mm_domain.Context
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMake *mContextMockMake) Optional() *mContextMockMake {
	mmMake.optional = true
	return mmMake
}

// Expect sets up expected params for Context.Make
func (mmMake *mContextMockMake) Expect() *mContextMockMake {
	if mmMake.mock.funcMake != nil {
		mmMake.mock.t.Fatalf("ContextMock.Make mock is already set by Set")
	}

	if mmMake.defaultExpectation == nil {
		mmMake.defaultExpectation = &ContextMockMakeExpectation{}
	}

	return mmMake
}

// Inspect accepts an inspector function that has same arguments as the Context.Make
func (mmMake *mContextMockMake) Inspect(f func()) *mContextMockMake {
	if mmMake.mock.inspectFuncMake != nil {
		mmMake.mock.t.Fatalf("Inspect function is already set for ContextMock.Make")
	}

	mmMake.mock.inspectFuncMake = f

	return mmMake
}

// Return sets up results that will be returned by Context.Make
func (mmMake *mContextMockMake) Return(c1 mm_domain.Context) *ContextMock {
	if mmMake.mock.funcMake != nil {
		mmMake.mock.t.Fatalf("ContextMock.Make mock is already set by Set")
	}

	if mmMake.defaultExpectation == nil {
		mmMake.defaultExpectation = &ContextMockMakeExpectation{mock: mmMake.mock}
	}
	mmMake.defaultExpectation.results = &ContextMockMakeResults{c1}
	mmMake.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMake.mock
}

// Set uses given function f to mock the Context.Make method
func (mmMake *mContextMockMake) Set(f func() (c1 mm_domain.Context)) *ContextMock {
	if mmMake.defaultExpectation != nil {
		mmMake.mock.t.Fatalf("Default expectation is already set for the Context.Make method")
	}

	if len(mmMake.expectations) > 0 {
		mmMake.mock.t.Fatalf("Some expectations are already set for the Context.Make method")
	}

	mmMake.mock.funcMake = f
	mmMake.mock.funcMakeOrigin = minimock.CallerInfo(1)
	return mmMake.mock
}

// Times sets number of times Context.Make should be invoked
func (mmMake *mContextMockMake) Times(n uint64) *mContextMockMake {
	if n == 0 {
		mmMake.mock.t.Fatalf("Times of ContextMock.Make mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMake.expectedInvocations, n)
	mmMake.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMake
}

func (mmMake *mContextMockMake) invocationsDone() bool {
	if len(mmMake.expectations) == 0 && mmMake.defaultExpectation == nil && mmMake.mock.funcMake == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMake.mock.afterMakeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMake.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Make implements mm_domain.Context
func (mmMake *ContextMock) Make() (c1 mm_domain.Context) {
	mm_atomic.AddUint64(&mmMake.beforeMakeCounter, 1)
	defer mm_atomic.AddUint64(&mmMake.afterMakeCounter, 1)

	mmMake.t.Helper()

	if mmMake.inspectFuncMake != nil {
		mmMake.inspectFuncMake()
	}

	if mmMake.MakeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMake.MakeMock.defaultExpectation.Counter, 1)

		mm_results := mmMake.MakeMock.defaultExpectation.results
		if mm_results == nil {
			mmMake.t.Fatal("No results are set for the ContextMock.Make")
		}
		return (*mm_results).c1
	}
	if mmMake.funcMake != nil {
		return mmMake.funcMake()
	}
	mmMake.t.Fatalf("Unexpected call to ContextMock.Make.")
	return
}

// MakeAfterCounter returns a count of finished ContextMock.Make invocations
func (mmMake *ContextMock) MakeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMake.afterMakeCounter)
}

// MakeBeforeCounter returns a count of ContextMock.Make invocations
func (mmMake *ContextMock) MakeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMake.beforeMakeCounter)
}

// MinimockMakeDone returns true if the count of the Make invocations corresponds
// the number of defined expectations
func (m *ContextMock) MinimockMakeDone() bool {
	if m.MakeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MakeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MakeMock.invocationsDone()
}

// MinimockMakeInspect logs each unmet expectation
func (m *ContextMock) MinimockMakeInspect() {
	for _, e := range m.MakeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContextMock.Make")
		}
	}

	afterMakeCounter := mm_atomic.LoadUint64(&m.afterMakeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MakeMock.defaultExpectation != nil && afterMakeCounter < 1 {
		m.t.Errorf("Expected call to ContextMock.Make at\n%s", m.MakeMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMake != nil && afterMakeCounter < 1 {
		m.t.Errorf("Expected call to ContextMock.Make at\n%s", m.funcMakeOrigin)
	}

	if !m.MakeMock.invocationsDone() && afterMakeCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextMock.Make at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MakeMock.expectedInvocations), m.MakeMock.expectedInvocationsOrigin, afterMakeCounter)
	}
}

type mContextMockServices struct {
	optional           bool
	mock               *ContextMock
	defaultExpectation *ContextMockServicesExpectation
	expectations       []*ContextMockServicesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ContextMockServicesExpectation specifies expectation struct of the Context.Services
type ContextMockServicesExpectation struct {
	mock *ContextMock

	results      *ContextMockServicesResults
	returnOrigin string
	Counter      uint64
}

// ContextMockServicesResults contains results of the Context.Services
type ContextMockServicesResults struct {
	s1 mm_domain.Services
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmServices *mContextMockServices) Optional() *mContextMockServices {
	mmServices.optional = true
	return mmServices
}

// Expect sets up expected params for Context.Services
func (mmServices *mContextMockServices) Expect() *mContextMockServices {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("ContextMock.Services mock is already set by Set")
	}

	if mmServices.defaultExpectation == nil {
		mmServices.defaultExpectation = &ContextMockServicesExpectation{}
	}

	return mmServices
}

// Inspect accepts an inspector function that has same arguments as the Context.Services
func (mmServices *mContextMockServices) Inspect(f func()) *mContextMockServices {
	if mmServices.mock.inspectFuncServices != nil {
		mmServices.mock.t.Fatalf("Inspect function is already set for ContextMock.Services")
	}

	mmServices.mock.inspectFuncServices = f

	return mmServices
}

// Return sets up results that will be returned by Context.Services
func (mmServices *mContextMockServices) Return(s1 mm_domain.Services) *ContextMock {
	if mmServices.mock.funcServices != nil {
		mmServices.mock.t.Fatalf("ContextMock.Services mock is already set by Set")
	}

	if mmServices.defaultExpectation == nil {
		mmServices.defaultExpectation = &ContextMockServicesExpectation{mock: mmServices.mock}
	}
	mmServices.defaultExpectation.results = &ContextMockServicesResults{s1}
	mmServices.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmServices.mock
}

// Set uses given function f to mock the Context.Services method
func (mmServices *mContextMockServices) Set(f func() (s1 mm_domain.Services)) *ContextMock {
	if mmServices.defaultExpectation != nil {
		mmServices.mock.t.Fatalf("Default expectation is already set for the Context.Services method")
	}

	if len(mmServices.expectations) > 0 {
		mmServices.mock.t.Fatalf("Some expectations are already set for the Context.Services method")
	}

	mmServices.mock.funcServices = f
	mmServices.mock.funcServicesOrigin = minimock.CallerInfo(1)
	return mmServices.mock
}

// Times sets number of times Context.Services should be invoked
func (mmServices *mContextMockServices) Times(n uint64) *mContextMockServices {
	if n == 0 {
		mmServices.mock.t.Fatalf("Times of ContextMock.Services mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmServices.expectedInvocations, n)
	mmServices.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmServices
}

func (mmServices *mContextMockServices) invocationsDone() bool {
	if len(mmServices.expectations) == 0 && mmServices.defaultExpectation == nil && mmServices.mock.funcServices == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmServices.mock.afterServicesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmServices.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Services implements mm_domain.Context
func (mmServices *ContextMock) Services() (s1 mm_domain.Services) {
	mm_atomic.AddUint64(&mmServices.beforeServicesCounter, 1)
	defer mm_atomic.AddUint64(&mmServices.afterServicesCounter, 1)

	mmServices.t.Helper()

	if mmServices.inspectFuncServices != nil {
		mmServices.inspectFuncServices()
	}

	if mmServices.ServicesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmServices.ServicesMock.defaultExpectation.Counter, 1)

		mm_results := mmServices.ServicesMock.defaultExpectation.results
		if mm_results == nil {
			mmServices.t.Fatal("No results are set for the ContextMock.Services")
		}
		return (*mm_results).s1
	}
	if mmServices.funcServices != nil {
		return mmServices.funcServices()
	}
	mmServices.t.Fatalf("Unexpected call to ContextMock.Services.")
	return
}

// ServicesAfterCounter returns a count of finished ContextMock.Services invocations
func (mmServices *ContextMock) ServicesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmServices.afterServicesCounter)
}

// ServicesBeforeCounter returns a count of ContextMock.Services invocations
func (mmServices *ContextMock) ServicesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmServices.beforeServicesCounter)
}

// MinimockServicesDone returns true if the count of the Services invocations corresponds
// the number of defined expectations
func (m *ContextMock) MinimockServicesDone() bool {
	if m.ServicesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ServicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ServicesMock.invocationsDone()
}

// MinimockServicesInspect logs each unmet expectation
func (m *ContextMock) MinimockServicesInspect() {
	for _, e := range m.ServicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContextMock.Services")
		}
	}

	afterServicesCounter := mm_atomic.LoadUint64(&m.afterServicesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ServicesMock.defaultExpectation != nil && afterServicesCounter < 1 {
		m.t.Errorf("Expected call to ContextMock.Services at\n%s", m.ServicesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcServices != nil && afterServicesCounter < 1 {
		m.t.Errorf("Expected call to ContextMock.Services at\n%s", m.funcServicesOrigin)
	}

	if !m.ServicesMock.invocationsDone() && afterServicesCounter > 0 {
		m.t.Errorf("Expected %d calls to ContextMock.Services at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ServicesMock.expectedInvocations), m.ServicesMock.expectedInvocationsOrigin, afterServicesCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContextMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConnectionInspect()

			m.MinimockMakeInspect()

			m.MinimockServicesInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConnectionDone() &&
		m.MinimockMakeDone() &&
		m.MinimockServicesDone()
}
