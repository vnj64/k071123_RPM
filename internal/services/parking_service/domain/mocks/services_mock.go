// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain.Services -o services_mock_test.go -n ServicesMock -p mocks

import (
	"k071123/internal/services/parking_service/domain/services"
	"k071123/tools/logger"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ServicesMock implements mm_domain.Services
type ServicesMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConfig          func() (c1 services.Config)
	funcConfigOrigin    string
	inspectFuncConfig   func()
	afterConfigCounter  uint64
	beforeConfigCounter uint64
	ConfigMock          mServicesMockConfig

	funcLogger          func() (lp1 *logger.Logger)
	funcLoggerOrigin    string
	inspectFuncLogger   func()
	afterLoggerCounter  uint64
	beforeLoggerCounter uint64
	LoggerMock          mServicesMockLogger
}

// NewServicesMock returns a mock for mm_domain.Services
func NewServicesMock(t minimock.Tester) *ServicesMock {
	m := &ServicesMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConfigMock = mServicesMockConfig{mock: m}

	m.LoggerMock = mServicesMockLogger{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServicesMockConfig struct {
	optional           bool
	mock               *ServicesMock
	defaultExpectation *ServicesMockConfigExpectation
	expectations       []*ServicesMockConfigExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServicesMockConfigExpectation specifies expectation struct of the Services.Config
type ServicesMockConfigExpectation struct {
	mock *ServicesMock

	results      *ServicesMockConfigResults
	returnOrigin string
	Counter      uint64
}

// ServicesMockConfigResults contains results of the Services.Config
type ServicesMockConfigResults struct {
	c1 services.Config
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConfig *mServicesMockConfig) Optional() *mServicesMockConfig {
	mmConfig.optional = true
	return mmConfig
}

// Expect sets up expected params for Services.Config
func (mmConfig *mServicesMockConfig) Expect() *mServicesMockConfig {
	if mmConfig.mock.funcConfig != nil {
		mmConfig.mock.t.Fatalf("ServicesMock.Config mock is already set by Set")
	}

	if mmConfig.defaultExpectation == nil {
		mmConfig.defaultExpectation = &ServicesMockConfigExpectation{}
	}

	return mmConfig
}

// Inspect accepts an inspector function that has same arguments as the Services.Config
func (mmConfig *mServicesMockConfig) Inspect(f func()) *mServicesMockConfig {
	if mmConfig.mock.inspectFuncConfig != nil {
		mmConfig.mock.t.Fatalf("Inspect function is already set for ServicesMock.Config")
	}

	mmConfig.mock.inspectFuncConfig = f

	return mmConfig
}

// Return sets up results that will be returned by Services.Config
func (mmConfig *mServicesMockConfig) Return(c1 services.Config) *ServicesMock {
	if mmConfig.mock.funcConfig != nil {
		mmConfig.mock.t.Fatalf("ServicesMock.Config mock is already set by Set")
	}

	if mmConfig.defaultExpectation == nil {
		mmConfig.defaultExpectation = &ServicesMockConfigExpectation{mock: mmConfig.mock}
	}
	mmConfig.defaultExpectation.results = &ServicesMockConfigResults{c1}
	mmConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConfig.mock
}

// Set uses given function f to mock the Services.Config method
func (mmConfig *mServicesMockConfig) Set(f func() (c1 services.Config)) *ServicesMock {
	if mmConfig.defaultExpectation != nil {
		mmConfig.mock.t.Fatalf("Default expectation is already set for the Services.Config method")
	}

	if len(mmConfig.expectations) > 0 {
		mmConfig.mock.t.Fatalf("Some expectations are already set for the Services.Config method")
	}

	mmConfig.mock.funcConfig = f
	mmConfig.mock.funcConfigOrigin = minimock.CallerInfo(1)
	return mmConfig.mock
}

// Times sets number of times Services.Config should be invoked
func (mmConfig *mServicesMockConfig) Times(n uint64) *mServicesMockConfig {
	if n == 0 {
		mmConfig.mock.t.Fatalf("Times of ServicesMock.Config mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConfig.expectedInvocations, n)
	mmConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConfig
}

func (mmConfig *mServicesMockConfig) invocationsDone() bool {
	if len(mmConfig.expectations) == 0 && mmConfig.defaultExpectation == nil && mmConfig.mock.funcConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConfig.mock.afterConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Config implements mm_domain.Services
func (mmConfig *ServicesMock) Config() (c1 services.Config) {
	mm_atomic.AddUint64(&mmConfig.beforeConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmConfig.afterConfigCounter, 1)

	mmConfig.t.Helper()

	if mmConfig.inspectFuncConfig != nil {
		mmConfig.inspectFuncConfig()
	}

	if mmConfig.ConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConfig.ConfigMock.defaultExpectation.Counter, 1)

		mm_results := mmConfig.ConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmConfig.t.Fatal("No results are set for the ServicesMock.Config")
		}
		return (*mm_results).c1
	}
	if mmConfig.funcConfig != nil {
		return mmConfig.funcConfig()
	}
	mmConfig.t.Fatalf("Unexpected call to ServicesMock.Config.")
	return
}

// ConfigAfterCounter returns a count of finished ServicesMock.Config invocations
func (mmConfig *ServicesMock) ConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfig.afterConfigCounter)
}

// ConfigBeforeCounter returns a count of ServicesMock.Config invocations
func (mmConfig *ServicesMock) ConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfig.beforeConfigCounter)
}

// MinimockConfigDone returns true if the count of the Config invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockConfigDone() bool {
	if m.ConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConfigMock.invocationsDone()
}

// MinimockConfigInspect logs each unmet expectation
func (m *ServicesMock) MinimockConfigInspect() {
	for _, e := range m.ConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServicesMock.Config")
		}
	}

	afterConfigCounter := mm_atomic.LoadUint64(&m.afterConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConfigMock.defaultExpectation != nil && afterConfigCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Config at\n%s", m.ConfigMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConfig != nil && afterConfigCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Config at\n%s", m.funcConfigOrigin)
	}

	if !m.ConfigMock.invocationsDone() && afterConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to ServicesMock.Config at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConfigMock.expectedInvocations), m.ConfigMock.expectedInvocationsOrigin, afterConfigCounter)
	}
}

type mServicesMockLogger struct {
	optional           bool
	mock               *ServicesMock
	defaultExpectation *ServicesMockLoggerExpectation
	expectations       []*ServicesMockLoggerExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServicesMockLoggerExpectation specifies expectation struct of the Services.Logger
type ServicesMockLoggerExpectation struct {
	mock *ServicesMock

	results      *ServicesMockLoggerResults
	returnOrigin string
	Counter      uint64
}

// ServicesMockLoggerResults contains results of the Services.Logger
type ServicesMockLoggerResults struct {
	lp1 *logger.Logger
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogger *mServicesMockLogger) Optional() *mServicesMockLogger {
	mmLogger.optional = true
	return mmLogger
}

// Expect sets up expected params for Services.Logger
func (mmLogger *mServicesMockLogger) Expect() *mServicesMockLogger {
	if mmLogger.mock.funcLogger != nil {
		mmLogger.mock.t.Fatalf("ServicesMock.Logger mock is already set by Set")
	}

	if mmLogger.defaultExpectation == nil {
		mmLogger.defaultExpectation = &ServicesMockLoggerExpectation{}
	}

	return mmLogger
}

// Inspect accepts an inspector function that has same arguments as the Services.Logger
func (mmLogger *mServicesMockLogger) Inspect(f func()) *mServicesMockLogger {
	if mmLogger.mock.inspectFuncLogger != nil {
		mmLogger.mock.t.Fatalf("Inspect function is already set for ServicesMock.Logger")
	}

	mmLogger.mock.inspectFuncLogger = f

	return mmLogger
}

// Return sets up results that will be returned by Services.Logger
func (mmLogger *mServicesMockLogger) Return(lp1 *logger.Logger) *ServicesMock {
	if mmLogger.mock.funcLogger != nil {
		mmLogger.mock.t.Fatalf("ServicesMock.Logger mock is already set by Set")
	}

	if mmLogger.defaultExpectation == nil {
		mmLogger.defaultExpectation = &ServicesMockLoggerExpectation{mock: mmLogger.mock}
	}
	mmLogger.defaultExpectation.results = &ServicesMockLoggerResults{lp1}
	mmLogger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogger.mock
}

// Set uses given function f to mock the Services.Logger method
func (mmLogger *mServicesMockLogger) Set(f func() (lp1 *logger.Logger)) *ServicesMock {
	if mmLogger.defaultExpectation != nil {
		mmLogger.mock.t.Fatalf("Default expectation is already set for the Services.Logger method")
	}

	if len(mmLogger.expectations) > 0 {
		mmLogger.mock.t.Fatalf("Some expectations are already set for the Services.Logger method")
	}

	mmLogger.mock.funcLogger = f
	mmLogger.mock.funcLoggerOrigin = minimock.CallerInfo(1)
	return mmLogger.mock
}

// Times sets number of times Services.Logger should be invoked
func (mmLogger *mServicesMockLogger) Times(n uint64) *mServicesMockLogger {
	if n == 0 {
		mmLogger.mock.t.Fatalf("Times of ServicesMock.Logger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogger.expectedInvocations, n)
	mmLogger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogger
}

func (mmLogger *mServicesMockLogger) invocationsDone() bool {
	if len(mmLogger.expectations) == 0 && mmLogger.defaultExpectation == nil && mmLogger.mock.funcLogger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogger.mock.afterLoggerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Logger implements mm_domain.Services
func (mmLogger *ServicesMock) Logger() (lp1 *logger.Logger) {
	mm_atomic.AddUint64(&mmLogger.beforeLoggerCounter, 1)
	defer mm_atomic.AddUint64(&mmLogger.afterLoggerCounter, 1)

	mmLogger.t.Helper()

	if mmLogger.inspectFuncLogger != nil {
		mmLogger.inspectFuncLogger()
	}

	if mmLogger.LoggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogger.LoggerMock.defaultExpectation.Counter, 1)

		mm_results := mmLogger.LoggerMock.defaultExpectation.results
		if mm_results == nil {
			mmLogger.t.Fatal("No results are set for the ServicesMock.Logger")
		}
		return (*mm_results).lp1
	}
	if mmLogger.funcLogger != nil {
		return mmLogger.funcLogger()
	}
	mmLogger.t.Fatalf("Unexpected call to ServicesMock.Logger.")
	return
}

// LoggerAfterCounter returns a count of finished ServicesMock.Logger invocations
func (mmLogger *ServicesMock) LoggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogger.afterLoggerCounter)
}

// LoggerBeforeCounter returns a count of ServicesMock.Logger invocations
func (mmLogger *ServicesMock) LoggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogger.beforeLoggerCounter)
}

// MinimockLoggerDone returns true if the count of the Logger invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockLoggerDone() bool {
	if m.LoggerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoggerMock.invocationsDone()
}

// MinimockLoggerInspect logs each unmet expectation
func (m *ServicesMock) MinimockLoggerInspect() {
	for _, e := range m.LoggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServicesMock.Logger")
		}
	}

	afterLoggerCounter := mm_atomic.LoadUint64(&m.afterLoggerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoggerMock.defaultExpectation != nil && afterLoggerCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Logger at\n%s", m.LoggerMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogger != nil && afterLoggerCounter < 1 {
		m.t.Errorf("Expected call to ServicesMock.Logger at\n%s", m.funcLoggerOrigin)
	}

	if !m.LoggerMock.invocationsDone() && afterLoggerCounter > 0 {
		m.t.Errorf("Expected %d calls to ServicesMock.Logger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoggerMock.expectedInvocations), m.LoggerMock.expectedInvocationsOrigin, afterLoggerCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServicesMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConfigInspect()

			m.MinimockLoggerInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServicesMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServicesMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConfigDone() &&
		m.MinimockLoggerDone()
}
