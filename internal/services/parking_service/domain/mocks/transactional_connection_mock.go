// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain.TransactionalConnection -o transactional_connection_mock_test.go -n TransactionalConnectionMock -p mocks

import (
	mm_domain "k071123/internal/services/parking_service/domain"
	"k071123/internal/services/parking_service/domain/repositories"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gorm.io/gorm"
)

// TransactionalConnectionMock implements mm_domain.TransactionalConnection
type TransactionalConnectionMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBegin          func() (t1 mm_domain.TransactionalConnection, err error)
	funcBeginOrigin    string
	inspectFuncBegin   func()
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mTransactionalConnectionMockBegin

	funcCarRepository          func() (c1 repositories.CarRepository)
	funcCarRepositoryOrigin    string
	inspectFuncCarRepository   func()
	afterCarRepositoryCounter  uint64
	beforeCarRepositoryCounter uint64
	CarRepositoryMock          mTransactionalConnectionMockCarRepository

	funcCommit          func() (err error)
	funcCommitOrigin    string
	inspectFuncCommit   func()
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mTransactionalConnectionMockCommit

	funcDB          func() (dp1 *gorm.DB)
	funcDBOrigin    string
	inspectFuncDB   func()
	afterDBCounter  uint64
	beforeDBCounter uint64
	DBMock          mTransactionalConnectionMockDB

	funcParkingRepository          func() (p1 repositories.ParkingRepository)
	funcParkingRepositoryOrigin    string
	inspectFuncParkingRepository   func()
	afterParkingRepositoryCounter  uint64
	beforeParkingRepositoryCounter uint64
	ParkingRepositoryMock          mTransactionalConnectionMockParkingRepository

	funcRollback          func() (err error)
	funcRollbackOrigin    string
	inspectFuncRollback   func()
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mTransactionalConnectionMockRollback

	funcSessionRepository          func() (s1 repositories.SessionRepository)
	funcSessionRepositoryOrigin    string
	inspectFuncSessionRepository   func()
	afterSessionRepositoryCounter  uint64
	beforeSessionRepositoryCounter uint64
	SessionRepositoryMock          mTransactionalConnectionMockSessionRepository

	funcTariffRepository          func() (t1 repositories.TariffRepository)
	funcTariffRepositoryOrigin    string
	inspectFuncTariffRepository   func()
	afterTariffRepositoryCounter  uint64
	beforeTariffRepositoryCounter uint64
	TariffRepositoryMock          mTransactionalConnectionMockTariffRepository

	funcUnitRepository          func() (u1 repositories.UnitRepository)
	funcUnitRepositoryOrigin    string
	inspectFuncUnitRepository   func()
	afterUnitRepositoryCounter  uint64
	beforeUnitRepositoryCounter uint64
	UnitRepositoryMock          mTransactionalConnectionMockUnitRepository
}

// NewTransactionalConnectionMock returns a mock for mm_domain.TransactionalConnection
func NewTransactionalConnectionMock(t minimock.Tester) *TransactionalConnectionMock {
	m := &TransactionalConnectionMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mTransactionalConnectionMockBegin{mock: m}

	m.CarRepositoryMock = mTransactionalConnectionMockCarRepository{mock: m}

	m.CommitMock = mTransactionalConnectionMockCommit{mock: m}

	m.DBMock = mTransactionalConnectionMockDB{mock: m}

	m.ParkingRepositoryMock = mTransactionalConnectionMockParkingRepository{mock: m}

	m.RollbackMock = mTransactionalConnectionMockRollback{mock: m}

	m.SessionRepositoryMock = mTransactionalConnectionMockSessionRepository{mock: m}

	m.TariffRepositoryMock = mTransactionalConnectionMockTariffRepository{mock: m}

	m.UnitRepositoryMock = mTransactionalConnectionMockUnitRepository{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTransactionalConnectionMockBegin struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockBeginExpectation
	expectations       []*TransactionalConnectionMockBeginExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockBeginExpectation specifies expectation struct of the TransactionalConnection.Begin
type TransactionalConnectionMockBeginExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockBeginResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockBeginResults contains results of the TransactionalConnection.Begin
type TransactionalConnectionMockBeginResults struct {
	t1  mm_domain.TransactionalConnection
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBegin *mTransactionalConnectionMockBegin) Optional() *mTransactionalConnectionMockBegin {
	mmBegin.optional = true
	return mmBegin
}

// Expect sets up expected params for TransactionalConnection.Begin
func (mmBegin *mTransactionalConnectionMockBegin) Expect() *mTransactionalConnectionMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TransactionalConnectionMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TransactionalConnectionMockBeginExpectation{}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.Begin
func (mmBegin *mTransactionalConnectionMockBegin) Inspect(f func()) *mTransactionalConnectionMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by TransactionalConnection.Begin
func (mmBegin *mTransactionalConnectionMockBegin) Return(t1 mm_domain.TransactionalConnection, err error) *TransactionalConnectionMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TransactionalConnectionMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TransactionalConnectionMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &TransactionalConnectionMockBeginResults{t1, err}
	mmBegin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// Set uses given function f to mock the TransactionalConnection.Begin method
func (mmBegin *mTransactionalConnectionMockBegin) Set(f func() (t1 mm_domain.TransactionalConnection, err error)) *TransactionalConnectionMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.Begin method")
	}

	mmBegin.mock.funcBegin = f
	mmBegin.mock.funcBeginOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// Times sets number of times TransactionalConnection.Begin should be invoked
func (mmBegin *mTransactionalConnectionMockBegin) Times(n uint64) *mTransactionalConnectionMockBegin {
	if n == 0 {
		mmBegin.mock.t.Fatalf("Times of TransactionalConnectionMock.Begin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBegin.expectedInvocations, n)
	mmBegin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBegin
}

func (mmBegin *mTransactionalConnectionMockBegin) invocationsDone() bool {
	if len(mmBegin.expectations) == 0 && mmBegin.defaultExpectation == nil && mmBegin.mock.funcBegin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBegin.mock.afterBeginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBegin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Begin implements mm_domain.TransactionalConnection
func (mmBegin *TransactionalConnectionMock) Begin() (t1 mm_domain.TransactionalConnection, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	mmBegin.t.Helper()

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin()
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the TransactionalConnectionMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin()
	}
	mmBegin.t.Fatalf("Unexpected call to TransactionalConnectionMock.Begin.")
	return
}

// BeginAfterCounter returns a count of finished TransactionalConnectionMock.Begin invocations
func (mmBegin *TransactionalConnectionMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of TransactionalConnectionMock.Begin invocations
func (mmBegin *TransactionalConnectionMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockBeginDone() bool {
	if m.BeginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginMock.invocationsDone()
}

// MinimockBeginInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.Begin")
		}
	}

	afterBeginCounter := mm_atomic.LoadUint64(&m.afterBeginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && afterBeginCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.Begin at\n%s", m.BeginMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && afterBeginCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.Begin at\n%s", m.funcBeginOrigin)
	}

	if !m.BeginMock.invocationsDone() && afterBeginCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.Begin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginMock.expectedInvocations), m.BeginMock.expectedInvocationsOrigin, afterBeginCounter)
	}
}

type mTransactionalConnectionMockCarRepository struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockCarRepositoryExpectation
	expectations       []*TransactionalConnectionMockCarRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockCarRepositoryExpectation specifies expectation struct of the TransactionalConnection.CarRepository
type TransactionalConnectionMockCarRepositoryExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockCarRepositoryResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockCarRepositoryResults contains results of the TransactionalConnection.CarRepository
type TransactionalConnectionMockCarRepositoryResults struct {
	c1 repositories.CarRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCarRepository *mTransactionalConnectionMockCarRepository) Optional() *mTransactionalConnectionMockCarRepository {
	mmCarRepository.optional = true
	return mmCarRepository
}

// Expect sets up expected params for TransactionalConnection.CarRepository
func (mmCarRepository *mTransactionalConnectionMockCarRepository) Expect() *mTransactionalConnectionMockCarRepository {
	if mmCarRepository.mock.funcCarRepository != nil {
		mmCarRepository.mock.t.Fatalf("TransactionalConnectionMock.CarRepository mock is already set by Set")
	}

	if mmCarRepository.defaultExpectation == nil {
		mmCarRepository.defaultExpectation = &TransactionalConnectionMockCarRepositoryExpectation{}
	}

	return mmCarRepository
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.CarRepository
func (mmCarRepository *mTransactionalConnectionMockCarRepository) Inspect(f func()) *mTransactionalConnectionMockCarRepository {
	if mmCarRepository.mock.inspectFuncCarRepository != nil {
		mmCarRepository.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.CarRepository")
	}

	mmCarRepository.mock.inspectFuncCarRepository = f

	return mmCarRepository
}

// Return sets up results that will be returned by TransactionalConnection.CarRepository
func (mmCarRepository *mTransactionalConnectionMockCarRepository) Return(c1 repositories.CarRepository) *TransactionalConnectionMock {
	if mmCarRepository.mock.funcCarRepository != nil {
		mmCarRepository.mock.t.Fatalf("TransactionalConnectionMock.CarRepository mock is already set by Set")
	}

	if mmCarRepository.defaultExpectation == nil {
		mmCarRepository.defaultExpectation = &TransactionalConnectionMockCarRepositoryExpectation{mock: mmCarRepository.mock}
	}
	mmCarRepository.defaultExpectation.results = &TransactionalConnectionMockCarRepositoryResults{c1}
	mmCarRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCarRepository.mock
}

// Set uses given function f to mock the TransactionalConnection.CarRepository method
func (mmCarRepository *mTransactionalConnectionMockCarRepository) Set(f func() (c1 repositories.CarRepository)) *TransactionalConnectionMock {
	if mmCarRepository.defaultExpectation != nil {
		mmCarRepository.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.CarRepository method")
	}

	if len(mmCarRepository.expectations) > 0 {
		mmCarRepository.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.CarRepository method")
	}

	mmCarRepository.mock.funcCarRepository = f
	mmCarRepository.mock.funcCarRepositoryOrigin = minimock.CallerInfo(1)
	return mmCarRepository.mock
}

// Times sets number of times TransactionalConnection.CarRepository should be invoked
func (mmCarRepository *mTransactionalConnectionMockCarRepository) Times(n uint64) *mTransactionalConnectionMockCarRepository {
	if n == 0 {
		mmCarRepository.mock.t.Fatalf("Times of TransactionalConnectionMock.CarRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCarRepository.expectedInvocations, n)
	mmCarRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCarRepository
}

func (mmCarRepository *mTransactionalConnectionMockCarRepository) invocationsDone() bool {
	if len(mmCarRepository.expectations) == 0 && mmCarRepository.defaultExpectation == nil && mmCarRepository.mock.funcCarRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCarRepository.mock.afterCarRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCarRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CarRepository implements mm_domain.TransactionalConnection
func (mmCarRepository *TransactionalConnectionMock) CarRepository() (c1 repositories.CarRepository) {
	mm_atomic.AddUint64(&mmCarRepository.beforeCarRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmCarRepository.afterCarRepositoryCounter, 1)

	mmCarRepository.t.Helper()

	if mmCarRepository.inspectFuncCarRepository != nil {
		mmCarRepository.inspectFuncCarRepository()
	}

	if mmCarRepository.CarRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCarRepository.CarRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmCarRepository.CarRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmCarRepository.t.Fatal("No results are set for the TransactionalConnectionMock.CarRepository")
		}
		return (*mm_results).c1
	}
	if mmCarRepository.funcCarRepository != nil {
		return mmCarRepository.funcCarRepository()
	}
	mmCarRepository.t.Fatalf("Unexpected call to TransactionalConnectionMock.CarRepository.")
	return
}

// CarRepositoryAfterCounter returns a count of finished TransactionalConnectionMock.CarRepository invocations
func (mmCarRepository *TransactionalConnectionMock) CarRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCarRepository.afterCarRepositoryCounter)
}

// CarRepositoryBeforeCounter returns a count of TransactionalConnectionMock.CarRepository invocations
func (mmCarRepository *TransactionalConnectionMock) CarRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCarRepository.beforeCarRepositoryCounter)
}

// MinimockCarRepositoryDone returns true if the count of the CarRepository invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockCarRepositoryDone() bool {
	if m.CarRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CarRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CarRepositoryMock.invocationsDone()
}

// MinimockCarRepositoryInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockCarRepositoryInspect() {
	for _, e := range m.CarRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.CarRepository")
		}
	}

	afterCarRepositoryCounter := mm_atomic.LoadUint64(&m.afterCarRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CarRepositoryMock.defaultExpectation != nil && afterCarRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.CarRepository at\n%s", m.CarRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCarRepository != nil && afterCarRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.CarRepository at\n%s", m.funcCarRepositoryOrigin)
	}

	if !m.CarRepositoryMock.invocationsDone() && afterCarRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.CarRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CarRepositoryMock.expectedInvocations), m.CarRepositoryMock.expectedInvocationsOrigin, afterCarRepositoryCounter)
	}
}

type mTransactionalConnectionMockCommit struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockCommitExpectation
	expectations       []*TransactionalConnectionMockCommitExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockCommitExpectation specifies expectation struct of the TransactionalConnection.Commit
type TransactionalConnectionMockCommitExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockCommitResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockCommitResults contains results of the TransactionalConnection.Commit
type TransactionalConnectionMockCommitResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommit *mTransactionalConnectionMockCommit) Optional() *mTransactionalConnectionMockCommit {
	mmCommit.optional = true
	return mmCommit
}

// Expect sets up expected params for TransactionalConnection.Commit
func (mmCommit *mTransactionalConnectionMockCommit) Expect() *mTransactionalConnectionMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TransactionalConnectionMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TransactionalConnectionMockCommitExpectation{}
	}

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.Commit
func (mmCommit *mTransactionalConnectionMockCommit) Inspect(f func()) *mTransactionalConnectionMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by TransactionalConnection.Commit
func (mmCommit *mTransactionalConnectionMockCommit) Return(err error) *TransactionalConnectionMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TransactionalConnectionMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TransactionalConnectionMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &TransactionalConnectionMockCommitResults{err}
	mmCommit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// Set uses given function f to mock the TransactionalConnection.Commit method
func (mmCommit *mTransactionalConnectionMockCommit) Set(f func() (err error)) *TransactionalConnectionMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.Commit method")
	}

	mmCommit.mock.funcCommit = f
	mmCommit.mock.funcCommitOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// Times sets number of times TransactionalConnection.Commit should be invoked
func (mmCommit *mTransactionalConnectionMockCommit) Times(n uint64) *mTransactionalConnectionMockCommit {
	if n == 0 {
		mmCommit.mock.t.Fatalf("Times of TransactionalConnectionMock.Commit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommit.expectedInvocations, n)
	mmCommit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommit
}

func (mmCommit *mTransactionalConnectionMockCommit) invocationsDone() bool {
	if len(mmCommit.expectations) == 0 && mmCommit.defaultExpectation == nil && mmCommit.mock.funcCommit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommit.mock.afterCommitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Commit implements mm_domain.TransactionalConnection
func (mmCommit *TransactionalConnectionMock) Commit() (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	mmCommit.t.Helper()

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit()
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the TransactionalConnectionMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit()
	}
	mmCommit.t.Fatalf("Unexpected call to TransactionalConnectionMock.Commit.")
	return
}

// CommitAfterCounter returns a count of finished TransactionalConnectionMock.Commit invocations
func (mmCommit *TransactionalConnectionMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of TransactionalConnectionMock.Commit invocations
func (mmCommit *TransactionalConnectionMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockCommitDone() bool {
	if m.CommitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitMock.invocationsDone()
}

// MinimockCommitInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.Commit")
		}
	}

	afterCommitCounter := mm_atomic.LoadUint64(&m.afterCommitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && afterCommitCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.Commit at\n%s", m.CommitMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && afterCommitCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.Commit at\n%s", m.funcCommitOrigin)
	}

	if !m.CommitMock.invocationsDone() && afterCommitCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.Commit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommitMock.expectedInvocations), m.CommitMock.expectedInvocationsOrigin, afterCommitCounter)
	}
}

type mTransactionalConnectionMockDB struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockDBExpectation
	expectations       []*TransactionalConnectionMockDBExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockDBExpectation specifies expectation struct of the TransactionalConnection.DB
type TransactionalConnectionMockDBExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockDBResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockDBResults contains results of the TransactionalConnection.DB
type TransactionalConnectionMockDBResults struct {
	dp1 *gorm.DB
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDB *mTransactionalConnectionMockDB) Optional() *mTransactionalConnectionMockDB {
	mmDB.optional = true
	return mmDB
}

// Expect sets up expected params for TransactionalConnection.DB
func (mmDB *mTransactionalConnectionMockDB) Expect() *mTransactionalConnectionMockDB {
	if mmDB.mock.funcDB != nil {
		mmDB.mock.t.Fatalf("TransactionalConnectionMock.DB mock is already set by Set")
	}

	if mmDB.defaultExpectation == nil {
		mmDB.defaultExpectation = &TransactionalConnectionMockDBExpectation{}
	}

	return mmDB
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.DB
func (mmDB *mTransactionalConnectionMockDB) Inspect(f func()) *mTransactionalConnectionMockDB {
	if mmDB.mock.inspectFuncDB != nil {
		mmDB.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.DB")
	}

	mmDB.mock.inspectFuncDB = f

	return mmDB
}

// Return sets up results that will be returned by TransactionalConnection.DB
func (mmDB *mTransactionalConnectionMockDB) Return(dp1 *gorm.DB) *TransactionalConnectionMock {
	if mmDB.mock.funcDB != nil {
		mmDB.mock.t.Fatalf("TransactionalConnectionMock.DB mock is already set by Set")
	}

	if mmDB.defaultExpectation == nil {
		mmDB.defaultExpectation = &TransactionalConnectionMockDBExpectation{mock: mmDB.mock}
	}
	mmDB.defaultExpectation.results = &TransactionalConnectionMockDBResults{dp1}
	mmDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDB.mock
}

// Set uses given function f to mock the TransactionalConnection.DB method
func (mmDB *mTransactionalConnectionMockDB) Set(f func() (dp1 *gorm.DB)) *TransactionalConnectionMock {
	if mmDB.defaultExpectation != nil {
		mmDB.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.DB method")
	}

	if len(mmDB.expectations) > 0 {
		mmDB.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.DB method")
	}

	mmDB.mock.funcDB = f
	mmDB.mock.funcDBOrigin = minimock.CallerInfo(1)
	return mmDB.mock
}

// Times sets number of times TransactionalConnection.DB should be invoked
func (mmDB *mTransactionalConnectionMockDB) Times(n uint64) *mTransactionalConnectionMockDB {
	if n == 0 {
		mmDB.mock.t.Fatalf("Times of TransactionalConnectionMock.DB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDB.expectedInvocations, n)
	mmDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDB
}

func (mmDB *mTransactionalConnectionMockDB) invocationsDone() bool {
	if len(mmDB.expectations) == 0 && mmDB.defaultExpectation == nil && mmDB.mock.funcDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDB.mock.afterDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DB implements mm_domain.TransactionalConnection
func (mmDB *TransactionalConnectionMock) DB() (dp1 *gorm.DB) {
	mm_atomic.AddUint64(&mmDB.beforeDBCounter, 1)
	defer mm_atomic.AddUint64(&mmDB.afterDBCounter, 1)

	mmDB.t.Helper()

	if mmDB.inspectFuncDB != nil {
		mmDB.inspectFuncDB()
	}

	if mmDB.DBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDB.DBMock.defaultExpectation.Counter, 1)

		mm_results := mmDB.DBMock.defaultExpectation.results
		if mm_results == nil {
			mmDB.t.Fatal("No results are set for the TransactionalConnectionMock.DB")
		}
		return (*mm_results).dp1
	}
	if mmDB.funcDB != nil {
		return mmDB.funcDB()
	}
	mmDB.t.Fatalf("Unexpected call to TransactionalConnectionMock.DB.")
	return
}

// DBAfterCounter returns a count of finished TransactionalConnectionMock.DB invocations
func (mmDB *TransactionalConnectionMock) DBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDB.afterDBCounter)
}

// DBBeforeCounter returns a count of TransactionalConnectionMock.DB invocations
func (mmDB *TransactionalConnectionMock) DBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDB.beforeDBCounter)
}

// MinimockDBDone returns true if the count of the DB invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockDBDone() bool {
	if m.DBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DBMock.invocationsDone()
}

// MinimockDBInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockDBInspect() {
	for _, e := range m.DBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.DB")
		}
	}

	afterDBCounter := mm_atomic.LoadUint64(&m.afterDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DBMock.defaultExpectation != nil && afterDBCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.DB at\n%s", m.DBMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDB != nil && afterDBCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.DB at\n%s", m.funcDBOrigin)
	}

	if !m.DBMock.invocationsDone() && afterDBCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.DB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DBMock.expectedInvocations), m.DBMock.expectedInvocationsOrigin, afterDBCounter)
	}
}

type mTransactionalConnectionMockParkingRepository struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockParkingRepositoryExpectation
	expectations       []*TransactionalConnectionMockParkingRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockParkingRepositoryExpectation specifies expectation struct of the TransactionalConnection.ParkingRepository
type TransactionalConnectionMockParkingRepositoryExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockParkingRepositoryResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockParkingRepositoryResults contains results of the TransactionalConnection.ParkingRepository
type TransactionalConnectionMockParkingRepositoryResults struct {
	p1 repositories.ParkingRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmParkingRepository *mTransactionalConnectionMockParkingRepository) Optional() *mTransactionalConnectionMockParkingRepository {
	mmParkingRepository.optional = true
	return mmParkingRepository
}

// Expect sets up expected params for TransactionalConnection.ParkingRepository
func (mmParkingRepository *mTransactionalConnectionMockParkingRepository) Expect() *mTransactionalConnectionMockParkingRepository {
	if mmParkingRepository.mock.funcParkingRepository != nil {
		mmParkingRepository.mock.t.Fatalf("TransactionalConnectionMock.ParkingRepository mock is already set by Set")
	}

	if mmParkingRepository.defaultExpectation == nil {
		mmParkingRepository.defaultExpectation = &TransactionalConnectionMockParkingRepositoryExpectation{}
	}

	return mmParkingRepository
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.ParkingRepository
func (mmParkingRepository *mTransactionalConnectionMockParkingRepository) Inspect(f func()) *mTransactionalConnectionMockParkingRepository {
	if mmParkingRepository.mock.inspectFuncParkingRepository != nil {
		mmParkingRepository.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.ParkingRepository")
	}

	mmParkingRepository.mock.inspectFuncParkingRepository = f

	return mmParkingRepository
}

// Return sets up results that will be returned by TransactionalConnection.ParkingRepository
func (mmParkingRepository *mTransactionalConnectionMockParkingRepository) Return(p1 repositories.ParkingRepository) *TransactionalConnectionMock {
	if mmParkingRepository.mock.funcParkingRepository != nil {
		mmParkingRepository.mock.t.Fatalf("TransactionalConnectionMock.ParkingRepository mock is already set by Set")
	}

	if mmParkingRepository.defaultExpectation == nil {
		mmParkingRepository.defaultExpectation = &TransactionalConnectionMockParkingRepositoryExpectation{mock: mmParkingRepository.mock}
	}
	mmParkingRepository.defaultExpectation.results = &TransactionalConnectionMockParkingRepositoryResults{p1}
	mmParkingRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmParkingRepository.mock
}

// Set uses given function f to mock the TransactionalConnection.ParkingRepository method
func (mmParkingRepository *mTransactionalConnectionMockParkingRepository) Set(f func() (p1 repositories.ParkingRepository)) *TransactionalConnectionMock {
	if mmParkingRepository.defaultExpectation != nil {
		mmParkingRepository.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.ParkingRepository method")
	}

	if len(mmParkingRepository.expectations) > 0 {
		mmParkingRepository.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.ParkingRepository method")
	}

	mmParkingRepository.mock.funcParkingRepository = f
	mmParkingRepository.mock.funcParkingRepositoryOrigin = minimock.CallerInfo(1)
	return mmParkingRepository.mock
}

// Times sets number of times TransactionalConnection.ParkingRepository should be invoked
func (mmParkingRepository *mTransactionalConnectionMockParkingRepository) Times(n uint64) *mTransactionalConnectionMockParkingRepository {
	if n == 0 {
		mmParkingRepository.mock.t.Fatalf("Times of TransactionalConnectionMock.ParkingRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmParkingRepository.expectedInvocations, n)
	mmParkingRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmParkingRepository
}

func (mmParkingRepository *mTransactionalConnectionMockParkingRepository) invocationsDone() bool {
	if len(mmParkingRepository.expectations) == 0 && mmParkingRepository.defaultExpectation == nil && mmParkingRepository.mock.funcParkingRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmParkingRepository.mock.afterParkingRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmParkingRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ParkingRepository implements mm_domain.TransactionalConnection
func (mmParkingRepository *TransactionalConnectionMock) ParkingRepository() (p1 repositories.ParkingRepository) {
	mm_atomic.AddUint64(&mmParkingRepository.beforeParkingRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmParkingRepository.afterParkingRepositoryCounter, 1)

	mmParkingRepository.t.Helper()

	if mmParkingRepository.inspectFuncParkingRepository != nil {
		mmParkingRepository.inspectFuncParkingRepository()
	}

	if mmParkingRepository.ParkingRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParkingRepository.ParkingRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmParkingRepository.ParkingRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmParkingRepository.t.Fatal("No results are set for the TransactionalConnectionMock.ParkingRepository")
		}
		return (*mm_results).p1
	}
	if mmParkingRepository.funcParkingRepository != nil {
		return mmParkingRepository.funcParkingRepository()
	}
	mmParkingRepository.t.Fatalf("Unexpected call to TransactionalConnectionMock.ParkingRepository.")
	return
}

// ParkingRepositoryAfterCounter returns a count of finished TransactionalConnectionMock.ParkingRepository invocations
func (mmParkingRepository *TransactionalConnectionMock) ParkingRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParkingRepository.afterParkingRepositoryCounter)
}

// ParkingRepositoryBeforeCounter returns a count of TransactionalConnectionMock.ParkingRepository invocations
func (mmParkingRepository *TransactionalConnectionMock) ParkingRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParkingRepository.beforeParkingRepositoryCounter)
}

// MinimockParkingRepositoryDone returns true if the count of the ParkingRepository invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockParkingRepositoryDone() bool {
	if m.ParkingRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ParkingRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ParkingRepositoryMock.invocationsDone()
}

// MinimockParkingRepositoryInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockParkingRepositoryInspect() {
	for _, e := range m.ParkingRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.ParkingRepository")
		}
	}

	afterParkingRepositoryCounter := mm_atomic.LoadUint64(&m.afterParkingRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ParkingRepositoryMock.defaultExpectation != nil && afterParkingRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.ParkingRepository at\n%s", m.ParkingRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParkingRepository != nil && afterParkingRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.ParkingRepository at\n%s", m.funcParkingRepositoryOrigin)
	}

	if !m.ParkingRepositoryMock.invocationsDone() && afterParkingRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.ParkingRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ParkingRepositoryMock.expectedInvocations), m.ParkingRepositoryMock.expectedInvocationsOrigin, afterParkingRepositoryCounter)
	}
}

type mTransactionalConnectionMockRollback struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockRollbackExpectation
	expectations       []*TransactionalConnectionMockRollbackExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockRollbackExpectation specifies expectation struct of the TransactionalConnection.Rollback
type TransactionalConnectionMockRollbackExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockRollbackResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockRollbackResults contains results of the TransactionalConnection.Rollback
type TransactionalConnectionMockRollbackResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRollback *mTransactionalConnectionMockRollback) Optional() *mTransactionalConnectionMockRollback {
	mmRollback.optional = true
	return mmRollback
}

// Expect sets up expected params for TransactionalConnection.Rollback
func (mmRollback *mTransactionalConnectionMockRollback) Expect() *mTransactionalConnectionMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TransactionalConnectionMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TransactionalConnectionMockRollbackExpectation{}
	}

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.Rollback
func (mmRollback *mTransactionalConnectionMockRollback) Inspect(f func()) *mTransactionalConnectionMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by TransactionalConnection.Rollback
func (mmRollback *mTransactionalConnectionMockRollback) Return(err error) *TransactionalConnectionMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TransactionalConnectionMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TransactionalConnectionMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &TransactionalConnectionMockRollbackResults{err}
	mmRollback.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRollback.mock
}

// Set uses given function f to mock the TransactionalConnection.Rollback method
func (mmRollback *mTransactionalConnectionMockRollback) Set(f func() (err error)) *TransactionalConnectionMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	mmRollback.mock.funcRollbackOrigin = minimock.CallerInfo(1)
	return mmRollback.mock
}

// Times sets number of times TransactionalConnection.Rollback should be invoked
func (mmRollback *mTransactionalConnectionMockRollback) Times(n uint64) *mTransactionalConnectionMockRollback {
	if n == 0 {
		mmRollback.mock.t.Fatalf("Times of TransactionalConnectionMock.Rollback mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRollback.expectedInvocations, n)
	mmRollback.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRollback
}

func (mmRollback *mTransactionalConnectionMockRollback) invocationsDone() bool {
	if len(mmRollback.expectations) == 0 && mmRollback.defaultExpectation == nil && mmRollback.mock.funcRollback == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRollback.mock.afterRollbackCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRollback.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Rollback implements mm_domain.TransactionalConnection
func (mmRollback *TransactionalConnectionMock) Rollback() (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	mmRollback.t.Helper()

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback()
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the TransactionalConnectionMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback()
	}
	mmRollback.t.Fatalf("Unexpected call to TransactionalConnectionMock.Rollback.")
	return
}

// RollbackAfterCounter returns a count of finished TransactionalConnectionMock.Rollback invocations
func (mmRollback *TransactionalConnectionMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of TransactionalConnectionMock.Rollback invocations
func (mmRollback *TransactionalConnectionMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockRollbackDone() bool {
	if m.RollbackMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RollbackMock.invocationsDone()
}

// MinimockRollbackInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.Rollback")
		}
	}

	afterRollbackCounter := mm_atomic.LoadUint64(&m.afterRollbackCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && afterRollbackCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.Rollback at\n%s", m.RollbackMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && afterRollbackCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.Rollback at\n%s", m.funcRollbackOrigin)
	}

	if !m.RollbackMock.invocationsDone() && afterRollbackCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.Rollback at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RollbackMock.expectedInvocations), m.RollbackMock.expectedInvocationsOrigin, afterRollbackCounter)
	}
}

type mTransactionalConnectionMockSessionRepository struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockSessionRepositoryExpectation
	expectations       []*TransactionalConnectionMockSessionRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockSessionRepositoryExpectation specifies expectation struct of the TransactionalConnection.SessionRepository
type TransactionalConnectionMockSessionRepositoryExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockSessionRepositoryResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockSessionRepositoryResults contains results of the TransactionalConnection.SessionRepository
type TransactionalConnectionMockSessionRepositoryResults struct {
	s1 repositories.SessionRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSessionRepository *mTransactionalConnectionMockSessionRepository) Optional() *mTransactionalConnectionMockSessionRepository {
	mmSessionRepository.optional = true
	return mmSessionRepository
}

// Expect sets up expected params for TransactionalConnection.SessionRepository
func (mmSessionRepository *mTransactionalConnectionMockSessionRepository) Expect() *mTransactionalConnectionMockSessionRepository {
	if mmSessionRepository.mock.funcSessionRepository != nil {
		mmSessionRepository.mock.t.Fatalf("TransactionalConnectionMock.SessionRepository mock is already set by Set")
	}

	if mmSessionRepository.defaultExpectation == nil {
		mmSessionRepository.defaultExpectation = &TransactionalConnectionMockSessionRepositoryExpectation{}
	}

	return mmSessionRepository
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.SessionRepository
func (mmSessionRepository *mTransactionalConnectionMockSessionRepository) Inspect(f func()) *mTransactionalConnectionMockSessionRepository {
	if mmSessionRepository.mock.inspectFuncSessionRepository != nil {
		mmSessionRepository.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.SessionRepository")
	}

	mmSessionRepository.mock.inspectFuncSessionRepository = f

	return mmSessionRepository
}

// Return sets up results that will be returned by TransactionalConnection.SessionRepository
func (mmSessionRepository *mTransactionalConnectionMockSessionRepository) Return(s1 repositories.SessionRepository) *TransactionalConnectionMock {
	if mmSessionRepository.mock.funcSessionRepository != nil {
		mmSessionRepository.mock.t.Fatalf("TransactionalConnectionMock.SessionRepository mock is already set by Set")
	}

	if mmSessionRepository.defaultExpectation == nil {
		mmSessionRepository.defaultExpectation = &TransactionalConnectionMockSessionRepositoryExpectation{mock: mmSessionRepository.mock}
	}
	mmSessionRepository.defaultExpectation.results = &TransactionalConnectionMockSessionRepositoryResults{s1}
	mmSessionRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSessionRepository.mock
}

// Set uses given function f to mock the TransactionalConnection.SessionRepository method
func (mmSessionRepository *mTransactionalConnectionMockSessionRepository) Set(f func() (s1 repositories.SessionRepository)) *TransactionalConnectionMock {
	if mmSessionRepository.defaultExpectation != nil {
		mmSessionRepository.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.SessionRepository method")
	}

	if len(mmSessionRepository.expectations) > 0 {
		mmSessionRepository.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.SessionRepository method")
	}

	mmSessionRepository.mock.funcSessionRepository = f
	mmSessionRepository.mock.funcSessionRepositoryOrigin = minimock.CallerInfo(1)
	return mmSessionRepository.mock
}

// Times sets number of times TransactionalConnection.SessionRepository should be invoked
func (mmSessionRepository *mTransactionalConnectionMockSessionRepository) Times(n uint64) *mTransactionalConnectionMockSessionRepository {
	if n == 0 {
		mmSessionRepository.mock.t.Fatalf("Times of TransactionalConnectionMock.SessionRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSessionRepository.expectedInvocations, n)
	mmSessionRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSessionRepository
}

func (mmSessionRepository *mTransactionalConnectionMockSessionRepository) invocationsDone() bool {
	if len(mmSessionRepository.expectations) == 0 && mmSessionRepository.defaultExpectation == nil && mmSessionRepository.mock.funcSessionRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSessionRepository.mock.afterSessionRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSessionRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SessionRepository implements mm_domain.TransactionalConnection
func (mmSessionRepository *TransactionalConnectionMock) SessionRepository() (s1 repositories.SessionRepository) {
	mm_atomic.AddUint64(&mmSessionRepository.beforeSessionRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmSessionRepository.afterSessionRepositoryCounter, 1)

	mmSessionRepository.t.Helper()

	if mmSessionRepository.inspectFuncSessionRepository != nil {
		mmSessionRepository.inspectFuncSessionRepository()
	}

	if mmSessionRepository.SessionRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSessionRepository.SessionRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmSessionRepository.SessionRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmSessionRepository.t.Fatal("No results are set for the TransactionalConnectionMock.SessionRepository")
		}
		return (*mm_results).s1
	}
	if mmSessionRepository.funcSessionRepository != nil {
		return mmSessionRepository.funcSessionRepository()
	}
	mmSessionRepository.t.Fatalf("Unexpected call to TransactionalConnectionMock.SessionRepository.")
	return
}

// SessionRepositoryAfterCounter returns a count of finished TransactionalConnectionMock.SessionRepository invocations
func (mmSessionRepository *TransactionalConnectionMock) SessionRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSessionRepository.afterSessionRepositoryCounter)
}

// SessionRepositoryBeforeCounter returns a count of TransactionalConnectionMock.SessionRepository invocations
func (mmSessionRepository *TransactionalConnectionMock) SessionRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSessionRepository.beforeSessionRepositoryCounter)
}

// MinimockSessionRepositoryDone returns true if the count of the SessionRepository invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockSessionRepositoryDone() bool {
	if m.SessionRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SessionRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SessionRepositoryMock.invocationsDone()
}

// MinimockSessionRepositoryInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockSessionRepositoryInspect() {
	for _, e := range m.SessionRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.SessionRepository")
		}
	}

	afterSessionRepositoryCounter := mm_atomic.LoadUint64(&m.afterSessionRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SessionRepositoryMock.defaultExpectation != nil && afterSessionRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.SessionRepository at\n%s", m.SessionRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSessionRepository != nil && afterSessionRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.SessionRepository at\n%s", m.funcSessionRepositoryOrigin)
	}

	if !m.SessionRepositoryMock.invocationsDone() && afterSessionRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.SessionRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SessionRepositoryMock.expectedInvocations), m.SessionRepositoryMock.expectedInvocationsOrigin, afterSessionRepositoryCounter)
	}
}

type mTransactionalConnectionMockTariffRepository struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockTariffRepositoryExpectation
	expectations       []*TransactionalConnectionMockTariffRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockTariffRepositoryExpectation specifies expectation struct of the TransactionalConnection.TariffRepository
type TransactionalConnectionMockTariffRepositoryExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockTariffRepositoryResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockTariffRepositoryResults contains results of the TransactionalConnection.TariffRepository
type TransactionalConnectionMockTariffRepositoryResults struct {
	t1 repositories.TariffRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTariffRepository *mTransactionalConnectionMockTariffRepository) Optional() *mTransactionalConnectionMockTariffRepository {
	mmTariffRepository.optional = true
	return mmTariffRepository
}

// Expect sets up expected params for TransactionalConnection.TariffRepository
func (mmTariffRepository *mTransactionalConnectionMockTariffRepository) Expect() *mTransactionalConnectionMockTariffRepository {
	if mmTariffRepository.mock.funcTariffRepository != nil {
		mmTariffRepository.mock.t.Fatalf("TransactionalConnectionMock.TariffRepository mock is already set by Set")
	}

	if mmTariffRepository.defaultExpectation == nil {
		mmTariffRepository.defaultExpectation = &TransactionalConnectionMockTariffRepositoryExpectation{}
	}

	return mmTariffRepository
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.TariffRepository
func (mmTariffRepository *mTransactionalConnectionMockTariffRepository) Inspect(f func()) *mTransactionalConnectionMockTariffRepository {
	if mmTariffRepository.mock.inspectFuncTariffRepository != nil {
		mmTariffRepository.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.TariffRepository")
	}

	mmTariffRepository.mock.inspectFuncTariffRepository = f

	return mmTariffRepository
}

// Return sets up results that will be returned by TransactionalConnection.TariffRepository
func (mmTariffRepository *mTransactionalConnectionMockTariffRepository) Return(t1 repositories.TariffRepository) *TransactionalConnectionMock {
	if mmTariffRepository.mock.funcTariffRepository != nil {
		mmTariffRepository.mock.t.Fatalf("TransactionalConnectionMock.TariffRepository mock is already set by Set")
	}

	if mmTariffRepository.defaultExpectation == nil {
		mmTariffRepository.defaultExpectation = &TransactionalConnectionMockTariffRepositoryExpectation{mock: mmTariffRepository.mock}
	}
	mmTariffRepository.defaultExpectation.results = &TransactionalConnectionMockTariffRepositoryResults{t1}
	mmTariffRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTariffRepository.mock
}

// Set uses given function f to mock the TransactionalConnection.TariffRepository method
func (mmTariffRepository *mTransactionalConnectionMockTariffRepository) Set(f func() (t1 repositories.TariffRepository)) *TransactionalConnectionMock {
	if mmTariffRepository.defaultExpectation != nil {
		mmTariffRepository.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.TariffRepository method")
	}

	if len(mmTariffRepository.expectations) > 0 {
		mmTariffRepository.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.TariffRepository method")
	}

	mmTariffRepository.mock.funcTariffRepository = f
	mmTariffRepository.mock.funcTariffRepositoryOrigin = minimock.CallerInfo(1)
	return mmTariffRepository.mock
}

// Times sets number of times TransactionalConnection.TariffRepository should be invoked
func (mmTariffRepository *mTransactionalConnectionMockTariffRepository) Times(n uint64) *mTransactionalConnectionMockTariffRepository {
	if n == 0 {
		mmTariffRepository.mock.t.Fatalf("Times of TransactionalConnectionMock.TariffRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTariffRepository.expectedInvocations, n)
	mmTariffRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTariffRepository
}

func (mmTariffRepository *mTransactionalConnectionMockTariffRepository) invocationsDone() bool {
	if len(mmTariffRepository.expectations) == 0 && mmTariffRepository.defaultExpectation == nil && mmTariffRepository.mock.funcTariffRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTariffRepository.mock.afterTariffRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTariffRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TariffRepository implements mm_domain.TransactionalConnection
func (mmTariffRepository *TransactionalConnectionMock) TariffRepository() (t1 repositories.TariffRepository) {
	mm_atomic.AddUint64(&mmTariffRepository.beforeTariffRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmTariffRepository.afterTariffRepositoryCounter, 1)

	mmTariffRepository.t.Helper()

	if mmTariffRepository.inspectFuncTariffRepository != nil {
		mmTariffRepository.inspectFuncTariffRepository()
	}

	if mmTariffRepository.TariffRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTariffRepository.TariffRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmTariffRepository.TariffRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmTariffRepository.t.Fatal("No results are set for the TransactionalConnectionMock.TariffRepository")
		}
		return (*mm_results).t1
	}
	if mmTariffRepository.funcTariffRepository != nil {
		return mmTariffRepository.funcTariffRepository()
	}
	mmTariffRepository.t.Fatalf("Unexpected call to TransactionalConnectionMock.TariffRepository.")
	return
}

// TariffRepositoryAfterCounter returns a count of finished TransactionalConnectionMock.TariffRepository invocations
func (mmTariffRepository *TransactionalConnectionMock) TariffRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTariffRepository.afterTariffRepositoryCounter)
}

// TariffRepositoryBeforeCounter returns a count of TransactionalConnectionMock.TariffRepository invocations
func (mmTariffRepository *TransactionalConnectionMock) TariffRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTariffRepository.beforeTariffRepositoryCounter)
}

// MinimockTariffRepositoryDone returns true if the count of the TariffRepository invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockTariffRepositoryDone() bool {
	if m.TariffRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TariffRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TariffRepositoryMock.invocationsDone()
}

// MinimockTariffRepositoryInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockTariffRepositoryInspect() {
	for _, e := range m.TariffRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.TariffRepository")
		}
	}

	afterTariffRepositoryCounter := mm_atomic.LoadUint64(&m.afterTariffRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TariffRepositoryMock.defaultExpectation != nil && afterTariffRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.TariffRepository at\n%s", m.TariffRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTariffRepository != nil && afterTariffRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.TariffRepository at\n%s", m.funcTariffRepositoryOrigin)
	}

	if !m.TariffRepositoryMock.invocationsDone() && afterTariffRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.TariffRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TariffRepositoryMock.expectedInvocations), m.TariffRepositoryMock.expectedInvocationsOrigin, afterTariffRepositoryCounter)
	}
}

type mTransactionalConnectionMockUnitRepository struct {
	optional           bool
	mock               *TransactionalConnectionMock
	defaultExpectation *TransactionalConnectionMockUnitRepositoryExpectation
	expectations       []*TransactionalConnectionMockUnitRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionalConnectionMockUnitRepositoryExpectation specifies expectation struct of the TransactionalConnection.UnitRepository
type TransactionalConnectionMockUnitRepositoryExpectation struct {
	mock *TransactionalConnectionMock

	results      *TransactionalConnectionMockUnitRepositoryResults
	returnOrigin string
	Counter      uint64
}

// TransactionalConnectionMockUnitRepositoryResults contains results of the TransactionalConnection.UnitRepository
type TransactionalConnectionMockUnitRepositoryResults struct {
	u1 repositories.UnitRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUnitRepository *mTransactionalConnectionMockUnitRepository) Optional() *mTransactionalConnectionMockUnitRepository {
	mmUnitRepository.optional = true
	return mmUnitRepository
}

// Expect sets up expected params for TransactionalConnection.UnitRepository
func (mmUnitRepository *mTransactionalConnectionMockUnitRepository) Expect() *mTransactionalConnectionMockUnitRepository {
	if mmUnitRepository.mock.funcUnitRepository != nil {
		mmUnitRepository.mock.t.Fatalf("TransactionalConnectionMock.UnitRepository mock is already set by Set")
	}

	if mmUnitRepository.defaultExpectation == nil {
		mmUnitRepository.defaultExpectation = &TransactionalConnectionMockUnitRepositoryExpectation{}
	}

	return mmUnitRepository
}

// Inspect accepts an inspector function that has same arguments as the TransactionalConnection.UnitRepository
func (mmUnitRepository *mTransactionalConnectionMockUnitRepository) Inspect(f func()) *mTransactionalConnectionMockUnitRepository {
	if mmUnitRepository.mock.inspectFuncUnitRepository != nil {
		mmUnitRepository.mock.t.Fatalf("Inspect function is already set for TransactionalConnectionMock.UnitRepository")
	}

	mmUnitRepository.mock.inspectFuncUnitRepository = f

	return mmUnitRepository
}

// Return sets up results that will be returned by TransactionalConnection.UnitRepository
func (mmUnitRepository *mTransactionalConnectionMockUnitRepository) Return(u1 repositories.UnitRepository) *TransactionalConnectionMock {
	if mmUnitRepository.mock.funcUnitRepository != nil {
		mmUnitRepository.mock.t.Fatalf("TransactionalConnectionMock.UnitRepository mock is already set by Set")
	}

	if mmUnitRepository.defaultExpectation == nil {
		mmUnitRepository.defaultExpectation = &TransactionalConnectionMockUnitRepositoryExpectation{mock: mmUnitRepository.mock}
	}
	mmUnitRepository.defaultExpectation.results = &TransactionalConnectionMockUnitRepositoryResults{u1}
	mmUnitRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUnitRepository.mock
}

// Set uses given function f to mock the TransactionalConnection.UnitRepository method
func (mmUnitRepository *mTransactionalConnectionMockUnitRepository) Set(f func() (u1 repositories.UnitRepository)) *TransactionalConnectionMock {
	if mmUnitRepository.defaultExpectation != nil {
		mmUnitRepository.mock.t.Fatalf("Default expectation is already set for the TransactionalConnection.UnitRepository method")
	}

	if len(mmUnitRepository.expectations) > 0 {
		mmUnitRepository.mock.t.Fatalf("Some expectations are already set for the TransactionalConnection.UnitRepository method")
	}

	mmUnitRepository.mock.funcUnitRepository = f
	mmUnitRepository.mock.funcUnitRepositoryOrigin = minimock.CallerInfo(1)
	return mmUnitRepository.mock
}

// Times sets number of times TransactionalConnection.UnitRepository should be invoked
func (mmUnitRepository *mTransactionalConnectionMockUnitRepository) Times(n uint64) *mTransactionalConnectionMockUnitRepository {
	if n == 0 {
		mmUnitRepository.mock.t.Fatalf("Times of TransactionalConnectionMock.UnitRepository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUnitRepository.expectedInvocations, n)
	mmUnitRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUnitRepository
}

func (mmUnitRepository *mTransactionalConnectionMockUnitRepository) invocationsDone() bool {
	if len(mmUnitRepository.expectations) == 0 && mmUnitRepository.defaultExpectation == nil && mmUnitRepository.mock.funcUnitRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUnitRepository.mock.afterUnitRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUnitRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UnitRepository implements mm_domain.TransactionalConnection
func (mmUnitRepository *TransactionalConnectionMock) UnitRepository() (u1 repositories.UnitRepository) {
	mm_atomic.AddUint64(&mmUnitRepository.beforeUnitRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmUnitRepository.afterUnitRepositoryCounter, 1)

	mmUnitRepository.t.Helper()

	if mmUnitRepository.inspectFuncUnitRepository != nil {
		mmUnitRepository.inspectFuncUnitRepository()
	}

	if mmUnitRepository.UnitRepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnitRepository.UnitRepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmUnitRepository.UnitRepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmUnitRepository.t.Fatal("No results are set for the TransactionalConnectionMock.UnitRepository")
		}
		return (*mm_results).u1
	}
	if mmUnitRepository.funcUnitRepository != nil {
		return mmUnitRepository.funcUnitRepository()
	}
	mmUnitRepository.t.Fatalf("Unexpected call to TransactionalConnectionMock.UnitRepository.")
	return
}

// UnitRepositoryAfterCounter returns a count of finished TransactionalConnectionMock.UnitRepository invocations
func (mmUnitRepository *TransactionalConnectionMock) UnitRepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnitRepository.afterUnitRepositoryCounter)
}

// UnitRepositoryBeforeCounter returns a count of TransactionalConnectionMock.UnitRepository invocations
func (mmUnitRepository *TransactionalConnectionMock) UnitRepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnitRepository.beforeUnitRepositoryCounter)
}

// MinimockUnitRepositoryDone returns true if the count of the UnitRepository invocations corresponds
// the number of defined expectations
func (m *TransactionalConnectionMock) MinimockUnitRepositoryDone() bool {
	if m.UnitRepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UnitRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UnitRepositoryMock.invocationsDone()
}

// MinimockUnitRepositoryInspect logs each unmet expectation
func (m *TransactionalConnectionMock) MinimockUnitRepositoryInspect() {
	for _, e := range m.UnitRepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransactionalConnectionMock.UnitRepository")
		}
	}

	afterUnitRepositoryCounter := mm_atomic.LoadUint64(&m.afterUnitRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UnitRepositoryMock.defaultExpectation != nil && afterUnitRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.UnitRepository at\n%s", m.UnitRepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnitRepository != nil && afterUnitRepositoryCounter < 1 {
		m.t.Errorf("Expected call to TransactionalConnectionMock.UnitRepository at\n%s", m.funcUnitRepositoryOrigin)
	}

	if !m.UnitRepositoryMock.invocationsDone() && afterUnitRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionalConnectionMock.UnitRepository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UnitRepositoryMock.expectedInvocations), m.UnitRepositoryMock.expectedInvocationsOrigin, afterUnitRepositoryCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionalConnectionMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginInspect()

			m.MinimockCarRepositoryInspect()

			m.MinimockCommitInspect()

			m.MinimockDBInspect()

			m.MinimockParkingRepositoryInspect()

			m.MinimockRollbackInspect()

			m.MinimockSessionRepositoryInspect()

			m.MinimockTariffRepositoryInspect()

			m.MinimockUnitRepositoryInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionalConnectionMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionalConnectionMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockCarRepositoryDone() &&
		m.MinimockCommitDone() &&
		m.MinimockDBDone() &&
		m.MinimockParkingRepositoryDone() &&
		m.MinimockRollbackDone() &&
		m.MinimockSessionRepositoryDone() &&
		m.MinimockTariffRepositoryDone() &&
		m.MinimockUnitRepositoryDone()
}
