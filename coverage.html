
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">k071123/internal/services/parking_service/cmd/main.go (0.0%)</option>
				
				<option value="file1">k071123/internal/services/parking_service/contracts/pkg/proto/parking_service.pb.go (0.0%)</option>
				
				<option value="file2">k071123/internal/services/parking_service/contracts/pkg/proto/parking_service_grpc.pb.go (0.0%)</option>
				
				<option value="file3">k071123/internal/services/parking_service/core/context.go (0.0%)</option>
				
				<option value="file4">k071123/internal/services/parking_service/core/di.go (0.0%)</option>
				
				<option value="file5">k071123/internal/services/parking_service/core/gprc_notification_client.go (0.0%)</option>
				
				<option value="file6">k071123/internal/services/parking_service/core/grpc_order_client.go (0.0%)</option>
				
				<option value="file7">k071123/internal/services/parking_service/core/grpc_server.go (0.0%)</option>
				
				<option value="file8">k071123/internal/services/parking_service/core/grpc_user_client.go (0.0%)</option>
				
				<option value="file9">k071123/internal/services/parking_service/core/server.go (0.0%)</option>
				
				<option value="file10">k071123/internal/services/parking_service/delivery/grpc/handlers.go (0.0%)</option>
				
				<option value="file11">k071123/internal/services/parking_service/delivery/http/parking.go (0.0%)</option>
				
				<option value="file12">k071123/internal/services/parking_service/delivery/http/routers.go (0.0%)</option>
				
				<option value="file13">k071123/internal/services/parking_service/delivery/http/session.go (0.0%)</option>
				
				<option value="file14">k071123/internal/services/parking_service/delivery/http/tariff.go (0.0%)</option>
				
				<option value="file15">k071123/internal/services/parking_service/delivery/http/unit.go (0.0%)</option>
				
				<option value="file16">k071123/internal/services/parking_service/domain/cases/car/case.go (83.3%)</option>
				
				<option value="file17">k071123/internal/services/parking_service/domain/cases/parking/case.go (0.0%)</option>
				
				<option value="file18">k071123/internal/services/parking_service/domain/cases/parking/helpers.go (0.0%)</option>
				
				<option value="file19">k071123/internal/services/parking_service/domain/cases/session/case.go (0.0%)</option>
				
				<option value="file20">k071123/internal/services/parking_service/domain/cases/tariff/case.go (0.0%)</option>
				
				<option value="file21">k071123/internal/services/parking_service/domain/cases/unit/case.go (0.0%)</option>
				
				<option value="file22">k071123/internal/services/parking_service/domain/mocks/connection_mock.go (13.4%)</option>
				
				<option value="file23">k071123/internal/services/parking_service/domain/mocks/context_mock.go (27.0%)</option>
				
				<option value="file24">k071123/internal/services/parking_service/domain/mocks/services_mock.go (24.4%)</option>
				
				<option value="file25">k071123/internal/services/parking_service/domain/models/parking.go (0.0%)</option>
				
				<option value="file26">k071123/internal/services/parking_service/domain/models/parking_schedule.go (0.0%)</option>
				
				<option value="file27">k071123/internal/services/parking_service/domain/props/create_car.go (100.0%)</option>
				
				<option value="file28">k071123/internal/services/parking_service/domain/props/create_parking.go (0.0%)</option>
				
				<option value="file29">k071123/internal/services/parking_service/domain/props/create_unit.go (0.0%)</option>
				
				<option value="file30">k071123/internal/services/parking_service/services/config/config.go (0.0%)</option>
				
				<option value="file31">k071123/internal/services/parking_service/storage/repositories/car.go (0.0%)</option>
				
				<option value="file32">k071123/internal/services/parking_service/storage/repositories/connection.go (0.0%)</option>
				
				<option value="file33">k071123/internal/services/parking_service/storage/repositories/parking.go (0.0%)</option>
				
				<option value="file34">k071123/internal/services/parking_service/storage/repositories/session.go (0.0%)</option>
				
				<option value="file35">k071123/internal/services/parking_service/storage/repositories/tariff.go (0.0%)</option>
				
				<option value="file36">k071123/internal/services/parking_service/storage/repositories/unit.go (0.0%)</option>
				
				<option value="file37">k071123/internal/services/parking_service/storage/sqlc/db.go (0.0%)</option>
				
				<option value="file38">k071123/internal/services/parking_service/storage/sqlc/query.sql.go (0.0%)</option>
				
				<option value="file39">k071123/internal/services/parking_service/tests/mocks/car_repository_mock.go (15.3%)</option>
				
				<option value="file40">k071123/internal/services/parking_service/tests/mocks/parking_repository_mock.go (0.0%)</option>
				
				<option value="file41">k071123/internal/services/parking_service/tests/mocks/session_repository_mock.go (0.0%)</option>
				
				<option value="file42">k071123/internal/services/parking_service/tests/mocks/unit_repository_mock.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "k071123/internal/services/parking_service/core"
        "k071123/internal/services/parking_service/delivery/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"
)

// @title Parking Service API
// @version 2.0
// @description API для работы с доменом Parking
// @host localhost:7802
// @BasePath /
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description "Enter your Bearer token in the format: `Bearer {token}`"
func main() <span class="cov0" title="0">{
        var wg sync.WaitGroup

        di := core.NewDi()
        server := core.NewHttpServer()
        grpcServer := core.NewGrpcServer()

        _, cancel := context.WithCancel(context.Background())
        defer cancel()

        log := di.Ctx.Services().Logger()

        handlers := &amp;http.Handlers{
                ParkingHandler: di.ParkingHandler,
                TariffHandler:  di.TariffHandler,
                SessionHandler: di.SessionHandler,
                UnitHandler:    di.UnitHandler,
        }

        http.SetupRoutes(server.App(), handlers)
        wg.Add(2)
        go func() </span><span class="cov0" title="0">{
                server.Start()
                defer wg.Done()
                log.Info("http server started...")
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                grpcServer.Start()
                defer wg.Done()
                log.Info("grpc server started...")
        }</span>()

        <span class="cov0" title="0">sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
        &lt;-sigs

        log.Infoln("Shutting down parking service...")
        cancel()
        time.Sleep(time.Second)

        wg.Wait()
        log.Infoln("Parking service stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.10
//         protoc        v3.21.12
// source: parking_service.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateCarReq struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        GosNumber     string                 `protobuf:"bytes,1,opt,name=GosNumber,proto3" json:"GosNumber,omitempty"`
        UserUUID      string                 `protobuf:"bytes,2,opt,name=UserUUID,proto3" json:"UserUUID,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateCarReq) Reset() <span class="cov0" title="0">{
        *x = CreateCarReq{}
        mi := &amp;file_parking_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateCarReq) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateCarReq) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateCarReq) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_parking_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateCarReq.ProtoReflect.Descriptor instead.
func (*CreateCarReq) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_parking_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateCarReq) GetGosNumber() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GosNumber
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateCarReq) GetUserUUID() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserUUID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateCarResp struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Car           *Car                   `protobuf:"bytes,1,opt,name=Car,proto3" json:"Car,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateCarResp) Reset() <span class="cov0" title="0">{
        *x = CreateCarResp{}
        mi := &amp;file_parking_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateCarResp) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateCarResp) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateCarResp) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_parking_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateCarResp.ProtoReflect.Descriptor instead.
func (*CreateCarResp) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_parking_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateCarResp) GetCar() *Car <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Car
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Car struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UUID          string                 `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
        UserUUID      string                 `protobuf:"bytes,2,opt,name=UserUUID,proto3" json:"UserUUID,omitempty"`
        GosNumber     string                 `protobuf:"bytes,3,opt,name=GosNumber,proto3" json:"GosNumber,omitempty"`
        IsActive      bool                   `protobuf:"varint,4,opt,name=IsActive,proto3" json:"IsActive,omitempty"`
        Settings      *CarSetting            `protobuf:"bytes,5,opt,name=Settings,proto3" json:"Settings,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Car) Reset() <span class="cov0" title="0">{
        *x = Car{}
        mi := &amp;file_parking_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Car) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Car) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Car) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_parking_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Car.ProtoReflect.Descriptor instead.
func (*Car) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_parking_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Car) GetUUID() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UUID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Car) GetUserUUID() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserUUID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Car) GetGosNumber() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GosNumber
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Car) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Car) GetSettings() *CarSetting <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Settings
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CarSetting struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UUID          string                 `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
        CarUUID       string                 `protobuf:"bytes,2,opt,name=CarUUID,proto3" json:"CarUUID,omitempty"`
        Vin           string                 `protobuf:"bytes,3,opt,name=Vin,proto3" json:"Vin,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CarSetting) Reset() <span class="cov0" title="0">{
        *x = CarSetting{}
        mi := &amp;file_parking_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CarSetting) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CarSetting) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CarSetting) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_parking_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CarSetting.ProtoReflect.Descriptor instead.
func (*CarSetting) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_parking_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *CarSetting) GetUUID() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UUID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CarSetting) GetCarUUID() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CarUUID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CarSetting) GetVin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Vin
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateSessionPaidRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        SessionUuid   string                 `protobuf:"bytes,1,opt,name=session_uuid,json=sessionUuid,proto3" json:"session_uuid,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateSessionPaidRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateSessionPaidRequest{}
        mi := &amp;file_parking_service_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateSessionPaidRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateSessionPaidRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateSessionPaidRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_parking_service_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateSessionPaidRequest.ProtoReflect.Descriptor instead.
func (*UpdateSessionPaidRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_parking_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *UpdateSessionPaidRequest) GetSessionUuid() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionUuid
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateSessionPaidResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateSessionPaidResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateSessionPaidResponse{}
        mi := &amp;file_parking_service_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateSessionPaidResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateSessionPaidResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateSessionPaidResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_parking_service_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateSessionPaidResponse.ProtoReflect.Descriptor instead.
func (*UpdateSessionPaidResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_parking_service_proto_rawDescGZIP(), []int{5}
}</span>

var File_parking_service_proto protoreflect.FileDescriptor

const file_parking_service_proto_rawDesc = "" +
        "\n" +
        "\x15parking_service.proto\x12\aparking\"H\n" +
        "\fCreateCarReq\x12\x1c\n" +
        "\tGosNumber\x18\x01 \x01(\tR\tGosNumber\x12\x1a\n" +
        "\bUserUUID\x18\x02 \x01(\tR\bUserUUID\"/\n" +
        "\rCreateCarResp\x12\x1e\n" +
        "\x03Car\x18\x01 \x01(\v2\f.parking.CarR\x03Car\"\xa0\x01\n" +
        "\x03Car\x12\x12\n" +
        "\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x1a\n" +
        "\bUserUUID\x18\x02 \x01(\tR\bUserUUID\x12\x1c\n" +
        "\tGosNumber\x18\x03 \x01(\tR\tGosNumber\x12\x1a\n" +
        "\bIsActive\x18\x04 \x01(\bR\bIsActive\x12/\n" +
        "\bSettings\x18\x05 \x01(\v2\x13.parking.CarSettingR\bSettings\"L\n" +
        "\n" +
        "CarSetting\x12\x12\n" +
        "\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x18\n" +
        "\aCarUUID\x18\x02 \x01(\tR\aCarUUID\x12\x10\n" +
        "\x03Vin\x18\x03 \x01(\tR\x03Vin\"=\n" +
        "\x18UpdateSessionPaidRequest\x12!\n" +
        "\fsession_uuid\x18\x01 \x01(\tR\vsessionUuid\"\x1b\n" +
        "\x19UpdateSessionPaidResponse2\xa1\x01\n" +
        "\aParking\x12:\n" +
        "\tCreateCar\x12\x15.parking.CreateCarReq\x1a\x16.parking.CreateCarResp\x12Z\n" +
        "\x11UpdateSessionPaid\x12!.parking.UpdateSessionPaidRequest\x1a\".parking.UpdateSessionPaidResponseB\x15Z\x13contracts/pkg/protob\x06proto3"

var (
        file_parking_service_proto_rawDescOnce sync.Once
        file_parking_service_proto_rawDescData []byte
)

func file_parking_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_parking_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_parking_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_parking_service_proto_rawDesc), len(file_parking_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_parking_service_proto_rawDescData</span>
}

var file_parking_service_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_parking_service_proto_goTypes = []any{
        (*CreateCarReq)(nil),              // 0: parking.CreateCarReq
        (*CreateCarResp)(nil),             // 1: parking.CreateCarResp
        (*Car)(nil),                       // 2: parking.Car
        (*CarSetting)(nil),                // 3: parking.CarSetting
        (*UpdateSessionPaidRequest)(nil),  // 4: parking.UpdateSessionPaidRequest
        (*UpdateSessionPaidResponse)(nil), // 5: parking.UpdateSessionPaidResponse
}
var file_parking_service_proto_depIdxs = []int32{
        2, // 0: parking.CreateCarResp.Car:type_name -&gt; parking.Car
        3, // 1: parking.Car.Settings:type_name -&gt; parking.CarSetting
        0, // 2: parking.Parking.CreateCar:input_type -&gt; parking.CreateCarReq
        4, // 3: parking.Parking.UpdateSessionPaid:input_type -&gt; parking.UpdateSessionPaidRequest
        1, // 4: parking.Parking.CreateCar:output_type -&gt; parking.CreateCarResp
        5, // 5: parking.Parking.UpdateSessionPaid:output_type -&gt; parking.UpdateSessionPaidResponse
        4, // [4:6] is the sub-list for method output_type
        2, // [2:4] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_parking_service_proto_init() }</span>
func file_parking_service_proto_init() <span class="cov0" title="0">{
        if File_parking_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_parking_service_proto_rawDesc), len(file_parking_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_parking_service_proto_goTypes,
                DependencyIndexes: file_parking_service_proto_depIdxs,
                MessageInfos:      file_parking_service_proto_msgTypes,
        }.Build()
        File_parking_service_proto = out.File
        file_parking_service_proto_goTypes = nil
        file_parking_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: parking_service.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ParkingClient is the client API for Parking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ParkingClient interface {
        CreateCar(ctx context.Context, in *CreateCarReq, opts ...grpc.CallOption) (*CreateCarResp, error)
        UpdateSessionPaid(ctx context.Context, in *UpdateSessionPaidRequest, opts ...grpc.CallOption) (*UpdateSessionPaidResponse, error)
}

type parkingClient struct {
        cc grpc.ClientConnInterface
}

func NewParkingClient(cc grpc.ClientConnInterface) ParkingClient <span class="cov0" title="0">{
        return &amp;parkingClient{cc}
}</span>

func (c *parkingClient) CreateCar(ctx context.Context, in *CreateCarReq, opts ...grpc.CallOption) (*CreateCarResp, error) <span class="cov0" title="0">{
        out := new(CreateCarResp)
        err := c.cc.Invoke(ctx, "/parking.Parking/CreateCar", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *parkingClient) UpdateSessionPaid(ctx context.Context, in *UpdateSessionPaidRequest, opts ...grpc.CallOption) (*UpdateSessionPaidResponse, error) <span class="cov0" title="0">{
        out := new(UpdateSessionPaidResponse)
        err := c.cc.Invoke(ctx, "/parking.Parking/UpdateSessionPaid", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ParkingServer is the server API for Parking service.
// All implementations must embed UnimplementedParkingServer
// for forward compatibility
type ParkingServer interface {
        CreateCar(context.Context, *CreateCarReq) (*CreateCarResp, error)
        UpdateSessionPaid(context.Context, *UpdateSessionPaidRequest) (*UpdateSessionPaidResponse, error)
        mustEmbedUnimplementedParkingServer()
}

// UnimplementedParkingServer must be embedded to have forward compatible implementations.
type UnimplementedParkingServer struct {
}

func (UnimplementedParkingServer) CreateCar(context.Context, *CreateCarReq) (*CreateCarResp, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateCar not implemented")
}</span>
func (UnimplementedParkingServer) UpdateSessionPaid(context.Context, *UpdateSessionPaidRequest) (*UpdateSessionPaidResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateSessionPaid not implemented")
}</span>
func (UnimplementedParkingServer) mustEmbedUnimplementedParkingServer() {<span class="cov0" title="0">}</span>

// UnsafeParkingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ParkingServer will
// result in compilation errors.
type UnsafeParkingServer interface {
        mustEmbedUnimplementedParkingServer()
}

func RegisterParkingServer(s grpc.ServiceRegistrar, srv ParkingServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;Parking_ServiceDesc, srv)
}</span>

func _Parking_CreateCar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateCarReq)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ParkingServer).CreateCar(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/parking.Parking/CreateCar",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ParkingServer).CreateCar(ctx, req.(*CreateCarReq))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Parking_UpdateSessionPaid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateSessionPaidRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ParkingServer).UpdateSessionPaid(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/parking.Parking/UpdateSessionPaid",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ParkingServer).UpdateSessionPaid(ctx, req.(*UpdateSessionPaidRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Parking_ServiceDesc is the grpc.ServiceDesc for Parking service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Parking_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "parking.Parking",
        HandlerType: (*ParkingServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateCar",
                        Handler:    _Parking_CreateCar_Handler,
                },
                {
                        MethodName: "UpdateSessionPaid",
                        Handler:    _Parking_UpdateSessionPaid_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "parking_service.proto",
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "k071123/internal/services/parking_service/domain"
        domainServices "k071123/internal/services/parking_service/domain/services"
        "k071123/internal/services/parking_service/services/config"
        "k071123/internal/services/parking_service/storage/repositories"
        "k071123/tools/logger"
)

type Ctx struct {
        services   domain.Services
        connection domain.Connection
}

type svs struct {
        config domainServices.Config
        logger *logger.Logger
}

func (s *svs) Config() domainServices.Config <span class="cov0" title="0">{
        return s.config
}</span>

func (s *svs) Logger() *logger.Logger <span class="cov0" title="0">{
        return s.logger
}</span>

func (c *Ctx) Services() domain.Services <span class="cov0" title="0">{
        return c.services
}</span>

func (c *Ctx) Connection() domain.Connection <span class="cov0" title="0">{
        return c.connection
}</span>

func (c *Ctx) Make() domain.Context <span class="cov0" title="0">{
        return &amp;Ctx{
                services:   c.services,
                connection: c.connection,
        }
}</span>

func InitCtx() *Ctx <span class="cov0" title="0">{
        cfg := config.Make()

        log, err := logger.New(logger.Config{
                Host:     cfg.ElasticHost(),
                Port:     cfg.ElasticPort(),
                Username: cfg.ElasticUsername(),
                Password: cfg.ElasticPassword(),
                Index:    "parking",
                Service:  "parking_service",
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">sqlConnection, err := repositories.NewConnection(
                cfg.PostgresUser(),
                cfg.PostgresPassword(),
                cfg.PostgresHost(),
                cfg.PostgresPort(),
                cfg.PostgresDbName(),
        )
        if err != nil </span><span class="cov0" title="0">{
                panic("connection isnt success")</span>
        }

        <span class="cov0" title="0">return &amp;Ctx{
                services: &amp;svs{
                        config: cfg,
                        logger: log,
                },
                connection: sqlConnection,
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package core

import (
        "k071123/internal/services/parking_service/delivery/http"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/cases/car"
        "k071123/internal/services/parking_service/domain/cases/parking"
        "k071123/internal/services/parking_service/domain/cases/session"
        "k071123/internal/services/parking_service/domain/cases/tariff"
        "k071123/internal/services/parking_service/domain/cases/unit"
        "k071123/internal/services/parking_service/services/config"
        "k071123/internal/utils/middleware"
)

type Di struct {
        Ctx            domain.Context
        ParkingHandler *http.ParkingHandler
        TariffHandler  *http.TariffHandler
        SessionHandler *http.SessionHandler
        UnitHandler    *http.UnitHandler
}

func NewDi() *Di <span class="cov0" title="0">{
        cfg := config.Make()
        ctx := InitCtx()

        oc, err := MakeOrderServiceClient()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">userGrpcClient, err := MakeUserServiceClient()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">notificationGrpcClient, err := MakeNotificationServiceClient()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">mw := middleware.NewMiddleware(cfg.PublicPemPath())
        var (
                parkingUseCase = parking.NewParkingUseCase(ctx)
                parkingHandler = http.NewParkingHandler(parkingUseCase, mw, ctx.Services().Logger())

                tariffUseCase = tariff.NewTariffUseCase(ctx)
                tariffHandler = http.NewTariffHandler(tariffUseCase, mw)

                carUseCase     = car.NewCarUseCase(ctx)
                sessionUseCase = session.NewSessionUseCase(ctx, oc, notificationGrpcClient, userGrpcClient)
                sessionHandler = http.NewSessionHandler(sessionUseCase, carUseCase, mw, oc, ctx.Services().Logger())

                unitUseCase = unit.NewUnitUseCase(ctx)
                unitHandler = http.NewUnitHandler(unitUseCase, mw)
        )

        return &amp;Di{
                Ctx:            ctx,
                ParkingHandler: parkingHandler,
                TariffHandler:  tariffHandler,
                SessionHandler: sessionHandler,
                UnitHandler:    unitHandler,
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package core

import (
        "context"
        "fmt"
        "google.golang.org/grpc"
        "k071123/internal/services/notification_service/contracts/pkg/proto"
        "k071123/internal/services/parking_service/services/config"
        "log"
        "sync"
        "time"
)

var (
        notificationClient     proto.NotificationClient
        notificationClientOnce sync.Once
)

func makeSecureNotificationConnection() (*grpc.ClientConn, error) <span class="cov0" title="0">{
        cfg := config.Make()
        addr := fmt.Sprintf("%s:%s", cfg.NotificationGrpcHost(), cfg.NotificationGrpcPort())
        // Используем контекст с тайм-аутом (например, 10 секунд)
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        conn, err := grpc.DialContext(ctx, addr, grpc.WithInsecure())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not connect to grpc client: %v", err)
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

func MakeNotificationServiceClient() (proto.NotificationClient, error) <span class="cov0" title="0">{
        var err error
        notificationClientOnce.Do(func() </span><span class="cov0" title="0">{
                conn, err := makeSecureNotificationConnection()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("could not create client connection: %v", err)
                }</span>
                <span class="cov0" title="0">notificationClient = proto.NewNotificationClient(conn)
                log.Println("Notification client initialized successfully.")</span>
        })
        <span class="cov0" title="0">return notificationClient, err</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package core

import (
        "context"
        "fmt"
        "google.golang.org/grpc"
        "k071123/internal/services/order_service/contracts/pkg/proto"
        "k071123/internal/services/parking_service/services/config"
        "log"
        "sync"
        "time"
)

var (
        orderClient     proto.OrderClient
        orderClientOnce sync.Once
)

func makeSecureOrderConnection() (*grpc.ClientConn, error) <span class="cov0" title="0">{
        cfg := config.Make()
        addr := fmt.Sprintf("%s:%s", cfg.OrderGrpcHost(), cfg.OrderGrpcPort())
        // Используем контекст с тайм-аутом (например, 10 секунд)
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        conn, err := grpc.DialContext(ctx, addr, grpc.WithInsecure())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not connect to grpc client: %v", err)
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

func MakeOrderServiceClient() (proto.OrderClient, error) <span class="cov0" title="0">{
        var err error
        orderClientOnce.Do(func() </span><span class="cov0" title="0">{
                conn, err := makeSecureOrderConnection()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("could not create client connection: %v", err)
                }</span>
                <span class="cov0" title="0">orderClient = proto.NewOrderClient(conn)
                log.Println("Order client initialized successfully.")</span>
        })
        <span class="cov0" title="0">return orderClient, err</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package core

import (
        "fmt"
        "google.golang.org/grpc"
        "k071123/internal/services/parking_service/contracts/pkg/proto"
        grpc2 "k071123/internal/services/parking_service/delivery/grpc"
        "k071123/internal/services/parking_service/domain/cases/car"
        "k071123/internal/services/parking_service/services/config"
        "net"
)

type GrpcServer struct {
        listener   net.Listener
        grpcServer *grpc.Server
}

func NewGrpcServer() *GrpcServer <span class="cov0" title="0">{
        cfg := config.Make()
        ctx := InitCtx()

        grpcListener, err := net.Listen("tcp", fmt.Sprintf("%s:%s", cfg.ParkingGrpcHost(), cfg.ParkingGrpcPort()))
        if err != nil </span><span class="cov0" title="0">{
                panic("failed to listen: " + err.Error())</span>
        }

        <span class="cov0" title="0">var opts []grpc.ServerOption
        grpcServer := grpc.NewServer(opts...)

        carUseCase := car.NewCarUseCase(ctx)
        proto.RegisterParkingServer(grpcServer, grpc2.NewHandler(ctx, carUseCase))

        return &amp;GrpcServer{
                listener:   grpcListener,
                grpcServer: grpcServer,
        }</span>
}

func (gs *GrpcServer) Start() <span class="cov0" title="0">{
        if err := gs.grpcServer.Serve(gs.listener); err != nil </span><span class="cov0" title="0">{
                panic("failed to serve: " + err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package core

import (
        "context"
        "fmt"
        "google.golang.org/grpc"
        "k071123/internal/services/parking_service/services/config"
        "k071123/internal/services/user_service/contracts/pkg/proto"
        "log"
        "sync"
        "time"
)

var (
        userClient     proto.UserClient
        userClientOnce sync.Once
)

func makeSecureUserConnection() (*grpc.ClientConn, error) <span class="cov0" title="0">{
        cfg := config.Make()
        addr := fmt.Sprintf("%s:%s", cfg.UserGrpcHost(), cfg.UserGrpcPort())
        // Используем контекст с тайм-аутом (например, 10 секунд)
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        conn, err := grpc.DialContext(ctx, addr, grpc.WithInsecure())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not connect to grpc client: %v", err)
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

func MakeUserServiceClient() (proto.UserClient, error) <span class="cov0" title="0">{
        var err error
        userClientOnce.Do(func() </span><span class="cov0" title="0">{
                conn, err := makeSecureUserConnection()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("could not create client connection: %v", err)
                }</span>
                <span class="cov0" title="0">userClient = proto.NewUserClient(conn)
                log.Println("User client initialized successfully.")</span>
        })
        <span class="cov0" title="0">return userClient, err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package core

import (
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/services/config"
        "k071123/internal/utils/middleware"
        "runtime"
        "strings"
)

type HttpServer struct {
        app *fiber.App
        ctx domain.Context
}

type Server interface {
        Start()
        App() *fiber.App
}

func NewHttpServer() Server <span class="cov0" title="0">{
        app := fiber.New()
        ctx := InitCtx()

        var methods = []string{fiber.MethodGet, fiber.MethodPost, fiber.MethodPut, fiber.MethodDelete}
        var headers = []string{
                fiber.HeaderAccept,
                fiber.HeaderAuthorization,
                fiber.HeaderContentType,
                fiber.HeaderContentLength,
                fiber.HeaderAcceptEncoding,
        }

        corsConfig := cors.New(cors.Config{
                AllowOrigins: strings.Join([]string{
                        "http://localhost:7802/", "http://localhost:8129/",
                }, ", "),
                AllowMethods:     strings.Join(methods, ", "),
                AllowHeaders:     strings.Join(headers, ", "),
                AllowCredentials: true, // Убедимся, что можно передавать куки и авторизационные заголовки
                MaxAge:           300,
        })

        app.Use(middleware.PanicRecovery(ctx.Services().Logger()))
        app.Use(middleware.LoggerMiddleware(ctx.Services().Logger()))

        app.Use(corsConfig)
        app.Use(func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                c.Locals("context", ctx)
                return c.Next()
        }</span>)

        <span class="cov0" title="0">return &amp;HttpServer{
                app: app,
                ctx: ctx,
        }</span>
}

func (s *HttpServer) Start() <span class="cov0" title="0">{
        cfg := config.Make()

        runtime.GOMAXPROCS(runtime.NumCPU())
        err := s.app.Listen(":" + cfg.HttpPort())
        if err != nil </span><span class="cov0" title="0">{
                panic("http server inst start successfully")</span>
        }
}

func (s *HttpServer) App() *fiber.App <span class="cov0" title="0">{
        return s.app
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package grpc

import (
        "context"
        "k071123/internal/services/parking_service/contracts/pkg/proto"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/cases/car"
        "k071123/internal/services/parking_service/domain/props"
)

type GrpcHandler struct {
        proto.UnimplementedParkingServer
        ctx        domain.Context
        carUseCase *car.CarUseCase
}

func NewHandler(ctx domain.Context, carUseCase *car.CarUseCase) *GrpcHandler <span class="cov0" title="0">{
        return &amp;GrpcHandler{
                ctx:        ctx,
                carUseCase: carUseCase,
        }
}</span>

func (h *GrpcHandler) CreateCar(c context.Context, req *proto.CreateCarReq) (*proto.CreateCarResp, error) <span class="cov0" title="0">{
        resp, err := h.carUseCase.CreateCar(props.CreateCarReq{
                GosNumber: req.GosNumber,
                UserUUID:  req.UserUUID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;proto.CreateCarResp{
                Car: &amp;proto.Car{
                        UUID:      resp.Car.UUID.String(),
                        UserUUID:  resp.Car.UserUUID.String(),
                        GosNumber: resp.Car.GosNumber,
                        IsActive:  resp.Car.IsActive,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package http

import (
        "github.com/gofiber/fiber/v2"
        "k071123/internal/services/parking_service/domain/cases/parking"
        "k071123/internal/services/parking_service/domain/props"
        "k071123/internal/shared/permissions"
        "k071123/internal/utils/errs"
        "k071123/internal/utils/middleware"
        "k071123/tools/logger"
)

type ParkingHandler struct {
        useCase *parking.ParkingUseCase
        mw      *middleware.Middleware
        log     *logger.Logger
}

func NewParkingHandler(useCase *parking.ParkingUseCase, mw *middleware.Middleware, log *logger.Logger) *ParkingHandler <span class="cov0" title="0">{
        return &amp;ParkingHandler{
                useCase: useCase,
                mw:      mw,
                log:     log,
        }
}</span>

func RegisterParkingRoutes(router fiber.Router, ph *ParkingHandler, mw *middleware.Middleware) <span class="cov0" title="0">{
        router.Post("/create", mw.AuthMiddleware([]permissions.Permission{
                permissions.CreateParking,
        }), ph.CreateParkingHandler)
}</span>

// CreateParkingHandler
// @Summary      Создать сущность парковки
// @Description  Создать сущность парковки
// @Tags         Parking
// @Accept       json
// @Produce      json
// @Security BearerAuth
// @Param request body props.CreateParkingReq true "Данные для создания парковки"
// @Success      200 {object} props.CreateParkingResp "Модель созданной парковки."
// @Failure      400 {object} errs.Error "Bad Request"
// @Failure      404 {object} errs.Error "Profile not found"
// @Failure      500 {object} errs.Error "Internal Server Error"
// @Router       /api/v1/parking/create [post]
func (h *ParkingHandler) CreateParkingHandler(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        var args props.CreateParkingReq
        log := h.log.WithField("Handler", "CreateParking")
        if err := ctx.BodyParser(&amp;args); err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to parse CreateParking request body: %v", err)
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">resp, err := h.useCase.CreateParking(args)
        if err != nil </span><span class="cov0" title="0">{
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">return errs.SendSuccess(ctx, fiber.StatusCreated, resp)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package http

import (
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/swagger"
)

// SetupRoutes регистрирует все маршруты, используя агрегированный набор хэндлеров
// @title Parking Service API
// @version 1.0
// @description API для работы с парковками
// @host localhost:7802
// @BasePath /api/v1
// @schemes http
func SetupRoutes(app *fiber.App, h *Handlers) <span class="cov0" title="0">{
        api := app.Group("/api/v1")

        docs := app.Group("/docs")
        docs.Get("/swagger/*", swagger.HandlerDefault)

        parkingGroup := api.Group("/parking")
        tariffGroup := api.Group("/tariff")
        sessionGroup := api.Group("/session")
        unitGroup := api.Group("/unit")

        RegisterParkingRoutes(parkingGroup, h.ParkingHandler, h.ParkingHandler.mw)
        RegisterTariffRoutes(tariffGroup, h.TariffHandler, h.TariffHandler.mw)
        RegisterSessionRoutes(sessionGroup, h.SessionHandler, h.SessionHandler.mw)
        RegisterUnitRoutes(unitGroup, h.UnitHandler, h.UnitHandler.mw)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package http

import (
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "k071123/internal/services/order_service/contracts/pkg/proto"
        "k071123/internal/services/parking_service/domain/cases/car"
        "k071123/internal/services/parking_service/domain/cases/session"
        "k071123/internal/services/parking_service/domain/props"
        "k071123/internal/shared/permissions"
        "k071123/internal/utils/errs"
        "k071123/internal/utils/middleware"
        "k071123/tools/logger"
)

type SessionHandler struct {
        useCase    *session.SessionUseCase
        carUseCase *car.CarUseCase
        mw         *middleware.Middleware
        oc         proto.OrderClient
        log        *logger.Logger
}

func NewSessionHandler(
        useCase *session.SessionUseCase,
        carUc *car.CarUseCase,
        mw *middleware.Middleware,
        oc proto.OrderClient,
        log *logger.Logger,
) *SessionHandler <span class="cov0" title="0">{
        return &amp;SessionHandler{
                useCase:    useCase,
                carUseCase: carUc,
                mw:         mw,
                oc:         oc,
                log:        log,
        }
}</span>

func RegisterSessionRoutes(router fiber.Router, sh *SessionHandler, mw *middleware.Middleware) <span class="cov0" title="0">{
        router.Post("/start", mw.AuthMiddleware([]permissions.Permission{
                permissions.StartSession,
        }), sh.StartSessionHandler)
        router.Post("/stop", mw.AuthMiddleware([]permissions.Permission{
                permissions.StopSession,
        }), sh.FinishSessionHandler)
}</span>

// StartSessionHandler
// @Summary      Начать парковочную сессию
// @Description  Начать парковочную сессию
// @Tags         Session
// @Accept       json
// @Produce      json
// @Security BearerAuth
// @Param request body props.StartSessionReq true "Данные для старта сесси"
// @Success      200 {object} props.StartSessionResp "Статус сессии."
// @Failure      400 {object} errs.Error "Bad Request"
// @Failure      404 {object} errs.Error "Profile not found"
// @Failure      500 {object} errs.Error "Internal Server Error"
// @Router       /api/v1/session/start [post]
func (h *SessionHandler) StartSessionHandler(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        var args props.StartSessionReq
        log := h.log.WithField("Handler", "StartSession")
        if err := ctx.BodyParser(&amp;args); err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to parse StartSession request body: %v", err)
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">userUUID, err := middleware.GetUserUUIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to get userUUID from context: %v", err)
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">args.UserUUID = userUUID
        resp, err := h.useCase.Start(args, h.oc)
        if err != nil </span><span class="cov0" title="0">{
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">return errs.SendSuccess(ctx, fiber.StatusCreated, resp)</span>
}

// FinishSessionHandler
// @Summary      Закончить парковочную сессию
// @Description  Закончить парковочную сессию
// @Tags         Session
// @Accept       json
// @Produce      json
// @Security BearerAuth
// @Param request body props.FinishSessionRequest true "Данные для стопа сессии"
// @Success      200 {object} props.FinishSessionResp "Статус сессии."
// @Failure      400 {object} errs.Error "Bad Request"
// @Failure      404 {object} errs.Error "Profile not found"
// @Failure      500 {object} errs.Error "Internal Server Error"
// @Router       /api/v1/session/stop [post]
func (h *SessionHandler) FinishSessionHandler(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        var args props.FinishSessionRequest
        if err := ctx.BodyParser(&amp;args); err != nil </span><span class="cov0" title="0">{
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">userUUID, err := middleware.GetUserUUIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("user: %s", userUUID)
                return errs.SendError(ctx, err)
        }</span>
        <span class="cov0" title="0">log.Infof("car number: %s", args.CarNumber)
        args.UserUUID = userUUID
        resp, err := h.useCase.Finish(args, h.oc)
        if err != nil </span><span class="cov0" title="0">{
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">return errs.SendSuccess(ctx, fiber.StatusCreated, resp)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package http

import (
        "github.com/gofiber/fiber/v2"

        "k071123/internal/services/parking_service/domain/cases/tariff"
        "k071123/internal/services/parking_service/domain/props"

        "k071123/internal/shared/permissions"
        "k071123/internal/utils/errs"
        "k071123/internal/utils/middleware"
)

type TariffHandler struct {
        useCase *tariff.TariffUseCase
        mw      *middleware.Middleware
}

func NewTariffHandler(useCase *tariff.TariffUseCase, mw *middleware.Middleware) *TariffHandler <span class="cov0" title="0">{
        return &amp;TariffHandler{
                useCase: useCase,
                mw:      mw,
        }
}</span>

func RegisterTariffRoutes(router fiber.Router, ph *TariffHandler, mw *middleware.Middleware) <span class="cov0" title="0">{
        router.Post("/create", mw.AuthMiddleware([]permissions.Permission{
                permissions.CreateUser,
        }), ph.CreateTariffHandler)
}</span>

// CreateTariffHandler
// @Summary      Создать тариф
// @Description  Создать тариф
// @Tags         Tariff
// @Accept       json
// @Produce      json
// @Security BearerAuth
// @Param request body props.CreateTariffReq true "Данные для создания тарифа"
// @Success      200 {object} props.CreateTariffResp "Модель созданной тарифа."
// @Failure      400 {object} errs.Error "Bad Request"
// @Failure      404 {object} errs.Error "Profile not found"
// @Failure      500 {object} errs.Error "Internal Server Error"
// @Router       /api/v1/tariff/create [post]
func (h *TariffHandler) CreateTariffHandler(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        var args props.CreateTariffReq
        if err := ctx.BodyParser(&amp;args); err != nil </span><span class="cov0" title="0">{
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">resp, err := h.useCase.CreateTariff(args)
        if err != nil </span><span class="cov0" title="0">{
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">return errs.SendSuccess(ctx, fiber.StatusCreated, resp)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package http

import (
        "github.com/gofiber/fiber/v2"
        "k071123/internal/services/parking_service/domain/cases/unit"
        "k071123/internal/services/parking_service/domain/props"
        "k071123/internal/shared/permissions"
        "k071123/internal/utils/errs"
        "k071123/internal/utils/middleware"
)

type UnitHandler struct {
        useCase *unit.UnitUseCase
        mw      *middleware.Middleware
}

func NewUnitHandler(useCase *unit.UnitUseCase, mw *middleware.Middleware) *UnitHandler <span class="cov0" title="0">{
        return &amp;UnitHandler{
                useCase: useCase,
                mw:      mw,
        }
}</span>

func RegisterUnitRoutes(router fiber.Router, ph *UnitHandler, mw *middleware.Middleware) <span class="cov0" title="0">{
        router.Post("/create", mw.AuthMiddleware([]permissions.Permission{
                permissions.CreateUnit,
        }), ph.CreateUnitHandler)
}</span>

// CreateUnitHandler
// @Summary      Создать сущность Unit
// @Description  Создать сущность Unit
// @Tags         Unit
// @Accept       json
// @Produce      json
// @Security BearerAuth
// @Param request body props.CreateUniqReq true "Данные для создания паркомата"
// @Success      200 {object} props.CreateUnitResp "Модель созданной паркомата."
// @Failure      400 {object} errs.Error "Bad Request"
// @Failure      404 {object} errs.Error "Profile not found"
// @Failure      500 {object} errs.Error "Internal Server Error"
// @Router       /api/v1/unit/create [post]
func (h *UnitHandler) CreateUnitHandler(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        var args props.CreateUniqReq
        if err := ctx.BodyParser(&amp;args); err != nil </span><span class="cov0" title="0">{
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">resp, err := h.useCase.CreateUnit(args)
        if err != nil </span><span class="cov0" title="0">{
                return errs.SendError(ctx, err)
        }</span>

        <span class="cov0" title="0">return errs.SendSuccess(ctx, fiber.StatusCreated, resp)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package car

import (
        "github.com/google/uuid"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/models"
        "k071123/internal/services/parking_service/domain/props"
        "k071123/internal/utils/errs"
)

type CarUseCase struct {
        ctx domain.Context
}

// TODO: CRUD + GetByGosNumber

func NewCarUseCase(ctx domain.Context) *CarUseCase <span class="cov8" title="1">{
        return &amp;CarUseCase{ctx: ctx}
}</span>

func (uc *CarUseCase) CreateCar(args props.CreateCarReq) (resp props.CreateCarResp, err error) <span class="cov8" title="1">{
        log := uc.ctx.Services().Logger().WithField("CarUseCase", "CreateCar")
        log.Printf("create car started work")
        if err := args.Validate(); err != nil </span><span class="cov8" title="1">{
                log.Errorf("validate input error: %v", err)
                return resp, errs.NewErrorWithDetails(errs.ErrUnprocessableEntity, err.Error())
        }</span>

        <span class="cov8" title="1">car := &amp;models.Car{
                UUID:      uuid.New(),
                GosNumber: args.GosNumber,
                IsActive:  true,
                UserUUID:  uuid.MustParse(args.UserUUID),
        }
        if err := uc.ctx.Connection().CarRepository().Add(car); err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to add car to database: %v", err)
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "database error")
        }</span>
        <span class="cov8" title="1">resp.Car = car

        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package parking

import (
        "github.com/google/uuid"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/models"
        "k071123/internal/services/parking_service/domain/models/parking_statuses"
        "k071123/internal/services/parking_service/domain/props"
        "k071123/internal/utils/errs"
)

type ParkingUseCase struct {
        ctx domain.Context
}

// TODO: CRUD PARKING

func NewParkingUseCase(ctx domain.Context) *ParkingUseCase <span class="cov0" title="0">{
        return &amp;ParkingUseCase{ctx: ctx}
}</span>

func (uc *ParkingUseCase) CreateParking(args props.CreateParkingReq) (resp props.CreateParkingResp, err error) <span class="cov0" title="0">{
        log := uc.ctx.Services().Logger().WithField("ParkingUseCase", "ParkingUseCase.CreateParking")
        if err := args.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Errorf("validation error: %s", err.Error())
                return resp, errs.NewErrorWithDetails(errs.ErrUnprocessableEntity, err.Error())
        }</span>

        <span class="cov0" title="0">tx, err := uc.ctx.Connection().Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("begin transaction error: %s", err.Error())
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to start transaction")
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        parking := &amp;models.Parking{
                UUID:        uuid.New(),
                Name:        args.Name,
                Latitude:    args.Latitude,
                Longitude:   args.Longitude,
                Address:     args.Address,
                TotalPlaces: args.TotalPlaces,
                Status:      parking_statuses.Active,
        }

        var parkingScheduleList []models.ParkingSchedule
        for i := 0; i &lt; len(args.WorkingTime); i++ </span><span class="cov0" title="0">{
                workingTime := ParkingScheduleParser(args.WorkingTime[i], parking.UUID)
                parkingScheduleList = append(parkingScheduleList, workingTime)
        }</span>
        <span class="cov0" title="0">parking.WorkingTime = parkingScheduleList

        if args.Tariff != nil &amp;&amp; args.TariffUUID == nil </span><span class="cov0" title="0">{
                tariff := &amp;models.Tariff{
                        UUID:            uuid.New(),
                        Type:            args.Tariff.Type,
                        HasFree:         args.Tariff.HasFree,
                        FreeTime:        args.Tariff.FreeTime,
                        HourlyPrice:     args.Tariff.HourlyPrice,
                        LongHourlyPrice: args.Tariff.LongHourlyPrice,
                        DailyPrice:      args.Tariff.DailyPrice,
                        LongHourlyEnd:   args.Tariff.LongHourlyEnd,
                        LongHourlyStart: args.Tariff.LongHourlyStart,
                }

                parking.TariffUUID = tariff.UUID
                if err := tx.TariffRepository().Add(tariff); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("create tariff error: %s", err.Error())
                        return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "failed to create tariff")
                }</span>
        }
        <span class="cov0" title="0">if args.TariffUUID != nil </span><span class="cov0" title="0">{
                tariff, err := tx.TariffRepository().GetByUUID(*args.TariffUUID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("get tariff error: %s", err.Error())
                        return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "failed to get tariff")
                }</span>
                <span class="cov0" title="0">parking.TariffUUID = tariff.UUID</span>
        }

        <span class="cov0" title="0">if err := tx.ParkingRepository().Add(parking); err != nil </span><span class="cov0" title="0">{
                log.Errorf("create parking error: %s", err.Error())
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "failed to create parking")
        }</span>
        <span class="cov0" title="0">resp.Parking = parking

        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return props.CreateParkingResp{}, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

//func (uc *ParkingUseCase) SearchParking(args props.SearchParkingReq) (resp props.SearchParkingResp, err error) {
//
//}
</pre>
		
		<pre class="file" id="file18" style="display: none">package parking

import (
        "github.com/google/uuid"
        "k071123/internal/services/parking_service/domain/models"
        "k071123/internal/services/parking_service/domain/props"
)

func ParkingScheduleParser(args props.CreateParkingSchedule, parkingUUID uuid.UUID) models.ParkingSchedule <span class="cov0" title="0">{
        var days64type []int64
        for i := 0; i &lt; len(args.DaysOfWeek); i++ </span><span class="cov0" title="0">{
                days64type = append(days64type, int64(i))
        }</span>

        <span class="cov0" title="0">return models.ParkingSchedule{
                UUID:        uuid.New(),
                DaysOfWeek:  args.DaysOfWeek,
                OpenTime:    args.OpenTime,
                CloseTime:   args.CloseTime,
                ParkingUUID: parkingUUID,
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package session

import (
        "context"
        "fmt"
        "github.com/google/uuid"
        proto2 "k071123/internal/services/notification_service/contracts/pkg/proto"
        "k071123/internal/services/order_service/contracts/pkg/proto"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/cases/tariff"
        "k071123/internal/services/parking_service/domain/models"
        "k071123/internal/services/parking_service/domain/props"
        proto3 "k071123/internal/services/user_service/contracts/pkg/proto"
        "k071123/internal/utils/errs"
        "time"
)

type SessionUseCase struct {
        ctx domain.Context
        oc  proto.OrderClient
        nc  proto2.NotificationClient
        uc  proto3.UserClient
}

func NewSessionUseCase(
        ctx domain.Context,
        oc proto.OrderClient,
        nc proto2.NotificationClient,
        uc proto3.UserClient,
) *SessionUseCase <span class="cov0" title="0">{
        return &amp;SessionUseCase{ctx: ctx, oc: oc, nc: nc, uc: uc}
}</span>

// TODO: сделать Search по Sessions

func (uc *SessionUseCase) Start(args props.StartSessionReq, oc proto.OrderClient) (resp props.StartSessionResp, err error) <span class="cov0" title="0">{
        // unit parking uuid validation
        log := uc.ctx.Services().Logger().WithField("SessionUseCase", "Start")
        tx, err := uc.ctx.Connection().Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("begin transaction error: %s", err.Error())
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to start transaction")
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        cardResp, err := oc.GetPreferredByUserUUID(context.Background(), &amp;proto.GetPreferredCardReq{
                UserUuid: args.UserUUID,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("grpc error, cannot get card: %v", err)
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get user card from order service")
        }</span>
        <span class="cov0" title="0">if cardResp.Card == nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "cannot start session without connected card")
        }</span>

        <span class="cov0" title="0">unit, err := tx.UnitRepository().GetByUUID(args.UnitUUID)
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get unit")
        }</span>
        <span class="cov0" title="0">if unit.ParkingUUID == nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrBadRequest, "unit is disconnected of parking")
        }</span>
        <span class="cov0" title="0">car, err := tx.CarRepository().GetByGosNumber(args.CarNumber)
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get car by number")
        }</span>

        <span class="cov0" title="0">filter := tx.SessionRepository().Filter().
                SetStatuses([]string{"active"}).
                SetCarUUIDs([]string{car.UUID.String()})
        sessions, err := tx.SessionRepository().WhereFilter(filter)
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to find sessions")
        }</span>
        <span class="cov0" title="0">if len(sessions) != 0 </span><span class="cov0" title="0">{
                log.Infof("found sessions: %v", sessions)
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "already has sessions")
        }</span>

        <span class="cov0" title="0">parking, err := tx.ParkingRepository().GetByUUID(unit.ParkingUUID.String())
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get parking by uuid")
        }</span>

        <span class="cov0" title="0">session := &amp;models.Session{
                UUID:        uuid.New(),
                ParkingUUID: parking.UUID,
                CarUUID:     car.UUID,
                StartAt:     time.Now(),
                Status:      models.Active,
        }
        if err := tx.SessionRepository().Add(session); err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to add session")
        }</span>
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                log.Errorf("commit transaction error: %s", err.Error())
                return resp, err
        }</span>
        <span class="cov0" title="0">resp.Status = "success"
        return resp, nil</span>
}

func (uc *SessionUseCase) Finish(args props.FinishSessionRequest, oc proto.OrderClient) (resp props.FinishSessionResp, err error) <span class="cov0" title="0">{
        log := uc.ctx.Services().Logger().WithField("SessionUseCase", "Finish")
        tx, err := uc.ctx.Connection().Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("begin transaction error: %s", err.Error())
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to start transaction")
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        log.Infof("user uuid: %s", args.UserUUID)
        user, err := uc.uc.GetUserByUUID(ctx, &amp;proto3.GetUserReq{
                Uuid: args.UserUUID,
        })
        if user == nil </span><span class="cov0" title="0">{
                log.Errorf("cannot find user")
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to find user")
        }</span>

        <span class="cov0" title="0">car, err := uc.ctx.Connection().CarRepository().GetByGosNumber(args.CarNumber)
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get car by number")
        }</span>

        <span class="cov0" title="0">unit, err := uc.ctx.Connection().UnitRepository().GetByUUID(args.UnitUUID.String())
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get unit by uuid")
        }</span>

        // active
        <span class="cov0" title="0">filter := uc.ctx.Connection().SessionRepository().Filter().SetCarUUIDs([]string{car.UUID.String()}).SetStatuses([]string{"active"})
        sessions, err := uc.ctx.Connection().SessionRepository().WhereFilter(filter)
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get session by uuid")
        }</span>
        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrBadRequest, "you don`t have an active session")
        }</span>

        <span class="cov0" title="0">session := sessions[0]
        parking, err := uc.ctx.Connection().ParkingRepository().GetByUUID(unit.ParkingUUID.String())
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get parking by uuid")
        }</span>

        <span class="cov0" title="0">tf, err := uc.ctx.Connection().TariffRepository().GetByUUID(parking.TariffUUID.String())
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get tariff by uuid")
        }</span>

        <span class="cov0" title="0">dur := time.Since(session.StartAt)
        if tf == nil </span><span class="cov0" title="0">{
                tf = &amp;models.Tariff{}
        }</span>

        <span class="cov0" title="0">cost, err := tariff.CalculateSessionCost(dur, *tf)
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to calculate the price")
        }</span>

        <span class="cov0" title="0">switch args.PaymentMethod </span>{
        case props.BankCard:<span class="cov0" title="0">
                cardResp, err := oc.GetPreferredByUserUUID(context.Background(), &amp;proto.GetPreferredCardReq{
                        UserUuid: args.UserUUID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to get card by uuid")
                }</span>
                <span class="cov0" title="0">if cardResp.Card == nil </span><span class="cov0" title="0">{
                        return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to start session without connected bank card")
                }</span>

                <span class="cov0" title="0">paymentResp, err := oc.CreatePayment(context.Background(), &amp;proto.CreatePaymentReq{
                        SessionUuid:   session.UUID.String(),
                        PaymentMethod: string(args.PaymentMethod),
                        Amount:        float32(cost),
                        Description:   fmt.Sprintf("Это платеж за парковочную сессию №%s", session.UUID.String()),
                        UserUuid:      args.UserUUID,
                        CardUuid:      cardResp.Card.Uuid,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to make payment")
                }</span>

                <span class="cov0" title="0">if paymentResp.Payment.Status != "succeeded" </span><span class="cov0" title="0">{
                        return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "payment failed")
                }</span>
        }

        <span class="cov0" title="0">now := time.Now()
        updates := uc.ctx.Connection().SessionRepository().Updates().
                SetStatus(string(models.Finished)).
                SetFinishAt(&amp;now).
                SetCost(cost)

        if err := tx.SessionRepository().Update(session.UUID, updates); err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to update session")
        }</span>
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        // user service grpc
        // OUTBOX
        <span class="cov0" title="0">_, err = uc.nc.SendEmail(ctx, &amp;proto2.SendEmailReq{
                Data:    "Your parking session successfully finished",
                Subject: "Parking Session",
                To:      []string{user.Email},
        })
        if err != nil </span><span class="cov0" title="0">{
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to send email")
        }</span>
        <span class="cov0" title="0">resp.Status = "success"

        return resp, nil</span>
}

func (uc *SessionUseCase) UpdatePaidTiming(args props.UpdateSessionPaid) error <span class="cov0" title="0">{
        updates := uc.ctx.Connection().SessionRepository().Updates()
        session, err := uc.ctx.Connection().SessionRepository().GetByUUID(args.SessionUUID.String())
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewErrorWithDetails(errs.ErrInternalServerError, "failed to find parking session")
        }</span>

        <span class="cov0" title="0">if session == nil </span><span class="cov0" title="0">{
                return errs.NewErrorWithDetails(errs.ErrInternalServerError, "failed to find parking session")
        }</span>
        <span class="cov0" title="0">now := time.Now()
        updates.SetFinishAt(&amp;now)
        if err := uc.ctx.Connection().SessionRepository().Update(args.SessionUUID, updates); err != nil </span><span class="cov0" title="0">{
                return errs.NewErrorWithDetails(errs.ErrInternalServerError, "failed to update parking session")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package tariff

import (
        "github.com/google/uuid"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/models"
        "k071123/internal/services/parking_service/domain/props"
        "k071123/internal/utils/errs"
        "time"
)

// TODO: CRUD TARIFF

type TariffUseCase struct {
        ctx domain.Context
}

func NewTariffUseCase(ctx domain.Context) *TariffUseCase <span class="cov0" title="0">{
        return &amp;TariffUseCase{ctx: ctx}
}</span>

func (uc *TariffUseCase) CreateTariff(args props.CreateTariffReq) (resp props.CreateTariffResp, err error) <span class="cov0" title="0">{
        log := uc.ctx.Services().Logger().WithField("TariffUseCase", "CreateTariff")
        tariff := &amp;models.Tariff{
                UUID:            uuid.New(),
                HourlyPrice:     args.HourlyPrice,
                LongHourlyPrice: args.LongHourlyPrice,
                DailyPrice:      args.DailyPrice,
                LongHourlyStart: args.LongHourlyStart,
                LongHourlyEnd:   args.LongHourlyEnd,
                Type:            args.Type,
        }
        if args.HasFree != nil </span><span class="cov0" title="0">{
                tariff.HasFree = args.HasFree
        }</span>
        <span class="cov0" title="0">if args.FreeTime != nil </span><span class="cov0" title="0">{
                tariff.FreeTime = args.FreeTime
        }</span>

        <span class="cov0" title="0">if err := uc.ctx.Connection().TariffRepository().Add(tariff); err != nil </span><span class="cov0" title="0">{
                log.Errorf("error on adding tariff: %v", err)
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "database error")
        }</span>
        <span class="cov0" title="0">resp.Tariff = tariff
        return resp, nil</span>
}

func CalculateSessionCost(duration time.Duration, tariff models.Tariff) (float64, error) <span class="cov0" title="0">{
        cost := 0.0
        durationHours := duration.Hours()
        if tariff.HasFree != nil </span><span class="cov0" title="0">{
                // бесплатно
                if duration.Minutes() &lt; float64(*tariff.FreeTime) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
        }
        // меньше часа
        <span class="cov0" title="0">if duration.Minutes() &lt; float64(time.Duration(60)*time.Minute) </span><span class="cov0" title="0">{
                cost = tariff.HourlyPrice
                return cost, nil
        }</span>
        // при условии, что 60 &lt; duration &lt; lhs
        <span class="cov0" title="0">lhs := time.Duration(tariff.LongHourlyStart) * time.Minute // LongHourlyStart в минутах
        if duration.Minutes() &lt; lhs.Minutes() &amp;&amp; duration.Minutes() &gt; 60 </span><span class="cov0" title="0">{
                cost = tariff.HourlyPrice * durationHours
                return cost, nil
        }</span>
        // lhs &lt; duration &lt; lhe
        <span class="cov0" title="0">lhe := time.Duration(tariff.LongHourlyEnd) * time.Minute
        if duration.Minutes() &lt; lhe.Minutes() &amp;&amp; duration.Minutes() &gt; 60 </span><span class="cov0" title="0">{
                cost = tariff.LongHourlyPrice
                return cost, nil
        }</span>
        // lhe &lt; duration
        <span class="cov0" title="0">if lhe.Minutes() &lt; duration.Minutes() </span><span class="cov0" title="0">{
                if duration.Hours() &gt;= 48 </span><span class="cov0" title="0">{
                        cost = tariff.DailyPrice * (duration.Hours() / 24)
                        return cost, nil
                }</span>
                <span class="cov0" title="0">cost = tariff.DailyPrice
                return cost, nil</span>
        }
        <span class="cov0" title="0">return 0, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package unit

import (
        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/models"
        "k071123/internal/services/parking_service/domain/props"
        "k071123/internal/utils/errs"
)

type UnitUseCase struct {
        ctx domain.Context
}

// TODO: CRUD UNIT

func NewUnitUseCase(ctx domain.Context) *UnitUseCase <span class="cov0" title="0">{
        return &amp;UnitUseCase{ctx: ctx}
}</span>

func (uc *UnitUseCase) CreateUnit(args props.CreateUniqReq) (resp props.CreateUnitResp, err error) <span class="cov0" title="0">{
        log := uc.ctx.Services().Logger().WithField("UnitUseCase", "CreateUnit")
        if err := args.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Errorf("validation error on unit: %v", err)
                return resp, errs.NewErrorWithDetails(errs.ErrUnprocessableEntity, err.Error())
        }</span>
        <span class="cov0" title="0">unit := &amp;models.Unit{
                UUID:          uuid.New(),
                Status:        args.Status,
                NetworkStatus: args.NetworkStatus,
                Direction:     args.Direction,
        }
        if args.Code != nil </span><span class="cov0" title="0">{
                unit.Code = args.Code
        }</span>
        <span class="cov0" title="0">if args.QrLink != nil </span><span class="cov0" title="0">{
                unit.QrLink = args.QrLink
        }</span>
        <span class="cov0" title="0">if args.ParkingUUID != nil </span><span class="cov0" title="0">{
                unit.ParkingUUID = args.ParkingUUID
        }</span>

        <span class="cov0" title="0">if err := uc.ctx.Connection().UnitRepository().Add(unit); err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to add unit: %v", err)
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unable to insert unit")
        }</span>

        <span class="cov0" title="0">resp.Unit = unit

        return resp, nil</span>
}

func (uc *UnitUseCase) GetByUUID(args props.GetUnitByUUID) (resp props.GetUnitByUUIDResp, err error) <span class="cov0" title="0">{
        log := uc.ctx.Services().Logger().WithField("UnitUseCase", "GetByUUID").WithFields(logrus.Fields{})
        if args.UUID == uuid.Nil </span><span class="cov0" title="0">{
                log.Errorf("uuid is nil on request")
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "uuid is nil on request")
        }</span>

        <span class="cov0" title="0">unit, err := uc.ctx.Connection().UnitRepository().GetByUUID(args.UUID.String())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to get unit by uuid: %v", err)
                return resp, errs.NewErrorWithDetails(errs.ErrInternalServerError, "unit not found")
        }</span>
        <span class="cov0" title="0">resp.Unit = unit
        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain.Connection -o connection_mock_test.go -n ConnectionMock -p mocks

import (
        mm_domain "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/repositories"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "gorm.io/gorm"
)

// ConnectionMock implements mm_domain.Connection
type ConnectionMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcBegin          func() (t1 mm_domain.TransactionalConnection, err error)
        funcBeginOrigin    string
        inspectFuncBegin   func()
        afterBeginCounter  uint64
        beforeBeginCounter uint64
        BeginMock          mConnectionMockBegin

        funcCarRepository          func() (c1 repositories.CarRepository)
        funcCarRepositoryOrigin    string
        inspectFuncCarRepository   func()
        afterCarRepositoryCounter  uint64
        beforeCarRepositoryCounter uint64
        CarRepositoryMock          mConnectionMockCarRepository

        funcDB          func() (dp1 *gorm.DB)
        funcDBOrigin    string
        inspectFuncDB   func()
        afterDBCounter  uint64
        beforeDBCounter uint64
        DBMock          mConnectionMockDB

        funcParkingRepository          func() (p1 repositories.ParkingRepository)
        funcParkingRepositoryOrigin    string
        inspectFuncParkingRepository   func()
        afterParkingRepositoryCounter  uint64
        beforeParkingRepositoryCounter uint64
        ParkingRepositoryMock          mConnectionMockParkingRepository

        funcSessionRepository          func() (s1 repositories.SessionRepository)
        funcSessionRepositoryOrigin    string
        inspectFuncSessionRepository   func()
        afterSessionRepositoryCounter  uint64
        beforeSessionRepositoryCounter uint64
        SessionRepositoryMock          mConnectionMockSessionRepository

        funcTariffRepository          func() (t1 repositories.TariffRepository)
        funcTariffRepositoryOrigin    string
        inspectFuncTariffRepository   func()
        afterTariffRepositoryCounter  uint64
        beforeTariffRepositoryCounter uint64
        TariffRepositoryMock          mConnectionMockTariffRepository

        funcUnitRepository          func() (u1 repositories.UnitRepository)
        funcUnitRepositoryOrigin    string
        inspectFuncUnitRepository   func()
        afterUnitRepositoryCounter  uint64
        beforeUnitRepositoryCounter uint64
        UnitRepositoryMock          mConnectionMockUnitRepository
}

// NewConnectionMock returns a mock for mm_domain.Connection
func NewConnectionMock(t minimock.Tester) *ConnectionMock <span class="cov8" title="1">{
        m := &amp;ConnectionMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.BeginMock = mConnectionMockBegin{mock: m}

        m.CarRepositoryMock = mConnectionMockCarRepository{mock: m}

        m.DBMock = mConnectionMockDB{mock: m}

        m.ParkingRepositoryMock = mConnectionMockParkingRepository{mock: m}

        m.SessionRepositoryMock = mConnectionMockSessionRepository{mock: m}

        m.TariffRepositoryMock = mConnectionMockTariffRepository{mock: m}

        m.UnitRepositoryMock = mConnectionMockUnitRepository{mock: m}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mConnectionMockBegin struct {
        optional           bool
        mock               *ConnectionMock
        defaultExpectation *ConnectionMockBeginExpectation
        expectations       []*ConnectionMockBeginExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ConnectionMockBeginExpectation specifies expectation struct of the Connection.Begin
type ConnectionMockBeginExpectation struct {
        mock *ConnectionMock

        results      *ConnectionMockBeginResults
        returnOrigin string
        Counter      uint64
}

// ConnectionMockBeginResults contains results of the Connection.Begin
type ConnectionMockBeginResults struct {
        t1  mm_domain.TransactionalConnection
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBegin *mConnectionMockBegin) Optional() *mConnectionMockBegin <span class="cov0" title="0">{
        mmBegin.optional = true
        return mmBegin
}</span>

// Expect sets up expected params for Connection.Begin
func (mmBegin *mConnectionMockBegin) Expect() *mConnectionMockBegin <span class="cov0" title="0">{
        if mmBegin.mock.funcBegin != nil </span><span class="cov0" title="0">{
                mmBegin.mock.t.Fatalf("ConnectionMock.Begin mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmBegin.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmBegin.defaultExpectation = &amp;ConnectionMockBeginExpectation{}
        }</span>

        <span class="cov0" title="0">return mmBegin</span>
}

// Inspect accepts an inspector function that has same arguments as the Connection.Begin
func (mmBegin *mConnectionMockBegin) Inspect(f func()) *mConnectionMockBegin <span class="cov0" title="0">{
        if mmBegin.mock.inspectFuncBegin != nil </span><span class="cov0" title="0">{
                mmBegin.mock.t.Fatalf("Inspect function is already set for ConnectionMock.Begin")
        }</span>

        <span class="cov0" title="0">mmBegin.mock.inspectFuncBegin = f

        return mmBegin</span>
}

// Return sets up results that will be returned by Connection.Begin
func (mmBegin *mConnectionMockBegin) Return(t1 mm_domain.TransactionalConnection, err error) *ConnectionMock <span class="cov0" title="0">{
        if mmBegin.mock.funcBegin != nil </span><span class="cov0" title="0">{
                mmBegin.mock.t.Fatalf("ConnectionMock.Begin mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmBegin.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmBegin.defaultExpectation = &amp;ConnectionMockBeginExpectation{mock: mmBegin.mock}
        }</span>
        <span class="cov0" title="0">mmBegin.defaultExpectation.results = &amp;ConnectionMockBeginResults{t1, err}
        mmBegin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmBegin.mock</span>
}

// Set uses given function f to mock the Connection.Begin method
func (mmBegin *mConnectionMockBegin) Set(f func() (t1 mm_domain.TransactionalConnection, err error)) *ConnectionMock <span class="cov0" title="0">{
        if mmBegin.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmBegin.mock.t.Fatalf("Default expectation is already set for the Connection.Begin method")
        }</span>

        <span class="cov0" title="0">if len(mmBegin.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmBegin.mock.t.Fatalf("Some expectations are already set for the Connection.Begin method")
        }</span>

        <span class="cov0" title="0">mmBegin.mock.funcBegin = f
        mmBegin.mock.funcBeginOrigin = minimock.CallerInfo(1)
        return mmBegin.mock</span>
}

// Times sets number of times Connection.Begin should be invoked
func (mmBegin *mConnectionMockBegin) Times(n uint64) *mConnectionMockBegin <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmBegin.mock.t.Fatalf("Times of ConnectionMock.Begin mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmBegin.expectedInvocations, n)
        mmBegin.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmBegin</span>
}

func (mmBegin *mConnectionMockBegin) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmBegin.expectations) == 0 &amp;&amp; mmBegin.defaultExpectation == nil &amp;&amp; mmBegin.mock.funcBegin == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmBegin.mock.afterBeginCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmBegin.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Begin implements mm_domain.Connection
func (mmBegin *ConnectionMock) Begin() (t1 mm_domain.TransactionalConnection, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmBegin.beforeBeginCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmBegin.afterBeginCounter, 1)

        mmBegin.t.Helper()

        if mmBegin.inspectFuncBegin != nil </span><span class="cov0" title="0">{
                mmBegin.inspectFuncBegin()
        }</span>

        <span class="cov0" title="0">if mmBegin.BeginMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmBegin.BeginMock.defaultExpectation.Counter, 1)

                mm_results := mmBegin.BeginMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmBegin.t.Fatal("No results are set for the ConnectionMock.Begin")
                }</span>
                <span class="cov0" title="0">return (*mm_results).t1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmBegin.funcBegin != nil </span><span class="cov0" title="0">{
                return mmBegin.funcBegin()
        }</span>
        <span class="cov0" title="0">mmBegin.t.Fatalf("Unexpected call to ConnectionMock.Begin.")
        return</span>
}

// BeginAfterCounter returns a count of finished ConnectionMock.Begin invocations
func (mmBegin *ConnectionMock) BeginAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmBegin.afterBeginCounter)
}</span>

// BeginBeforeCounter returns a count of ConnectionMock.Begin invocations
func (mmBegin *ConnectionMock) BeginBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmBegin.beforeBeginCounter)
}</span>

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockBeginDone() bool <span class="cov8" title="1">{
        if m.BeginMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.BeginMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.BeginMock.invocationsDone()</span>
}

// MinimockBeginInspect logs each unmet expectation
func (m *ConnectionMock) MinimockBeginInspect() <span class="cov0" title="0">{
        for _, e := range m.BeginMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ConnectionMock.Begin")
                }</span>
        }

        <span class="cov0" title="0">afterBeginCounter := mm_atomic.LoadUint64(&amp;m.afterBeginCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.BeginMock.defaultExpectation != nil &amp;&amp; afterBeginCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.Begin at\n%s", m.BeginMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcBegin != nil &amp;&amp; afterBeginCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.Begin at\n%s", m.funcBeginOrigin)
        }</span>

        <span class="cov0" title="0">if !m.BeginMock.invocationsDone() &amp;&amp; afterBeginCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ConnectionMock.Begin at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.BeginMock.expectedInvocations), m.BeginMock.expectedInvocationsOrigin, afterBeginCounter)
        }</span>
}

type mConnectionMockCarRepository struct {
        optional           bool
        mock               *ConnectionMock
        defaultExpectation *ConnectionMockCarRepositoryExpectation
        expectations       []*ConnectionMockCarRepositoryExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ConnectionMockCarRepositoryExpectation specifies expectation struct of the Connection.CarRepository
type ConnectionMockCarRepositoryExpectation struct {
        mock *ConnectionMock

        results      *ConnectionMockCarRepositoryResults
        returnOrigin string
        Counter      uint64
}

// ConnectionMockCarRepositoryResults contains results of the Connection.CarRepository
type ConnectionMockCarRepositoryResults struct {
        c1 repositories.CarRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCarRepository *mConnectionMockCarRepository) Optional() *mConnectionMockCarRepository <span class="cov0" title="0">{
        mmCarRepository.optional = true
        return mmCarRepository
}</span>

// Expect sets up expected params for Connection.CarRepository
func (mmCarRepository *mConnectionMockCarRepository) Expect() *mConnectionMockCarRepository <span class="cov0" title="0">{
        if mmCarRepository.mock.funcCarRepository != nil </span><span class="cov0" title="0">{
                mmCarRepository.mock.t.Fatalf("ConnectionMock.CarRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCarRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCarRepository.defaultExpectation = &amp;ConnectionMockCarRepositoryExpectation{}
        }</span>

        <span class="cov0" title="0">return mmCarRepository</span>
}

// Inspect accepts an inspector function that has same arguments as the Connection.CarRepository
func (mmCarRepository *mConnectionMockCarRepository) Inspect(f func()) *mConnectionMockCarRepository <span class="cov0" title="0">{
        if mmCarRepository.mock.inspectFuncCarRepository != nil </span><span class="cov0" title="0">{
                mmCarRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.CarRepository")
        }</span>

        <span class="cov0" title="0">mmCarRepository.mock.inspectFuncCarRepository = f

        return mmCarRepository</span>
}

// Return sets up results that will be returned by Connection.CarRepository
func (mmCarRepository *mConnectionMockCarRepository) Return(c1 repositories.CarRepository) *ConnectionMock <span class="cov8" title="1">{
        if mmCarRepository.mock.funcCarRepository != nil </span><span class="cov0" title="0">{
                mmCarRepository.mock.t.Fatalf("ConnectionMock.CarRepository mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCarRepository.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmCarRepository.defaultExpectation = &amp;ConnectionMockCarRepositoryExpectation{mock: mmCarRepository.mock}
        }</span>
        <span class="cov8" title="1">mmCarRepository.defaultExpectation.results = &amp;ConnectionMockCarRepositoryResults{c1}
        mmCarRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCarRepository.mock</span>
}

// Set uses given function f to mock the Connection.CarRepository method
func (mmCarRepository *mConnectionMockCarRepository) Set(f func() (c1 repositories.CarRepository)) *ConnectionMock <span class="cov0" title="0">{
        if mmCarRepository.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCarRepository.mock.t.Fatalf("Default expectation is already set for the Connection.CarRepository method")
        }</span>

        <span class="cov0" title="0">if len(mmCarRepository.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCarRepository.mock.t.Fatalf("Some expectations are already set for the Connection.CarRepository method")
        }</span>

        <span class="cov0" title="0">mmCarRepository.mock.funcCarRepository = f
        mmCarRepository.mock.funcCarRepositoryOrigin = minimock.CallerInfo(1)
        return mmCarRepository.mock</span>
}

// Times sets number of times Connection.CarRepository should be invoked
func (mmCarRepository *mConnectionMockCarRepository) Times(n uint64) *mConnectionMockCarRepository <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCarRepository.mock.t.Fatalf("Times of ConnectionMock.CarRepository mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCarRepository.expectedInvocations, n)
        mmCarRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCarRepository</span>
}

func (mmCarRepository *mConnectionMockCarRepository) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmCarRepository.expectations) == 0 &amp;&amp; mmCarRepository.defaultExpectation == nil &amp;&amp; mmCarRepository.mock.funcCarRepository == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmCarRepository.mock.afterCarRepositoryCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCarRepository.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CarRepository implements mm_domain.Connection
func (mmCarRepository *ConnectionMock) CarRepository() (c1 repositories.CarRepository) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmCarRepository.beforeCarRepositoryCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCarRepository.afterCarRepositoryCounter, 1)

        mmCarRepository.t.Helper()

        if mmCarRepository.inspectFuncCarRepository != nil </span><span class="cov0" title="0">{
                mmCarRepository.inspectFuncCarRepository()
        }</span>

        <span class="cov8" title="1">if mmCarRepository.CarRepositoryMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmCarRepository.CarRepositoryMock.defaultExpectation.Counter, 1)

                mm_results := mmCarRepository.CarRepositoryMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCarRepository.t.Fatal("No results are set for the ConnectionMock.CarRepository")
                }</span>
                <span class="cov8" title="1">return (*mm_results).c1</span>
        }
        <span class="cov0" title="0">if mmCarRepository.funcCarRepository != nil </span><span class="cov0" title="0">{
                return mmCarRepository.funcCarRepository()
        }</span>
        <span class="cov0" title="0">mmCarRepository.t.Fatalf("Unexpected call to ConnectionMock.CarRepository.")
        return</span>
}

// CarRepositoryAfterCounter returns a count of finished ConnectionMock.CarRepository invocations
func (mmCarRepository *ConnectionMock) CarRepositoryAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCarRepository.afterCarRepositoryCounter)
}</span>

// CarRepositoryBeforeCounter returns a count of ConnectionMock.CarRepository invocations
func (mmCarRepository *ConnectionMock) CarRepositoryBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCarRepository.beforeCarRepositoryCounter)
}</span>

// MinimockCarRepositoryDone returns true if the count of the CarRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockCarRepositoryDone() bool <span class="cov8" title="1">{
        if m.CarRepositoryMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.CarRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.CarRepositoryMock.invocationsDone()</span>
}

// MinimockCarRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockCarRepositoryInspect() <span class="cov0" title="0">{
        for _, e := range m.CarRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ConnectionMock.CarRepository")
                }</span>
        }

        <span class="cov0" title="0">afterCarRepositoryCounter := mm_atomic.LoadUint64(&amp;m.afterCarRepositoryCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CarRepositoryMock.defaultExpectation != nil &amp;&amp; afterCarRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.CarRepository at\n%s", m.CarRepositoryMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCarRepository != nil &amp;&amp; afterCarRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.CarRepository at\n%s", m.funcCarRepositoryOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CarRepositoryMock.invocationsDone() &amp;&amp; afterCarRepositoryCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ConnectionMock.CarRepository at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CarRepositoryMock.expectedInvocations), m.CarRepositoryMock.expectedInvocationsOrigin, afterCarRepositoryCounter)
        }</span>
}

type mConnectionMockDB struct {
        optional           bool
        mock               *ConnectionMock
        defaultExpectation *ConnectionMockDBExpectation
        expectations       []*ConnectionMockDBExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ConnectionMockDBExpectation specifies expectation struct of the Connection.DB
type ConnectionMockDBExpectation struct {
        mock *ConnectionMock

        results      *ConnectionMockDBResults
        returnOrigin string
        Counter      uint64
}

// ConnectionMockDBResults contains results of the Connection.DB
type ConnectionMockDBResults struct {
        dp1 *gorm.DB
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDB *mConnectionMockDB) Optional() *mConnectionMockDB <span class="cov0" title="0">{
        mmDB.optional = true
        return mmDB
}</span>

// Expect sets up expected params for Connection.DB
func (mmDB *mConnectionMockDB) Expect() *mConnectionMockDB <span class="cov0" title="0">{
        if mmDB.mock.funcDB != nil </span><span class="cov0" title="0">{
                mmDB.mock.t.Fatalf("ConnectionMock.DB mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDB.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDB.defaultExpectation = &amp;ConnectionMockDBExpectation{}
        }</span>

        <span class="cov0" title="0">return mmDB</span>
}

// Inspect accepts an inspector function that has same arguments as the Connection.DB
func (mmDB *mConnectionMockDB) Inspect(f func()) *mConnectionMockDB <span class="cov0" title="0">{
        if mmDB.mock.inspectFuncDB != nil </span><span class="cov0" title="0">{
                mmDB.mock.t.Fatalf("Inspect function is already set for ConnectionMock.DB")
        }</span>

        <span class="cov0" title="0">mmDB.mock.inspectFuncDB = f

        return mmDB</span>
}

// Return sets up results that will be returned by Connection.DB
func (mmDB *mConnectionMockDB) Return(dp1 *gorm.DB) *ConnectionMock <span class="cov0" title="0">{
        if mmDB.mock.funcDB != nil </span><span class="cov0" title="0">{
                mmDB.mock.t.Fatalf("ConnectionMock.DB mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDB.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDB.defaultExpectation = &amp;ConnectionMockDBExpectation{mock: mmDB.mock}
        }</span>
        <span class="cov0" title="0">mmDB.defaultExpectation.results = &amp;ConnectionMockDBResults{dp1}
        mmDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmDB.mock</span>
}

// Set uses given function f to mock the Connection.DB method
func (mmDB *mConnectionMockDB) Set(f func() (dp1 *gorm.DB)) *ConnectionMock <span class="cov0" title="0">{
        if mmDB.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDB.mock.t.Fatalf("Default expectation is already set for the Connection.DB method")
        }</span>

        <span class="cov0" title="0">if len(mmDB.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDB.mock.t.Fatalf("Some expectations are already set for the Connection.DB method")
        }</span>

        <span class="cov0" title="0">mmDB.mock.funcDB = f
        mmDB.mock.funcDBOrigin = minimock.CallerInfo(1)
        return mmDB.mock</span>
}

// Times sets number of times Connection.DB should be invoked
func (mmDB *mConnectionMockDB) Times(n uint64) *mConnectionMockDB <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDB.mock.t.Fatalf("Times of ConnectionMock.DB mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDB.expectedInvocations, n)
        mmDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmDB</span>
}

func (mmDB *mConnectionMockDB) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmDB.expectations) == 0 &amp;&amp; mmDB.defaultExpectation == nil &amp;&amp; mmDB.mock.funcDB == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmDB.mock.afterDBCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDB.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DB implements mm_domain.Connection
func (mmDB *ConnectionMock) DB() (dp1 *gorm.DB) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmDB.beforeDBCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDB.afterDBCounter, 1)

        mmDB.t.Helper()

        if mmDB.inspectFuncDB != nil </span><span class="cov0" title="0">{
                mmDB.inspectFuncDB()
        }</span>

        <span class="cov0" title="0">if mmDB.DBMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmDB.DBMock.defaultExpectation.Counter, 1)

                mm_results := mmDB.DBMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDB.t.Fatal("No results are set for the ConnectionMock.DB")
                }</span>
                <span class="cov0" title="0">return (*mm_results).dp1</span>
        }
        <span class="cov0" title="0">if mmDB.funcDB != nil </span><span class="cov0" title="0">{
                return mmDB.funcDB()
        }</span>
        <span class="cov0" title="0">mmDB.t.Fatalf("Unexpected call to ConnectionMock.DB.")
        return</span>
}

// DBAfterCounter returns a count of finished ConnectionMock.DB invocations
func (mmDB *ConnectionMock) DBAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDB.afterDBCounter)
}</span>

// DBBeforeCounter returns a count of ConnectionMock.DB invocations
func (mmDB *ConnectionMock) DBBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDB.beforeDBCounter)
}</span>

// MinimockDBDone returns true if the count of the DB invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockDBDone() bool <span class="cov8" title="1">{
        if m.DBMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.DBMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.DBMock.invocationsDone()</span>
}

// MinimockDBInspect logs each unmet expectation
func (m *ConnectionMock) MinimockDBInspect() <span class="cov0" title="0">{
        for _, e := range m.DBMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ConnectionMock.DB")
                }</span>
        }

        <span class="cov0" title="0">afterDBCounter := mm_atomic.LoadUint64(&amp;m.afterDBCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DBMock.defaultExpectation != nil &amp;&amp; afterDBCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.DB at\n%s", m.DBMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDB != nil &amp;&amp; afterDBCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.DB at\n%s", m.funcDBOrigin)
        }</span>

        <span class="cov0" title="0">if !m.DBMock.invocationsDone() &amp;&amp; afterDBCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ConnectionMock.DB at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DBMock.expectedInvocations), m.DBMock.expectedInvocationsOrigin, afterDBCounter)
        }</span>
}

type mConnectionMockParkingRepository struct {
        optional           bool
        mock               *ConnectionMock
        defaultExpectation *ConnectionMockParkingRepositoryExpectation
        expectations       []*ConnectionMockParkingRepositoryExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ConnectionMockParkingRepositoryExpectation specifies expectation struct of the Connection.ParkingRepository
type ConnectionMockParkingRepositoryExpectation struct {
        mock *ConnectionMock

        results      *ConnectionMockParkingRepositoryResults
        returnOrigin string
        Counter      uint64
}

// ConnectionMockParkingRepositoryResults contains results of the Connection.ParkingRepository
type ConnectionMockParkingRepositoryResults struct {
        p1 repositories.ParkingRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmParkingRepository *mConnectionMockParkingRepository) Optional() *mConnectionMockParkingRepository <span class="cov0" title="0">{
        mmParkingRepository.optional = true
        return mmParkingRepository
}</span>

// Expect sets up expected params for Connection.ParkingRepository
func (mmParkingRepository *mConnectionMockParkingRepository) Expect() *mConnectionMockParkingRepository <span class="cov0" title="0">{
        if mmParkingRepository.mock.funcParkingRepository != nil </span><span class="cov0" title="0">{
                mmParkingRepository.mock.t.Fatalf("ConnectionMock.ParkingRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmParkingRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmParkingRepository.defaultExpectation = &amp;ConnectionMockParkingRepositoryExpectation{}
        }</span>

        <span class="cov0" title="0">return mmParkingRepository</span>
}

// Inspect accepts an inspector function that has same arguments as the Connection.ParkingRepository
func (mmParkingRepository *mConnectionMockParkingRepository) Inspect(f func()) *mConnectionMockParkingRepository <span class="cov0" title="0">{
        if mmParkingRepository.mock.inspectFuncParkingRepository != nil </span><span class="cov0" title="0">{
                mmParkingRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.ParkingRepository")
        }</span>

        <span class="cov0" title="0">mmParkingRepository.mock.inspectFuncParkingRepository = f

        return mmParkingRepository</span>
}

// Return sets up results that will be returned by Connection.ParkingRepository
func (mmParkingRepository *mConnectionMockParkingRepository) Return(p1 repositories.ParkingRepository) *ConnectionMock <span class="cov0" title="0">{
        if mmParkingRepository.mock.funcParkingRepository != nil </span><span class="cov0" title="0">{
                mmParkingRepository.mock.t.Fatalf("ConnectionMock.ParkingRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmParkingRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmParkingRepository.defaultExpectation = &amp;ConnectionMockParkingRepositoryExpectation{mock: mmParkingRepository.mock}
        }</span>
        <span class="cov0" title="0">mmParkingRepository.defaultExpectation.results = &amp;ConnectionMockParkingRepositoryResults{p1}
        mmParkingRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmParkingRepository.mock</span>
}

// Set uses given function f to mock the Connection.ParkingRepository method
func (mmParkingRepository *mConnectionMockParkingRepository) Set(f func() (p1 repositories.ParkingRepository)) *ConnectionMock <span class="cov0" title="0">{
        if mmParkingRepository.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmParkingRepository.mock.t.Fatalf("Default expectation is already set for the Connection.ParkingRepository method")
        }</span>

        <span class="cov0" title="0">if len(mmParkingRepository.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmParkingRepository.mock.t.Fatalf("Some expectations are already set for the Connection.ParkingRepository method")
        }</span>

        <span class="cov0" title="0">mmParkingRepository.mock.funcParkingRepository = f
        mmParkingRepository.mock.funcParkingRepositoryOrigin = minimock.CallerInfo(1)
        return mmParkingRepository.mock</span>
}

// Times sets number of times Connection.ParkingRepository should be invoked
func (mmParkingRepository *mConnectionMockParkingRepository) Times(n uint64) *mConnectionMockParkingRepository <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmParkingRepository.mock.t.Fatalf("Times of ConnectionMock.ParkingRepository mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmParkingRepository.expectedInvocations, n)
        mmParkingRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmParkingRepository</span>
}

func (mmParkingRepository *mConnectionMockParkingRepository) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmParkingRepository.expectations) == 0 &amp;&amp; mmParkingRepository.defaultExpectation == nil &amp;&amp; mmParkingRepository.mock.funcParkingRepository == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmParkingRepository.mock.afterParkingRepositoryCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmParkingRepository.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ParkingRepository implements mm_domain.Connection
func (mmParkingRepository *ConnectionMock) ParkingRepository() (p1 repositories.ParkingRepository) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmParkingRepository.beforeParkingRepositoryCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmParkingRepository.afterParkingRepositoryCounter, 1)

        mmParkingRepository.t.Helper()

        if mmParkingRepository.inspectFuncParkingRepository != nil </span><span class="cov0" title="0">{
                mmParkingRepository.inspectFuncParkingRepository()
        }</span>

        <span class="cov0" title="0">if mmParkingRepository.ParkingRepositoryMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmParkingRepository.ParkingRepositoryMock.defaultExpectation.Counter, 1)

                mm_results := mmParkingRepository.ParkingRepositoryMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmParkingRepository.t.Fatal("No results are set for the ConnectionMock.ParkingRepository")
                }</span>
                <span class="cov0" title="0">return (*mm_results).p1</span>
        }
        <span class="cov0" title="0">if mmParkingRepository.funcParkingRepository != nil </span><span class="cov0" title="0">{
                return mmParkingRepository.funcParkingRepository()
        }</span>
        <span class="cov0" title="0">mmParkingRepository.t.Fatalf("Unexpected call to ConnectionMock.ParkingRepository.")
        return</span>
}

// ParkingRepositoryAfterCounter returns a count of finished ConnectionMock.ParkingRepository invocations
func (mmParkingRepository *ConnectionMock) ParkingRepositoryAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmParkingRepository.afterParkingRepositoryCounter)
}</span>

// ParkingRepositoryBeforeCounter returns a count of ConnectionMock.ParkingRepository invocations
func (mmParkingRepository *ConnectionMock) ParkingRepositoryBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmParkingRepository.beforeParkingRepositoryCounter)
}</span>

// MinimockParkingRepositoryDone returns true if the count of the ParkingRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockParkingRepositoryDone() bool <span class="cov8" title="1">{
        if m.ParkingRepositoryMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.ParkingRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.ParkingRepositoryMock.invocationsDone()</span>
}

// MinimockParkingRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockParkingRepositoryInspect() <span class="cov0" title="0">{
        for _, e := range m.ParkingRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ConnectionMock.ParkingRepository")
                }</span>
        }

        <span class="cov0" title="0">afterParkingRepositoryCounter := mm_atomic.LoadUint64(&amp;m.afterParkingRepositoryCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ParkingRepositoryMock.defaultExpectation != nil &amp;&amp; afterParkingRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.ParkingRepository at\n%s", m.ParkingRepositoryMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcParkingRepository != nil &amp;&amp; afterParkingRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.ParkingRepository at\n%s", m.funcParkingRepositoryOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ParkingRepositoryMock.invocationsDone() &amp;&amp; afterParkingRepositoryCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ConnectionMock.ParkingRepository at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ParkingRepositoryMock.expectedInvocations), m.ParkingRepositoryMock.expectedInvocationsOrigin, afterParkingRepositoryCounter)
        }</span>
}

type mConnectionMockSessionRepository struct {
        optional           bool
        mock               *ConnectionMock
        defaultExpectation *ConnectionMockSessionRepositoryExpectation
        expectations       []*ConnectionMockSessionRepositoryExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ConnectionMockSessionRepositoryExpectation specifies expectation struct of the Connection.SessionRepository
type ConnectionMockSessionRepositoryExpectation struct {
        mock *ConnectionMock

        results      *ConnectionMockSessionRepositoryResults
        returnOrigin string
        Counter      uint64
}

// ConnectionMockSessionRepositoryResults contains results of the Connection.SessionRepository
type ConnectionMockSessionRepositoryResults struct {
        s1 repositories.SessionRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSessionRepository *mConnectionMockSessionRepository) Optional() *mConnectionMockSessionRepository <span class="cov0" title="0">{
        mmSessionRepository.optional = true
        return mmSessionRepository
}</span>

// Expect sets up expected params for Connection.SessionRepository
func (mmSessionRepository *mConnectionMockSessionRepository) Expect() *mConnectionMockSessionRepository <span class="cov0" title="0">{
        if mmSessionRepository.mock.funcSessionRepository != nil </span><span class="cov0" title="0">{
                mmSessionRepository.mock.t.Fatalf("ConnectionMock.SessionRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSessionRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSessionRepository.defaultExpectation = &amp;ConnectionMockSessionRepositoryExpectation{}
        }</span>

        <span class="cov0" title="0">return mmSessionRepository</span>
}

// Inspect accepts an inspector function that has same arguments as the Connection.SessionRepository
func (mmSessionRepository *mConnectionMockSessionRepository) Inspect(f func()) *mConnectionMockSessionRepository <span class="cov0" title="0">{
        if mmSessionRepository.mock.inspectFuncSessionRepository != nil </span><span class="cov0" title="0">{
                mmSessionRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.SessionRepository")
        }</span>

        <span class="cov0" title="0">mmSessionRepository.mock.inspectFuncSessionRepository = f

        return mmSessionRepository</span>
}

// Return sets up results that will be returned by Connection.SessionRepository
func (mmSessionRepository *mConnectionMockSessionRepository) Return(s1 repositories.SessionRepository) *ConnectionMock <span class="cov0" title="0">{
        if mmSessionRepository.mock.funcSessionRepository != nil </span><span class="cov0" title="0">{
                mmSessionRepository.mock.t.Fatalf("ConnectionMock.SessionRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSessionRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSessionRepository.defaultExpectation = &amp;ConnectionMockSessionRepositoryExpectation{mock: mmSessionRepository.mock}
        }</span>
        <span class="cov0" title="0">mmSessionRepository.defaultExpectation.results = &amp;ConnectionMockSessionRepositoryResults{s1}
        mmSessionRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmSessionRepository.mock</span>
}

// Set uses given function f to mock the Connection.SessionRepository method
func (mmSessionRepository *mConnectionMockSessionRepository) Set(f func() (s1 repositories.SessionRepository)) *ConnectionMock <span class="cov0" title="0">{
        if mmSessionRepository.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSessionRepository.mock.t.Fatalf("Default expectation is already set for the Connection.SessionRepository method")
        }</span>

        <span class="cov0" title="0">if len(mmSessionRepository.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSessionRepository.mock.t.Fatalf("Some expectations are already set for the Connection.SessionRepository method")
        }</span>

        <span class="cov0" title="0">mmSessionRepository.mock.funcSessionRepository = f
        mmSessionRepository.mock.funcSessionRepositoryOrigin = minimock.CallerInfo(1)
        return mmSessionRepository.mock</span>
}

// Times sets number of times Connection.SessionRepository should be invoked
func (mmSessionRepository *mConnectionMockSessionRepository) Times(n uint64) *mConnectionMockSessionRepository <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSessionRepository.mock.t.Fatalf("Times of ConnectionMock.SessionRepository mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSessionRepository.expectedInvocations, n)
        mmSessionRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmSessionRepository</span>
}

func (mmSessionRepository *mConnectionMockSessionRepository) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmSessionRepository.expectations) == 0 &amp;&amp; mmSessionRepository.defaultExpectation == nil &amp;&amp; mmSessionRepository.mock.funcSessionRepository == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmSessionRepository.mock.afterSessionRepositoryCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSessionRepository.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// SessionRepository implements mm_domain.Connection
func (mmSessionRepository *ConnectionMock) SessionRepository() (s1 repositories.SessionRepository) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmSessionRepository.beforeSessionRepositoryCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSessionRepository.afterSessionRepositoryCounter, 1)

        mmSessionRepository.t.Helper()

        if mmSessionRepository.inspectFuncSessionRepository != nil </span><span class="cov0" title="0">{
                mmSessionRepository.inspectFuncSessionRepository()
        }</span>

        <span class="cov0" title="0">if mmSessionRepository.SessionRepositoryMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmSessionRepository.SessionRepositoryMock.defaultExpectation.Counter, 1)

                mm_results := mmSessionRepository.SessionRepositoryMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSessionRepository.t.Fatal("No results are set for the ConnectionMock.SessionRepository")
                }</span>
                <span class="cov0" title="0">return (*mm_results).s1</span>
        }
        <span class="cov0" title="0">if mmSessionRepository.funcSessionRepository != nil </span><span class="cov0" title="0">{
                return mmSessionRepository.funcSessionRepository()
        }</span>
        <span class="cov0" title="0">mmSessionRepository.t.Fatalf("Unexpected call to ConnectionMock.SessionRepository.")
        return</span>
}

// SessionRepositoryAfterCounter returns a count of finished ConnectionMock.SessionRepository invocations
func (mmSessionRepository *ConnectionMock) SessionRepositoryAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSessionRepository.afterSessionRepositoryCounter)
}</span>

// SessionRepositoryBeforeCounter returns a count of ConnectionMock.SessionRepository invocations
func (mmSessionRepository *ConnectionMock) SessionRepositoryBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSessionRepository.beforeSessionRepositoryCounter)
}</span>

// MinimockSessionRepositoryDone returns true if the count of the SessionRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockSessionRepositoryDone() bool <span class="cov8" title="1">{
        if m.SessionRepositoryMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.SessionRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.SessionRepositoryMock.invocationsDone()</span>
}

// MinimockSessionRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockSessionRepositoryInspect() <span class="cov0" title="0">{
        for _, e := range m.SessionRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ConnectionMock.SessionRepository")
                }</span>
        }

        <span class="cov0" title="0">afterSessionRepositoryCounter := mm_atomic.LoadUint64(&amp;m.afterSessionRepositoryCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SessionRepositoryMock.defaultExpectation != nil &amp;&amp; afterSessionRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.SessionRepository at\n%s", m.SessionRepositoryMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSessionRepository != nil &amp;&amp; afterSessionRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.SessionRepository at\n%s", m.funcSessionRepositoryOrigin)
        }</span>

        <span class="cov0" title="0">if !m.SessionRepositoryMock.invocationsDone() &amp;&amp; afterSessionRepositoryCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ConnectionMock.SessionRepository at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SessionRepositoryMock.expectedInvocations), m.SessionRepositoryMock.expectedInvocationsOrigin, afterSessionRepositoryCounter)
        }</span>
}

type mConnectionMockTariffRepository struct {
        optional           bool
        mock               *ConnectionMock
        defaultExpectation *ConnectionMockTariffRepositoryExpectation
        expectations       []*ConnectionMockTariffRepositoryExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ConnectionMockTariffRepositoryExpectation specifies expectation struct of the Connection.TariffRepository
type ConnectionMockTariffRepositoryExpectation struct {
        mock *ConnectionMock

        results      *ConnectionMockTariffRepositoryResults
        returnOrigin string
        Counter      uint64
}

// ConnectionMockTariffRepositoryResults contains results of the Connection.TariffRepository
type ConnectionMockTariffRepositoryResults struct {
        t1 repositories.TariffRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTariffRepository *mConnectionMockTariffRepository) Optional() *mConnectionMockTariffRepository <span class="cov0" title="0">{
        mmTariffRepository.optional = true
        return mmTariffRepository
}</span>

// Expect sets up expected params for Connection.TariffRepository
func (mmTariffRepository *mConnectionMockTariffRepository) Expect() *mConnectionMockTariffRepository <span class="cov0" title="0">{
        if mmTariffRepository.mock.funcTariffRepository != nil </span><span class="cov0" title="0">{
                mmTariffRepository.mock.t.Fatalf("ConnectionMock.TariffRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmTariffRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmTariffRepository.defaultExpectation = &amp;ConnectionMockTariffRepositoryExpectation{}
        }</span>

        <span class="cov0" title="0">return mmTariffRepository</span>
}

// Inspect accepts an inspector function that has same arguments as the Connection.TariffRepository
func (mmTariffRepository *mConnectionMockTariffRepository) Inspect(f func()) *mConnectionMockTariffRepository <span class="cov0" title="0">{
        if mmTariffRepository.mock.inspectFuncTariffRepository != nil </span><span class="cov0" title="0">{
                mmTariffRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.TariffRepository")
        }</span>

        <span class="cov0" title="0">mmTariffRepository.mock.inspectFuncTariffRepository = f

        return mmTariffRepository</span>
}

// Return sets up results that will be returned by Connection.TariffRepository
func (mmTariffRepository *mConnectionMockTariffRepository) Return(t1 repositories.TariffRepository) *ConnectionMock <span class="cov0" title="0">{
        if mmTariffRepository.mock.funcTariffRepository != nil </span><span class="cov0" title="0">{
                mmTariffRepository.mock.t.Fatalf("ConnectionMock.TariffRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmTariffRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmTariffRepository.defaultExpectation = &amp;ConnectionMockTariffRepositoryExpectation{mock: mmTariffRepository.mock}
        }</span>
        <span class="cov0" title="0">mmTariffRepository.defaultExpectation.results = &amp;ConnectionMockTariffRepositoryResults{t1}
        mmTariffRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmTariffRepository.mock</span>
}

// Set uses given function f to mock the Connection.TariffRepository method
func (mmTariffRepository *mConnectionMockTariffRepository) Set(f func() (t1 repositories.TariffRepository)) *ConnectionMock <span class="cov0" title="0">{
        if mmTariffRepository.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmTariffRepository.mock.t.Fatalf("Default expectation is already set for the Connection.TariffRepository method")
        }</span>

        <span class="cov0" title="0">if len(mmTariffRepository.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmTariffRepository.mock.t.Fatalf("Some expectations are already set for the Connection.TariffRepository method")
        }</span>

        <span class="cov0" title="0">mmTariffRepository.mock.funcTariffRepository = f
        mmTariffRepository.mock.funcTariffRepositoryOrigin = minimock.CallerInfo(1)
        return mmTariffRepository.mock</span>
}

// Times sets number of times Connection.TariffRepository should be invoked
func (mmTariffRepository *mConnectionMockTariffRepository) Times(n uint64) *mConnectionMockTariffRepository <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmTariffRepository.mock.t.Fatalf("Times of ConnectionMock.TariffRepository mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmTariffRepository.expectedInvocations, n)
        mmTariffRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmTariffRepository</span>
}

func (mmTariffRepository *mConnectionMockTariffRepository) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmTariffRepository.expectations) == 0 &amp;&amp; mmTariffRepository.defaultExpectation == nil &amp;&amp; mmTariffRepository.mock.funcTariffRepository == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmTariffRepository.mock.afterTariffRepositoryCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmTariffRepository.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// TariffRepository implements mm_domain.Connection
func (mmTariffRepository *ConnectionMock) TariffRepository() (t1 repositories.TariffRepository) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmTariffRepository.beforeTariffRepositoryCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmTariffRepository.afterTariffRepositoryCounter, 1)

        mmTariffRepository.t.Helper()

        if mmTariffRepository.inspectFuncTariffRepository != nil </span><span class="cov0" title="0">{
                mmTariffRepository.inspectFuncTariffRepository()
        }</span>

        <span class="cov0" title="0">if mmTariffRepository.TariffRepositoryMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmTariffRepository.TariffRepositoryMock.defaultExpectation.Counter, 1)

                mm_results := mmTariffRepository.TariffRepositoryMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmTariffRepository.t.Fatal("No results are set for the ConnectionMock.TariffRepository")
                }</span>
                <span class="cov0" title="0">return (*mm_results).t1</span>
        }
        <span class="cov0" title="0">if mmTariffRepository.funcTariffRepository != nil </span><span class="cov0" title="0">{
                return mmTariffRepository.funcTariffRepository()
        }</span>
        <span class="cov0" title="0">mmTariffRepository.t.Fatalf("Unexpected call to ConnectionMock.TariffRepository.")
        return</span>
}

// TariffRepositoryAfterCounter returns a count of finished ConnectionMock.TariffRepository invocations
func (mmTariffRepository *ConnectionMock) TariffRepositoryAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmTariffRepository.afterTariffRepositoryCounter)
}</span>

// TariffRepositoryBeforeCounter returns a count of ConnectionMock.TariffRepository invocations
func (mmTariffRepository *ConnectionMock) TariffRepositoryBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmTariffRepository.beforeTariffRepositoryCounter)
}</span>

// MinimockTariffRepositoryDone returns true if the count of the TariffRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockTariffRepositoryDone() bool <span class="cov8" title="1">{
        if m.TariffRepositoryMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.TariffRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.TariffRepositoryMock.invocationsDone()</span>
}

// MinimockTariffRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockTariffRepositoryInspect() <span class="cov0" title="0">{
        for _, e := range m.TariffRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ConnectionMock.TariffRepository")
                }</span>
        }

        <span class="cov0" title="0">afterTariffRepositoryCounter := mm_atomic.LoadUint64(&amp;m.afterTariffRepositoryCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.TariffRepositoryMock.defaultExpectation != nil &amp;&amp; afterTariffRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.TariffRepository at\n%s", m.TariffRepositoryMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcTariffRepository != nil &amp;&amp; afterTariffRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.TariffRepository at\n%s", m.funcTariffRepositoryOrigin)
        }</span>

        <span class="cov0" title="0">if !m.TariffRepositoryMock.invocationsDone() &amp;&amp; afterTariffRepositoryCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ConnectionMock.TariffRepository at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.TariffRepositoryMock.expectedInvocations), m.TariffRepositoryMock.expectedInvocationsOrigin, afterTariffRepositoryCounter)
        }</span>
}

type mConnectionMockUnitRepository struct {
        optional           bool
        mock               *ConnectionMock
        defaultExpectation *ConnectionMockUnitRepositoryExpectation
        expectations       []*ConnectionMockUnitRepositoryExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ConnectionMockUnitRepositoryExpectation specifies expectation struct of the Connection.UnitRepository
type ConnectionMockUnitRepositoryExpectation struct {
        mock *ConnectionMock

        results      *ConnectionMockUnitRepositoryResults
        returnOrigin string
        Counter      uint64
}

// ConnectionMockUnitRepositoryResults contains results of the Connection.UnitRepository
type ConnectionMockUnitRepositoryResults struct {
        u1 repositories.UnitRepository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUnitRepository *mConnectionMockUnitRepository) Optional() *mConnectionMockUnitRepository <span class="cov0" title="0">{
        mmUnitRepository.optional = true
        return mmUnitRepository
}</span>

// Expect sets up expected params for Connection.UnitRepository
func (mmUnitRepository *mConnectionMockUnitRepository) Expect() *mConnectionMockUnitRepository <span class="cov0" title="0">{
        if mmUnitRepository.mock.funcUnitRepository != nil </span><span class="cov0" title="0">{
                mmUnitRepository.mock.t.Fatalf("ConnectionMock.UnitRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUnitRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUnitRepository.defaultExpectation = &amp;ConnectionMockUnitRepositoryExpectation{}
        }</span>

        <span class="cov0" title="0">return mmUnitRepository</span>
}

// Inspect accepts an inspector function that has same arguments as the Connection.UnitRepository
func (mmUnitRepository *mConnectionMockUnitRepository) Inspect(f func()) *mConnectionMockUnitRepository <span class="cov0" title="0">{
        if mmUnitRepository.mock.inspectFuncUnitRepository != nil </span><span class="cov0" title="0">{
                mmUnitRepository.mock.t.Fatalf("Inspect function is already set for ConnectionMock.UnitRepository")
        }</span>

        <span class="cov0" title="0">mmUnitRepository.mock.inspectFuncUnitRepository = f

        return mmUnitRepository</span>
}

// Return sets up results that will be returned by Connection.UnitRepository
func (mmUnitRepository *mConnectionMockUnitRepository) Return(u1 repositories.UnitRepository) *ConnectionMock <span class="cov0" title="0">{
        if mmUnitRepository.mock.funcUnitRepository != nil </span><span class="cov0" title="0">{
                mmUnitRepository.mock.t.Fatalf("ConnectionMock.UnitRepository mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUnitRepository.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUnitRepository.defaultExpectation = &amp;ConnectionMockUnitRepositoryExpectation{mock: mmUnitRepository.mock}
        }</span>
        <span class="cov0" title="0">mmUnitRepository.defaultExpectation.results = &amp;ConnectionMockUnitRepositoryResults{u1}
        mmUnitRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUnitRepository.mock</span>
}

// Set uses given function f to mock the Connection.UnitRepository method
func (mmUnitRepository *mConnectionMockUnitRepository) Set(f func() (u1 repositories.UnitRepository)) *ConnectionMock <span class="cov0" title="0">{
        if mmUnitRepository.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUnitRepository.mock.t.Fatalf("Default expectation is already set for the Connection.UnitRepository method")
        }</span>

        <span class="cov0" title="0">if len(mmUnitRepository.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUnitRepository.mock.t.Fatalf("Some expectations are already set for the Connection.UnitRepository method")
        }</span>

        <span class="cov0" title="0">mmUnitRepository.mock.funcUnitRepository = f
        mmUnitRepository.mock.funcUnitRepositoryOrigin = minimock.CallerInfo(1)
        return mmUnitRepository.mock</span>
}

// Times sets number of times Connection.UnitRepository should be invoked
func (mmUnitRepository *mConnectionMockUnitRepository) Times(n uint64) *mConnectionMockUnitRepository <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUnitRepository.mock.t.Fatalf("Times of ConnectionMock.UnitRepository mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUnitRepository.expectedInvocations, n)
        mmUnitRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUnitRepository</span>
}

func (mmUnitRepository *mConnectionMockUnitRepository) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmUnitRepository.expectations) == 0 &amp;&amp; mmUnitRepository.defaultExpectation == nil &amp;&amp; mmUnitRepository.mock.funcUnitRepository == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUnitRepository.mock.afterUnitRepositoryCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUnitRepository.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// UnitRepository implements mm_domain.Connection
func (mmUnitRepository *ConnectionMock) UnitRepository() (u1 repositories.UnitRepository) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUnitRepository.beforeUnitRepositoryCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUnitRepository.afterUnitRepositoryCounter, 1)

        mmUnitRepository.t.Helper()

        if mmUnitRepository.inspectFuncUnitRepository != nil </span><span class="cov0" title="0">{
                mmUnitRepository.inspectFuncUnitRepository()
        }</span>

        <span class="cov0" title="0">if mmUnitRepository.UnitRepositoryMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUnitRepository.UnitRepositoryMock.defaultExpectation.Counter, 1)

                mm_results := mmUnitRepository.UnitRepositoryMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUnitRepository.t.Fatal("No results are set for the ConnectionMock.UnitRepository")
                }</span>
                <span class="cov0" title="0">return (*mm_results).u1</span>
        }
        <span class="cov0" title="0">if mmUnitRepository.funcUnitRepository != nil </span><span class="cov0" title="0">{
                return mmUnitRepository.funcUnitRepository()
        }</span>
        <span class="cov0" title="0">mmUnitRepository.t.Fatalf("Unexpected call to ConnectionMock.UnitRepository.")
        return</span>
}

// UnitRepositoryAfterCounter returns a count of finished ConnectionMock.UnitRepository invocations
func (mmUnitRepository *ConnectionMock) UnitRepositoryAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUnitRepository.afterUnitRepositoryCounter)
}</span>

// UnitRepositoryBeforeCounter returns a count of ConnectionMock.UnitRepository invocations
func (mmUnitRepository *ConnectionMock) UnitRepositoryBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUnitRepository.beforeUnitRepositoryCounter)
}</span>

// MinimockUnitRepositoryDone returns true if the count of the UnitRepository invocations corresponds
// the number of defined expectations
func (m *ConnectionMock) MinimockUnitRepositoryDone() bool <span class="cov8" title="1">{
        if m.UnitRepositoryMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.UnitRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.UnitRepositoryMock.invocationsDone()</span>
}

// MinimockUnitRepositoryInspect logs each unmet expectation
func (m *ConnectionMock) MinimockUnitRepositoryInspect() <span class="cov0" title="0">{
        for _, e := range m.UnitRepositoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ConnectionMock.UnitRepository")
                }</span>
        }

        <span class="cov0" title="0">afterUnitRepositoryCounter := mm_atomic.LoadUint64(&amp;m.afterUnitRepositoryCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UnitRepositoryMock.defaultExpectation != nil &amp;&amp; afterUnitRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.UnitRepository at\n%s", m.UnitRepositoryMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUnitRepository != nil &amp;&amp; afterUnitRepositoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ConnectionMock.UnitRepository at\n%s", m.funcUnitRepositoryOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UnitRepositoryMock.invocationsDone() &amp;&amp; afterUnitRepositoryCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ConnectionMock.UnitRepository at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UnitRepositoryMock.expectedInvocations), m.UnitRepositoryMock.expectedInvocationsOrigin, afterUnitRepositoryCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConnectionMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockBeginInspect()

                        m.MinimockCarRepositoryInspect()

                        m.MinimockDBInspect()

                        m.MinimockParkingRepositoryInspect()

                        m.MinimockSessionRepositoryInspect()

                        m.MinimockTariffRepositoryInspect()

                        m.MinimockUnitRepositoryInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConnectionMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ConnectionMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockBeginDone() &amp;&amp;
                m.MinimockCarRepositoryDone() &amp;&amp;
                m.MinimockDBDone() &amp;&amp;
                m.MinimockParkingRepositoryDone() &amp;&amp;
                m.MinimockSessionRepositoryDone() &amp;&amp;
                m.MinimockTariffRepositoryDone() &amp;&amp;
                m.MinimockUnitRepositoryDone()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain.Context -o context_mock_test.go -n ContextMock -p mocks

import (
        mm_domain "k071123/internal/services/parking_service/domain"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// ContextMock implements mm_domain.Context
type ContextMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcConnection          func() (c1 mm_domain.Connection)
        funcConnectionOrigin    string
        inspectFuncConnection   func()
        afterConnectionCounter  uint64
        beforeConnectionCounter uint64
        ConnectionMock          mContextMockConnection

        funcMake          func() (c1 mm_domain.Context)
        funcMakeOrigin    string
        inspectFuncMake   func()
        afterMakeCounter  uint64
        beforeMakeCounter uint64
        MakeMock          mContextMockMake

        funcServices          func() (s1 mm_domain.Services)
        funcServicesOrigin    string
        inspectFuncServices   func()
        afterServicesCounter  uint64
        beforeServicesCounter uint64
        ServicesMock          mContextMockServices
}

// NewContextMock returns a mock for mm_domain.Context
func NewContextMock(t minimock.Tester) *ContextMock <span class="cov8" title="1">{
        m := &amp;ContextMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.ConnectionMock = mContextMockConnection{mock: m}

        m.MakeMock = mContextMockMake{mock: m}

        m.ServicesMock = mContextMockServices{mock: m}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mContextMockConnection struct {
        optional           bool
        mock               *ContextMock
        defaultExpectation *ContextMockConnectionExpectation
        expectations       []*ContextMockConnectionExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ContextMockConnectionExpectation specifies expectation struct of the Context.Connection
type ContextMockConnectionExpectation struct {
        mock *ContextMock

        results      *ContextMockConnectionResults
        returnOrigin string
        Counter      uint64
}

// ContextMockConnectionResults contains results of the Context.Connection
type ContextMockConnectionResults struct {
        c1 mm_domain.Connection
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConnection *mContextMockConnection) Optional() *mContextMockConnection <span class="cov0" title="0">{
        mmConnection.optional = true
        return mmConnection
}</span>

// Expect sets up expected params for Context.Connection
func (mmConnection *mContextMockConnection) Expect() *mContextMockConnection <span class="cov0" title="0">{
        if mmConnection.mock.funcConnection != nil </span><span class="cov0" title="0">{
                mmConnection.mock.t.Fatalf("ContextMock.Connection mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmConnection.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmConnection.defaultExpectation = &amp;ContextMockConnectionExpectation{}
        }</span>

        <span class="cov0" title="0">return mmConnection</span>
}

// Inspect accepts an inspector function that has same arguments as the Context.Connection
func (mmConnection *mContextMockConnection) Inspect(f func()) *mContextMockConnection <span class="cov0" title="0">{
        if mmConnection.mock.inspectFuncConnection != nil </span><span class="cov0" title="0">{
                mmConnection.mock.t.Fatalf("Inspect function is already set for ContextMock.Connection")
        }</span>

        <span class="cov0" title="0">mmConnection.mock.inspectFuncConnection = f

        return mmConnection</span>
}

// Return sets up results that will be returned by Context.Connection
func (mmConnection *mContextMockConnection) Return(c1 mm_domain.Connection) *ContextMock <span class="cov8" title="1">{
        if mmConnection.mock.funcConnection != nil </span><span class="cov0" title="0">{
                mmConnection.mock.t.Fatalf("ContextMock.Connection mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmConnection.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmConnection.defaultExpectation = &amp;ContextMockConnectionExpectation{mock: mmConnection.mock}
        }</span>
        <span class="cov8" title="1">mmConnection.defaultExpectation.results = &amp;ContextMockConnectionResults{c1}
        mmConnection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmConnection.mock</span>
}

// Set uses given function f to mock the Context.Connection method
func (mmConnection *mContextMockConnection) Set(f func() (c1 mm_domain.Connection)) *ContextMock <span class="cov0" title="0">{
        if mmConnection.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmConnection.mock.t.Fatalf("Default expectation is already set for the Context.Connection method")
        }</span>

        <span class="cov0" title="0">if len(mmConnection.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmConnection.mock.t.Fatalf("Some expectations are already set for the Context.Connection method")
        }</span>

        <span class="cov0" title="0">mmConnection.mock.funcConnection = f
        mmConnection.mock.funcConnectionOrigin = minimock.CallerInfo(1)
        return mmConnection.mock</span>
}

// Times sets number of times Context.Connection should be invoked
func (mmConnection *mContextMockConnection) Times(n uint64) *mContextMockConnection <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmConnection.mock.t.Fatalf("Times of ContextMock.Connection mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmConnection.expectedInvocations, n)
        mmConnection.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmConnection</span>
}

func (mmConnection *mContextMockConnection) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmConnection.expectations) == 0 &amp;&amp; mmConnection.defaultExpectation == nil &amp;&amp; mmConnection.mock.funcConnection == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmConnection.mock.afterConnectionCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmConnection.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Connection implements mm_domain.Context
func (mmConnection *ContextMock) Connection() (c1 mm_domain.Connection) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmConnection.beforeConnectionCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmConnection.afterConnectionCounter, 1)

        mmConnection.t.Helper()

        if mmConnection.inspectFuncConnection != nil </span><span class="cov0" title="0">{
                mmConnection.inspectFuncConnection()
        }</span>

        <span class="cov8" title="1">if mmConnection.ConnectionMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmConnection.ConnectionMock.defaultExpectation.Counter, 1)

                mm_results := mmConnection.ConnectionMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmConnection.t.Fatal("No results are set for the ContextMock.Connection")
                }</span>
                <span class="cov8" title="1">return (*mm_results).c1</span>
        }
        <span class="cov0" title="0">if mmConnection.funcConnection != nil </span><span class="cov0" title="0">{
                return mmConnection.funcConnection()
        }</span>
        <span class="cov0" title="0">mmConnection.t.Fatalf("Unexpected call to ContextMock.Connection.")
        return</span>
}

// ConnectionAfterCounter returns a count of finished ContextMock.Connection invocations
func (mmConnection *ContextMock) ConnectionAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmConnection.afterConnectionCounter)
}</span>

// ConnectionBeforeCounter returns a count of ContextMock.Connection invocations
func (mmConnection *ContextMock) ConnectionBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmConnection.beforeConnectionCounter)
}</span>

// MinimockConnectionDone returns true if the count of the Connection invocations corresponds
// the number of defined expectations
func (m *ContextMock) MinimockConnectionDone() bool <span class="cov8" title="1">{
        if m.ConnectionMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.ConnectionMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.ConnectionMock.invocationsDone()</span>
}

// MinimockConnectionInspect logs each unmet expectation
func (m *ContextMock) MinimockConnectionInspect() <span class="cov0" title="0">{
        for _, e := range m.ConnectionMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ContextMock.Connection")
                }</span>
        }

        <span class="cov0" title="0">afterConnectionCounter := mm_atomic.LoadUint64(&amp;m.afterConnectionCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ConnectionMock.defaultExpectation != nil &amp;&amp; afterConnectionCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ContextMock.Connection at\n%s", m.ConnectionMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcConnection != nil &amp;&amp; afterConnectionCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ContextMock.Connection at\n%s", m.funcConnectionOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ConnectionMock.invocationsDone() &amp;&amp; afterConnectionCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ContextMock.Connection at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ConnectionMock.expectedInvocations), m.ConnectionMock.expectedInvocationsOrigin, afterConnectionCounter)
        }</span>
}

type mContextMockMake struct {
        optional           bool
        mock               *ContextMock
        defaultExpectation *ContextMockMakeExpectation
        expectations       []*ContextMockMakeExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ContextMockMakeExpectation specifies expectation struct of the Context.Make
type ContextMockMakeExpectation struct {
        mock *ContextMock

        results      *ContextMockMakeResults
        returnOrigin string
        Counter      uint64
}

// ContextMockMakeResults contains results of the Context.Make
type ContextMockMakeResults struct {
        c1 mm_domain.Context
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMake *mContextMockMake) Optional() *mContextMockMake <span class="cov0" title="0">{
        mmMake.optional = true
        return mmMake
}</span>

// Expect sets up expected params for Context.Make
func (mmMake *mContextMockMake) Expect() *mContextMockMake <span class="cov0" title="0">{
        if mmMake.mock.funcMake != nil </span><span class="cov0" title="0">{
                mmMake.mock.t.Fatalf("ContextMock.Make mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmMake.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmMake.defaultExpectation = &amp;ContextMockMakeExpectation{}
        }</span>

        <span class="cov0" title="0">return mmMake</span>
}

// Inspect accepts an inspector function that has same arguments as the Context.Make
func (mmMake *mContextMockMake) Inspect(f func()) *mContextMockMake <span class="cov0" title="0">{
        if mmMake.mock.inspectFuncMake != nil </span><span class="cov0" title="0">{
                mmMake.mock.t.Fatalf("Inspect function is already set for ContextMock.Make")
        }</span>

        <span class="cov0" title="0">mmMake.mock.inspectFuncMake = f

        return mmMake</span>
}

// Return sets up results that will be returned by Context.Make
func (mmMake *mContextMockMake) Return(c1 mm_domain.Context) *ContextMock <span class="cov0" title="0">{
        if mmMake.mock.funcMake != nil </span><span class="cov0" title="0">{
                mmMake.mock.t.Fatalf("ContextMock.Make mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmMake.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmMake.defaultExpectation = &amp;ContextMockMakeExpectation{mock: mmMake.mock}
        }</span>
        <span class="cov0" title="0">mmMake.defaultExpectation.results = &amp;ContextMockMakeResults{c1}
        mmMake.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmMake.mock</span>
}

// Set uses given function f to mock the Context.Make method
func (mmMake *mContextMockMake) Set(f func() (c1 mm_domain.Context)) *ContextMock <span class="cov0" title="0">{
        if mmMake.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmMake.mock.t.Fatalf("Default expectation is already set for the Context.Make method")
        }</span>

        <span class="cov0" title="0">if len(mmMake.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmMake.mock.t.Fatalf("Some expectations are already set for the Context.Make method")
        }</span>

        <span class="cov0" title="0">mmMake.mock.funcMake = f
        mmMake.mock.funcMakeOrigin = minimock.CallerInfo(1)
        return mmMake.mock</span>
}

// Times sets number of times Context.Make should be invoked
func (mmMake *mContextMockMake) Times(n uint64) *mContextMockMake <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmMake.mock.t.Fatalf("Times of ContextMock.Make mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmMake.expectedInvocations, n)
        mmMake.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmMake</span>
}

func (mmMake *mContextMockMake) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmMake.expectations) == 0 &amp;&amp; mmMake.defaultExpectation == nil &amp;&amp; mmMake.mock.funcMake == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmMake.mock.afterMakeCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmMake.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Make implements mm_domain.Context
func (mmMake *ContextMock) Make() (c1 mm_domain.Context) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmMake.beforeMakeCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmMake.afterMakeCounter, 1)

        mmMake.t.Helper()

        if mmMake.inspectFuncMake != nil </span><span class="cov0" title="0">{
                mmMake.inspectFuncMake()
        }</span>

        <span class="cov0" title="0">if mmMake.MakeMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmMake.MakeMock.defaultExpectation.Counter, 1)

                mm_results := mmMake.MakeMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmMake.t.Fatal("No results are set for the ContextMock.Make")
                }</span>
                <span class="cov0" title="0">return (*mm_results).c1</span>
        }
        <span class="cov0" title="0">if mmMake.funcMake != nil </span><span class="cov0" title="0">{
                return mmMake.funcMake()
        }</span>
        <span class="cov0" title="0">mmMake.t.Fatalf("Unexpected call to ContextMock.Make.")
        return</span>
}

// MakeAfterCounter returns a count of finished ContextMock.Make invocations
func (mmMake *ContextMock) MakeAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmMake.afterMakeCounter)
}</span>

// MakeBeforeCounter returns a count of ContextMock.Make invocations
func (mmMake *ContextMock) MakeBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmMake.beforeMakeCounter)
}</span>

// MinimockMakeDone returns true if the count of the Make invocations corresponds
// the number of defined expectations
func (m *ContextMock) MinimockMakeDone() bool <span class="cov8" title="1">{
        if m.MakeMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.MakeMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.MakeMock.invocationsDone()</span>
}

// MinimockMakeInspect logs each unmet expectation
func (m *ContextMock) MinimockMakeInspect() <span class="cov0" title="0">{
        for _, e := range m.MakeMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ContextMock.Make")
                }</span>
        }

        <span class="cov0" title="0">afterMakeCounter := mm_atomic.LoadUint64(&amp;m.afterMakeCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.MakeMock.defaultExpectation != nil &amp;&amp; afterMakeCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ContextMock.Make at\n%s", m.MakeMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcMake != nil &amp;&amp; afterMakeCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ContextMock.Make at\n%s", m.funcMakeOrigin)
        }</span>

        <span class="cov0" title="0">if !m.MakeMock.invocationsDone() &amp;&amp; afterMakeCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ContextMock.Make at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.MakeMock.expectedInvocations), m.MakeMock.expectedInvocationsOrigin, afterMakeCounter)
        }</span>
}

type mContextMockServices struct {
        optional           bool
        mock               *ContextMock
        defaultExpectation *ContextMockServicesExpectation
        expectations       []*ContextMockServicesExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ContextMockServicesExpectation specifies expectation struct of the Context.Services
type ContextMockServicesExpectation struct {
        mock *ContextMock

        results      *ContextMockServicesResults
        returnOrigin string
        Counter      uint64
}

// ContextMockServicesResults contains results of the Context.Services
type ContextMockServicesResults struct {
        s1 mm_domain.Services
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmServices *mContextMockServices) Optional() *mContextMockServices <span class="cov0" title="0">{
        mmServices.optional = true
        return mmServices
}</span>

// Expect sets up expected params for Context.Services
func (mmServices *mContextMockServices) Expect() *mContextMockServices <span class="cov0" title="0">{
        if mmServices.mock.funcServices != nil </span><span class="cov0" title="0">{
                mmServices.mock.t.Fatalf("ContextMock.Services mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmServices.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmServices.defaultExpectation = &amp;ContextMockServicesExpectation{}
        }</span>

        <span class="cov0" title="0">return mmServices</span>
}

// Inspect accepts an inspector function that has same arguments as the Context.Services
func (mmServices *mContextMockServices) Inspect(f func()) *mContextMockServices <span class="cov0" title="0">{
        if mmServices.mock.inspectFuncServices != nil </span><span class="cov0" title="0">{
                mmServices.mock.t.Fatalf("Inspect function is already set for ContextMock.Services")
        }</span>

        <span class="cov0" title="0">mmServices.mock.inspectFuncServices = f

        return mmServices</span>
}

// Return sets up results that will be returned by Context.Services
func (mmServices *mContextMockServices) Return(s1 mm_domain.Services) *ContextMock <span class="cov8" title="1">{
        if mmServices.mock.funcServices != nil </span><span class="cov0" title="0">{
                mmServices.mock.t.Fatalf("ContextMock.Services mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmServices.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmServices.defaultExpectation = &amp;ContextMockServicesExpectation{mock: mmServices.mock}
        }</span>
        <span class="cov8" title="1">mmServices.defaultExpectation.results = &amp;ContextMockServicesResults{s1}
        mmServices.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmServices.mock</span>
}

// Set uses given function f to mock the Context.Services method
func (mmServices *mContextMockServices) Set(f func() (s1 mm_domain.Services)) *ContextMock <span class="cov0" title="0">{
        if mmServices.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmServices.mock.t.Fatalf("Default expectation is already set for the Context.Services method")
        }</span>

        <span class="cov0" title="0">if len(mmServices.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmServices.mock.t.Fatalf("Some expectations are already set for the Context.Services method")
        }</span>

        <span class="cov0" title="0">mmServices.mock.funcServices = f
        mmServices.mock.funcServicesOrigin = minimock.CallerInfo(1)
        return mmServices.mock</span>
}

// Times sets number of times Context.Services should be invoked
func (mmServices *mContextMockServices) Times(n uint64) *mContextMockServices <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmServices.mock.t.Fatalf("Times of ContextMock.Services mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmServices.expectedInvocations, n)
        mmServices.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmServices</span>
}

func (mmServices *mContextMockServices) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmServices.expectations) == 0 &amp;&amp; mmServices.defaultExpectation == nil &amp;&amp; mmServices.mock.funcServices == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmServices.mock.afterServicesCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmServices.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Services implements mm_domain.Context
func (mmServices *ContextMock) Services() (s1 mm_domain.Services) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmServices.beforeServicesCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmServices.afterServicesCounter, 1)

        mmServices.t.Helper()

        if mmServices.inspectFuncServices != nil </span><span class="cov0" title="0">{
                mmServices.inspectFuncServices()
        }</span>

        <span class="cov8" title="1">if mmServices.ServicesMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmServices.ServicesMock.defaultExpectation.Counter, 1)

                mm_results := mmServices.ServicesMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmServices.t.Fatal("No results are set for the ContextMock.Services")
                }</span>
                <span class="cov8" title="1">return (*mm_results).s1</span>
        }
        <span class="cov0" title="0">if mmServices.funcServices != nil </span><span class="cov0" title="0">{
                return mmServices.funcServices()
        }</span>
        <span class="cov0" title="0">mmServices.t.Fatalf("Unexpected call to ContextMock.Services.")
        return</span>
}

// ServicesAfterCounter returns a count of finished ContextMock.Services invocations
func (mmServices *ContextMock) ServicesAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmServices.afterServicesCounter)
}</span>

// ServicesBeforeCounter returns a count of ContextMock.Services invocations
func (mmServices *ContextMock) ServicesBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmServices.beforeServicesCounter)
}</span>

// MinimockServicesDone returns true if the count of the Services invocations corresponds
// the number of defined expectations
func (m *ContextMock) MinimockServicesDone() bool <span class="cov8" title="1">{
        if m.ServicesMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.ServicesMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.ServicesMock.invocationsDone()</span>
}

// MinimockServicesInspect logs each unmet expectation
func (m *ContextMock) MinimockServicesInspect() <span class="cov0" title="0">{
        for _, e := range m.ServicesMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ContextMock.Services")
                }</span>
        }

        <span class="cov0" title="0">afterServicesCounter := mm_atomic.LoadUint64(&amp;m.afterServicesCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ServicesMock.defaultExpectation != nil &amp;&amp; afterServicesCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ContextMock.Services at\n%s", m.ServicesMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcServices != nil &amp;&amp; afterServicesCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ContextMock.Services at\n%s", m.funcServicesOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ServicesMock.invocationsDone() &amp;&amp; afterServicesCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ContextMock.Services at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ServicesMock.expectedInvocations), m.ServicesMock.expectedInvocationsOrigin, afterServicesCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContextMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockConnectionInspect()

                        m.MinimockMakeInspect()

                        m.MinimockServicesInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContextMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ContextMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockConnectionDone() &amp;&amp;
                m.MinimockMakeDone() &amp;&amp;
                m.MinimockServicesDone()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain.Services -o services_mock_test.go -n ServicesMock -p mocks

import (
        "k071123/internal/services/parking_service/domain/services"
        "k071123/tools/logger"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// ServicesMock implements mm_domain.Services
type ServicesMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcConfig          func() (c1 services.Config)
        funcConfigOrigin    string
        inspectFuncConfig   func()
        afterConfigCounter  uint64
        beforeConfigCounter uint64
        ConfigMock          mServicesMockConfig

        funcLogger          func() (lp1 *logger.Logger)
        funcLoggerOrigin    string
        inspectFuncLogger   func()
        afterLoggerCounter  uint64
        beforeLoggerCounter uint64
        LoggerMock          mServicesMockLogger
}

// NewServicesMock returns a mock for mm_domain.Services
func NewServicesMock(t minimock.Tester) *ServicesMock <span class="cov8" title="1">{
        m := &amp;ServicesMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.ConfigMock = mServicesMockConfig{mock: m}

        m.LoggerMock = mServicesMockLogger{mock: m}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mServicesMockConfig struct {
        optional           bool
        mock               *ServicesMock
        defaultExpectation *ServicesMockConfigExpectation
        expectations       []*ServicesMockConfigExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ServicesMockConfigExpectation specifies expectation struct of the Services.Config
type ServicesMockConfigExpectation struct {
        mock *ServicesMock

        results      *ServicesMockConfigResults
        returnOrigin string
        Counter      uint64
}

// ServicesMockConfigResults contains results of the Services.Config
type ServicesMockConfigResults struct {
        c1 services.Config
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConfig *mServicesMockConfig) Optional() *mServicesMockConfig <span class="cov0" title="0">{
        mmConfig.optional = true
        return mmConfig
}</span>

// Expect sets up expected params for Services.Config
func (mmConfig *mServicesMockConfig) Expect() *mServicesMockConfig <span class="cov0" title="0">{
        if mmConfig.mock.funcConfig != nil </span><span class="cov0" title="0">{
                mmConfig.mock.t.Fatalf("ServicesMock.Config mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmConfig.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmConfig.defaultExpectation = &amp;ServicesMockConfigExpectation{}
        }</span>

        <span class="cov0" title="0">return mmConfig</span>
}

// Inspect accepts an inspector function that has same arguments as the Services.Config
func (mmConfig *mServicesMockConfig) Inspect(f func()) *mServicesMockConfig <span class="cov0" title="0">{
        if mmConfig.mock.inspectFuncConfig != nil </span><span class="cov0" title="0">{
                mmConfig.mock.t.Fatalf("Inspect function is already set for ServicesMock.Config")
        }</span>

        <span class="cov0" title="0">mmConfig.mock.inspectFuncConfig = f

        return mmConfig</span>
}

// Return sets up results that will be returned by Services.Config
func (mmConfig *mServicesMockConfig) Return(c1 services.Config) *ServicesMock <span class="cov0" title="0">{
        if mmConfig.mock.funcConfig != nil </span><span class="cov0" title="0">{
                mmConfig.mock.t.Fatalf("ServicesMock.Config mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmConfig.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmConfig.defaultExpectation = &amp;ServicesMockConfigExpectation{mock: mmConfig.mock}
        }</span>
        <span class="cov0" title="0">mmConfig.defaultExpectation.results = &amp;ServicesMockConfigResults{c1}
        mmConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmConfig.mock</span>
}

// Set uses given function f to mock the Services.Config method
func (mmConfig *mServicesMockConfig) Set(f func() (c1 services.Config)) *ServicesMock <span class="cov0" title="0">{
        if mmConfig.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmConfig.mock.t.Fatalf("Default expectation is already set for the Services.Config method")
        }</span>

        <span class="cov0" title="0">if len(mmConfig.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmConfig.mock.t.Fatalf("Some expectations are already set for the Services.Config method")
        }</span>

        <span class="cov0" title="0">mmConfig.mock.funcConfig = f
        mmConfig.mock.funcConfigOrigin = minimock.CallerInfo(1)
        return mmConfig.mock</span>
}

// Times sets number of times Services.Config should be invoked
func (mmConfig *mServicesMockConfig) Times(n uint64) *mServicesMockConfig <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmConfig.mock.t.Fatalf("Times of ServicesMock.Config mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmConfig.expectedInvocations, n)
        mmConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmConfig</span>
}

func (mmConfig *mServicesMockConfig) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmConfig.expectations) == 0 &amp;&amp; mmConfig.defaultExpectation == nil &amp;&amp; mmConfig.mock.funcConfig == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmConfig.mock.afterConfigCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmConfig.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Config implements mm_domain.Services
func (mmConfig *ServicesMock) Config() (c1 services.Config) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmConfig.beforeConfigCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmConfig.afterConfigCounter, 1)

        mmConfig.t.Helper()

        if mmConfig.inspectFuncConfig != nil </span><span class="cov0" title="0">{
                mmConfig.inspectFuncConfig()
        }</span>

        <span class="cov0" title="0">if mmConfig.ConfigMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmConfig.ConfigMock.defaultExpectation.Counter, 1)

                mm_results := mmConfig.ConfigMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmConfig.t.Fatal("No results are set for the ServicesMock.Config")
                }</span>
                <span class="cov0" title="0">return (*mm_results).c1</span>
        }
        <span class="cov0" title="0">if mmConfig.funcConfig != nil </span><span class="cov0" title="0">{
                return mmConfig.funcConfig()
        }</span>
        <span class="cov0" title="0">mmConfig.t.Fatalf("Unexpected call to ServicesMock.Config.")
        return</span>
}

// ConfigAfterCounter returns a count of finished ServicesMock.Config invocations
func (mmConfig *ServicesMock) ConfigAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmConfig.afterConfigCounter)
}</span>

// ConfigBeforeCounter returns a count of ServicesMock.Config invocations
func (mmConfig *ServicesMock) ConfigBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmConfig.beforeConfigCounter)
}</span>

// MinimockConfigDone returns true if the count of the Config invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockConfigDone() bool <span class="cov8" title="1">{
        if m.ConfigMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.ConfigMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.ConfigMock.invocationsDone()</span>
}

// MinimockConfigInspect logs each unmet expectation
func (m *ServicesMock) MinimockConfigInspect() <span class="cov0" title="0">{
        for _, e := range m.ConfigMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ServicesMock.Config")
                }</span>
        }

        <span class="cov0" title="0">afterConfigCounter := mm_atomic.LoadUint64(&amp;m.afterConfigCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ConfigMock.defaultExpectation != nil &amp;&amp; afterConfigCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ServicesMock.Config at\n%s", m.ConfigMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcConfig != nil &amp;&amp; afterConfigCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ServicesMock.Config at\n%s", m.funcConfigOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ConfigMock.invocationsDone() &amp;&amp; afterConfigCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ServicesMock.Config at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ConfigMock.expectedInvocations), m.ConfigMock.expectedInvocationsOrigin, afterConfigCounter)
        }</span>
}

type mServicesMockLogger struct {
        optional           bool
        mock               *ServicesMock
        defaultExpectation *ServicesMockLoggerExpectation
        expectations       []*ServicesMockLoggerExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ServicesMockLoggerExpectation specifies expectation struct of the Services.Logger
type ServicesMockLoggerExpectation struct {
        mock *ServicesMock

        results      *ServicesMockLoggerResults
        returnOrigin string
        Counter      uint64
}

// ServicesMockLoggerResults contains results of the Services.Logger
type ServicesMockLoggerResults struct {
        lp1 *logger.Logger
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogger *mServicesMockLogger) Optional() *mServicesMockLogger <span class="cov0" title="0">{
        mmLogger.optional = true
        return mmLogger
}</span>

// Expect sets up expected params for Services.Logger
func (mmLogger *mServicesMockLogger) Expect() *mServicesMockLogger <span class="cov0" title="0">{
        if mmLogger.mock.funcLogger != nil </span><span class="cov0" title="0">{
                mmLogger.mock.t.Fatalf("ServicesMock.Logger mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLogger.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLogger.defaultExpectation = &amp;ServicesMockLoggerExpectation{}
        }</span>

        <span class="cov0" title="0">return mmLogger</span>
}

// Inspect accepts an inspector function that has same arguments as the Services.Logger
func (mmLogger *mServicesMockLogger) Inspect(f func()) *mServicesMockLogger <span class="cov0" title="0">{
        if mmLogger.mock.inspectFuncLogger != nil </span><span class="cov0" title="0">{
                mmLogger.mock.t.Fatalf("Inspect function is already set for ServicesMock.Logger")
        }</span>

        <span class="cov0" title="0">mmLogger.mock.inspectFuncLogger = f

        return mmLogger</span>
}

// Return sets up results that will be returned by Services.Logger
func (mmLogger *mServicesMockLogger) Return(lp1 *logger.Logger) *ServicesMock <span class="cov8" title="1">{
        if mmLogger.mock.funcLogger != nil </span><span class="cov0" title="0">{
                mmLogger.mock.t.Fatalf("ServicesMock.Logger mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmLogger.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmLogger.defaultExpectation = &amp;ServicesMockLoggerExpectation{mock: mmLogger.mock}
        }</span>
        <span class="cov8" title="1">mmLogger.defaultExpectation.results = &amp;ServicesMockLoggerResults{lp1}
        mmLogger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmLogger.mock</span>
}

// Set uses given function f to mock the Services.Logger method
func (mmLogger *mServicesMockLogger) Set(f func() (lp1 *logger.Logger)) *ServicesMock <span class="cov0" title="0">{
        if mmLogger.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmLogger.mock.t.Fatalf("Default expectation is already set for the Services.Logger method")
        }</span>

        <span class="cov0" title="0">if len(mmLogger.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmLogger.mock.t.Fatalf("Some expectations are already set for the Services.Logger method")
        }</span>

        <span class="cov0" title="0">mmLogger.mock.funcLogger = f
        mmLogger.mock.funcLoggerOrigin = minimock.CallerInfo(1)
        return mmLogger.mock</span>
}

// Times sets number of times Services.Logger should be invoked
func (mmLogger *mServicesMockLogger) Times(n uint64) *mServicesMockLogger <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmLogger.mock.t.Fatalf("Times of ServicesMock.Logger mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmLogger.expectedInvocations, n)
        mmLogger.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmLogger</span>
}

func (mmLogger *mServicesMockLogger) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmLogger.expectations) == 0 &amp;&amp; mmLogger.defaultExpectation == nil &amp;&amp; mmLogger.mock.funcLogger == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmLogger.mock.afterLoggerCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmLogger.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Logger implements mm_domain.Services
func (mmLogger *ServicesMock) Logger() (lp1 *logger.Logger) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmLogger.beforeLoggerCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmLogger.afterLoggerCounter, 1)

        mmLogger.t.Helper()

        if mmLogger.inspectFuncLogger != nil </span><span class="cov0" title="0">{
                mmLogger.inspectFuncLogger()
        }</span>

        <span class="cov8" title="1">if mmLogger.LoggerMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmLogger.LoggerMock.defaultExpectation.Counter, 1)

                mm_results := mmLogger.LoggerMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmLogger.t.Fatal("No results are set for the ServicesMock.Logger")
                }</span>
                <span class="cov8" title="1">return (*mm_results).lp1</span>
        }
        <span class="cov0" title="0">if mmLogger.funcLogger != nil </span><span class="cov0" title="0">{
                return mmLogger.funcLogger()
        }</span>
        <span class="cov0" title="0">mmLogger.t.Fatalf("Unexpected call to ServicesMock.Logger.")
        return</span>
}

// LoggerAfterCounter returns a count of finished ServicesMock.Logger invocations
func (mmLogger *ServicesMock) LoggerAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmLogger.afterLoggerCounter)
}</span>

// LoggerBeforeCounter returns a count of ServicesMock.Logger invocations
func (mmLogger *ServicesMock) LoggerBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmLogger.beforeLoggerCounter)
}</span>

// MinimockLoggerDone returns true if the count of the Logger invocations corresponds
// the number of defined expectations
func (m *ServicesMock) MinimockLoggerDone() bool <span class="cov8" title="1">{
        if m.LoggerMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.LoggerMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.LoggerMock.invocationsDone()</span>
}

// MinimockLoggerInspect logs each unmet expectation
func (m *ServicesMock) MinimockLoggerInspect() <span class="cov0" title="0">{
        for _, e := range m.LoggerMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ServicesMock.Logger")
                }</span>
        }

        <span class="cov0" title="0">afterLoggerCounter := mm_atomic.LoadUint64(&amp;m.afterLoggerCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.LoggerMock.defaultExpectation != nil &amp;&amp; afterLoggerCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ServicesMock.Logger at\n%s", m.LoggerMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcLogger != nil &amp;&amp; afterLoggerCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ServicesMock.Logger at\n%s", m.funcLoggerOrigin)
        }</span>

        <span class="cov0" title="0">if !m.LoggerMock.invocationsDone() &amp;&amp; afterLoggerCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ServicesMock.Logger at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.LoggerMock.expectedInvocations), m.LoggerMock.expectedInvocationsOrigin, afterLoggerCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServicesMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockConfigInspect()

                        m.MinimockLoggerInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServicesMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ServicesMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockConfigDone() &amp;&amp;
                m.MinimockLoggerDone()
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package models

import (
        "github.com/google/uuid"
        "k071123/internal/services/parking_service/domain/models/parking_statuses"
        "k071123/pkg/timestamps"
)

type Parking struct {
        Timestamps  timestamps.Timestamps          `gorm:"embedded;" json:"-" swaggerignore:"true"`
        UUID        uuid.UUID                      `gorm:"primaryKey" json:"uuid"`
        TariffUUID  uuid.UUID                      `json:"tariff_uuid"`
        Name        string                         `json:"name"`
        Address     string                         `json:"address"`
        Latitude    string                         `json:"latitude"`
        Longitude   string                         `json:"longitude"`
        WorkingTime []ParkingSchedule              `gorm:"foreignKey:ParkingUUID" json:"working_time"`
        TotalPlaces uint                           `json:"total_places"`
        Status      parking_statuses.ParkingStatus `json:"status"`
}

func (p Parking) TableName() string <span class="cov0" title="0">{
        return "parkings"
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package models

import (
        "github.com/google/uuid"
        "github.com/lib/pq"
)

type ParkingSchedule struct {
        UUID        uuid.UUID     `gorm:"primaryKey" json:"uuid"`
        DaysOfWeek  pq.Int64Array `gorm:"type:int[]" json:"days_of_week"`
        OpenTime    string        `json:"open_time"`
        CloseTime   string        `json:"close_time"`
        ParkingUUID uuid.UUID     `gorm:"gorm:constraint:OnUpdate:CASCADE,OnDelete:SET NULL;" json:"parking_uuid"`
}

func (p ParkingSchedule) TableName() string <span class="cov0" title="0">{
        return "parking_schedule"
}</span>

// Monday 10.00-20.00
// Tuesday 24hrs
</pre>
		
		<pre class="file" id="file27" style="display: none">package props

import (
        "errors"
        "k071123/internal/services/parking_service/domain/models"
)

type CreateCarReq struct {
        GosNumber string `json:"gos_number"`
        UserUUID  string `json:"user_uuid"`
}

func (r *CreateCarReq) Validate() error <span class="cov8" title="1">{
        if r.GosNumber == "" </span><span class="cov8" title="1">{
                return errors.New("gos_number is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type CreateCarResp struct {
        Car *models.Car `json:"car"`
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package props

import (
        "errors"
        "fmt"
        "github.com/lib/pq"
        "k071123/internal/services/parking_service/domain/models"
        "strconv"
        "strings"
        "time"
)

type CreateParkingReq struct {
        Name        string                  `json:"name"`
        Address     string                  `json:"address"`
        Latitude    string                  `json:"latitude"`
        Longitude   string                  `json:"longitude"`
        WorkingTime []CreateParkingSchedule `json:"working_time"`
        TotalPlaces uint                    `json:"total_places"`
        Tariff      *CreateTariffReq        `json:"tariff"`
        TariffUUID  *string                 `json:"tariff_uuid"`
}

type CreateParkingSchedule struct {
        DaysOfWeek pq.Int64Array `gorm:"type:integer[]" json:"days_of_week"`
        OpenTime   string        `json:"open_time"`
        CloseTime  string        `json:"close_time"`
}

type CreateParkingResp struct {
        Parking *models.Parking `json:"parking"`
}

func (req *CreateParkingReq) Validate() error <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return errors.New("name is required")
        }</span>

        <span class="cov0" title="0">if req.Address == "" </span><span class="cov0" title="0">{
                return errors.New("address is required")
        }</span>

        <span class="cov0" title="0">if err := validateCoordinate(req.Latitude); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid latitude: %w", err)
        }</span>
        <span class="cov0" title="0">if err := validateCoordinate(req.Longitude); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid longitude: %w", err)
        }</span>

        <span class="cov0" title="0">if req.TotalPlaces == 0 </span><span class="cov0" title="0">{
                return errors.New("total_places must be &gt; 0")
        }</span>

        <span class="cov0" title="0">if req.Tariff != nil </span><span class="cov0" title="0">{
                if err := req.Tariff.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid tariff: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if len(req.WorkingTime) == 0 </span><span class="cov0" title="0">{
                return errors.New("working_time is required")
        }</span>

        <span class="cov0" title="0">for i, wt := range req.WorkingTime </span><span class="cov0" title="0">{
                if err := wt.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("working_time[%d]: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (t *CreateTariffReq) Validate() error <span class="cov0" title="0">{
        if t.Type == "" </span><span class="cov0" title="0">{
                return errors.New("tariff.type is required")
        }</span>
        <span class="cov0" title="0">if t.HourlyPrice &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("hourly_price must be &gt;= 0")
        }</span>
        <span class="cov0" title="0">if t.DailyPrice &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("daily_price must be &gt;= 0")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *CreateParkingSchedule) Validate() error <span class="cov0" title="0">{
        if len(s.DaysOfWeek) == 0 </span><span class="cov0" title="0">{
                return errors.New("days_of_week must not be empty")
        }</span>

        <span class="cov0" title="0">for _, day := range s.DaysOfWeek </span><span class="cov0" title="0">{
                if day &lt; 1 || day &gt; 7 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid day_of_week %d: allowed 1–7", day)
                }</span>
        }

        <span class="cov0" title="0">if s.OpenTime == "" || s.CloseTime == "" </span><span class="cov0" title="0">{
                return errors.New("open_time and close_time are required")
        }</span>

        <span class="cov0" title="0">open, err := parseHHMM(s.OpenTime)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid open_time: %w", err)
        }</span>

        <span class="cov0" title="0">closing, err := parseHHMM(s.CloseTime)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid close_time: %w", err)
        }</span>

        <span class="cov0" title="0">if !closing.After(open) </span><span class="cov0" title="0">{
                return errors.New("close_time must be after open_time")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func validateCoordinate(value string) error <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return errors.New("value is empty")
        }</span>
        <span class="cov0" title="0">_, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("must be a valid float")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func parseHHMM(s string) (time.Time, error) <span class="cov0" title="0">{
        parts := strings.Split(s, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return time.Time{}, errors.New("format must be HH:MM")
        }</span>

        <span class="cov0" title="0">hour, err1 := strconv.Atoi(parts[0])
        min, err2 := strconv.Atoi(parts[1])

        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return time.Time{}, errors.New("invalid numeric values")
        }</span>

        <span class="cov0" title="0">if hour &lt; 0 || hour &gt; 23 || min &lt; 0 || min &gt; 59 </span><span class="cov0" title="0">{
                return time.Time{}, errors.New("time out of range")
        }</span>

        // Возвращаем "время внутри дня"
        <span class="cov0" title="0">return time.Date(2000, 1, 1, hour, min, 0, 0, time.UTC), nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package props

import (
        "errors"
        "github.com/google/uuid"
        "k071123/internal/services/parking_service/domain/models"
        "k071123/internal/services/parking_service/domain/models/unit_statuses"
)

type CreateUniqReq struct {
        Status        unit_statuses.UnitStatus        `json:"status"`
        NetworkStatus unit_statuses.NetworkUnitStatus `json:"network_status"`
        Direction     unit_statuses.UnitDirection     `json:"direction"`
        Code          *string                         `json:"code"` // 234654
        QrLink        *string                         `json:"qr_link"`
        ParkingUUID   *uuid.UUID                      `json:"parking_uuid"`
}

type CreateUnitResp struct {
        Unit *models.Unit `json:"unit"`
}

func (r CreateUniqReq) Validate() error <span class="cov0" title="0">{
        if r.Code != nil </span><span class="cov0" title="0">{
                if len(*r.Code) != 6 </span><span class="cov0" title="0">{
                        return errors.New("code length must be 6")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package config

import (
        "github.com/ilyakaznacheev/cleanenv"
        "github.com/joho/godotenv"
)

type Postgres struct {
        Port     string `env:"POSTGRES_PORT"`
        User     string `env:"POSTGRES_USER"`
        Password string `env:"POSTGRES_PASSWORD"`
        Database string `env:"PARKING_DB_NAME"`
        Host     string `env:"POSTGRES_HOST"`
}

type HttpServer struct {
        Port string `env:"PARKING_HTTP_PORT"`
}

type ParkingGrpc struct {
        Port string `env:"PARKING_GRPC_PORT"`
        Host string `env:"PARKING_GRPC_HOST"`
}

type OrderGrpc struct {
        Port string `env:"ORDER_GRPC_PORT"`
        Host string `env:"ORDER_GRPC_HOST"`
}

type UserGrpc struct {
        Port string `env:"USER_GRPC_PORT"`
        Host string `env:"USER_GRPC_HOST"`
}

type NotificationGrpc struct {
        Port string `env:"NOTIFICATION_GRPC_PORT"`
        Host string `env:"NOTIFICATION_GRPC_HOST"`
}

type Middleware struct {
        PublicPemPath string `env:"JWT_PUBLIC_PEM_PATH"`
}

type Elastic struct {
        Host     string `env:"ELASTIC_HOST"`
        Port     string `env:"ELASTIC_PORT"`
        Username string `env:"ELASTIC_USERNAME"`
        Password string `env:"ELASTIC_PASSWORD"`
}

type Config struct {
        Postgres         Postgres
        HttpServer       HttpServer
        ParkingGrpc      ParkingGrpc
        OrderGrpc        OrderGrpc
        UserGrpc         UserGrpc
        Middleware       Middleware
        Elastic          Elastic
        NotificationGrpc NotificationGrpc
}

func Make() *Config <span class="cov0" title="0">{
        if err := godotenv.Load(".env"); err != nil </span><span class="cov0" title="0">{
                panic(".env file not found")</span>
        }

        <span class="cov0" title="0">var config Config
        if err := cleanenv.ReadEnv(&amp;config); err != nil </span><span class="cov0" title="0">{
                panic("cannot read environment")</span>
        }

        <span class="cov0" title="0">return &amp;config</span>
}

func (c *Config) PostgresPort() string <span class="cov0" title="0">{
        return c.Postgres.Port
}</span>

func (c *Config) PostgresUser() string <span class="cov0" title="0">{
        return c.Postgres.User
}</span>

func (c *Config) PostgresPassword() string <span class="cov0" title="0">{
        return c.Postgres.Password
}</span>

func (c *Config) PostgresDbName() string <span class="cov0" title="0">{
        return c.Postgres.Database
}</span>

func (c *Config) PostgresHost() string <span class="cov0" title="0">{
        return c.Postgres.Host
}</span>

func (c *Config) HttpPort() string <span class="cov0" title="0">{
        return c.HttpServer.Port
}</span>

func (c *Config) ParkingGrpcPort() string <span class="cov0" title="0">{
        return c.ParkingGrpc.Port
}</span>

func (c *Config) ParkingGrpcHost() string <span class="cov0" title="0">{
        return c.ParkingGrpc.Host
}</span>

func (c *Config) PublicPemPath() string <span class="cov0" title="0">{
        return c.Middleware.PublicPemPath
}</span>

func (c *Config) OrderGrpcPort() string <span class="cov0" title="0">{
        return c.OrderGrpc.Port
}</span>

func (c *Config) OrderGrpcHost() string <span class="cov0" title="0">{
        return c.OrderGrpc.Host
}</span>

func (c *Config) ElasticHost() string <span class="cov0" title="0">{
        return c.Elastic.Host
}</span>

func (c *Config) ElasticPort() string <span class="cov0" title="0">{
        return c.Elastic.Port
}</span>

func (c *Config) ElasticUsername() string <span class="cov0" title="0">{
        return c.Elastic.Username
}</span>

func (c *Config) ElasticPassword() string <span class="cov0" title="0">{
        return c.Elastic.Password
}</span>

func (c *Config) UserGrpcHost() string <span class="cov0" title="0">{
        return c.UserGrpc.Host
}</span>

func (c *Config) UserGrpcPort() string <span class="cov0" title="0">{
        return c.UserGrpc.Port
}</span>

func (c *Config) NotificationGrpcPort() string <span class="cov0" title="0">{
        return c.NotificationGrpc.Port
}</span>

func (c *Config) NotificationGrpcHost() string <span class="cov0" title="0">{
        return c.NotificationGrpc.Host
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package repositories

import (
        "gorm.io/gorm"
        "k071123/internal/services/parking_service/domain/models"
)

type CarRepository struct {
        db *gorm.DB
}

func NewCarRepository(db *gorm.DB) *CarRepository <span class="cov0" title="0">{
        return &amp;CarRepository{
                db: db,
        }
}</span>

func (r *CarRepository) Add(model *models.Car) error <span class="cov0" title="0">{
        return r.db.Create(model).Error
}</span>

func (r *CarRepository) GetByUUID(uuid string) (*models.Car, error) <span class="cov0" title="0">{
        var car models.Car
        if err := r.db.Where("uuid = ?", uuid).Preload("Settings").First(&amp;car).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;car, nil</span>
}

func (r *CarRepository) GetByGosNumber(number string) (*models.Car, error) <span class="cov0" title="0">{
        var car models.Car
        if err := r.db.Where("gos_number = ?", number).Preload("Settings").First(&amp;car).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;car, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package repositories

import (
        "fmt"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "k071123/internal/services/parking_service/domain"
        "k071123/internal/services/parking_service/domain/repositories"
        "reflect"
        "sync"
)

type connection struct {
        db *gorm.DB

        mu    sync.Mutex
        cache map[reflect.Type]interface{}
}

type txConnection struct {
        *connection
        tx *gorm.DB
}

func NewConnection(user, password, host, port, database string) (domain.Connection, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("postgresql://%s:%s@%s:%s/%s", user, password, host, port, database)
        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;connection{
                db:    db,
                cache: make(map[reflect.Type]interface{}),
        }, nil</span>
}

func (c *connection) Begin() (domain.TransactionalConnection, error) <span class="cov0" title="0">{
        tx := c.db.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, tx.Error
        }</span>

        <span class="cov0" title="0">return &amp;txConnection{
                connection: &amp;connection{
                        db:    tx,
                        cache: make(map[reflect.Type]interface{}),
                },
                tx: tx,
        }, nil</span>
}

func (t *txConnection) Commit() error <span class="cov0" title="0">{
        return t.tx.Commit().Error
}</span>

func (t *txConnection) Rollback() error <span class="cov0" title="0">{
        return t.tx.Rollback().Error
}</span>

func (c *connection) get(repoPtr interface{}, factory func(*gorm.DB) interface{}) interface{} <span class="cov0" title="0">{
        t := reflect.TypeOf(repoPtr).Elem() // repoPrt = repositories.CarRepo

        c.mu.Lock()
        defer c.mu.Unlock()

        if r, ok := c.cache[t]; ok </span><span class="cov0" title="0">{
                return r
        }</span>

        <span class="cov0" title="0">instance := factory(c.db)
        c.cache[t] = instance
        return instance</span>
}

func (c *connection) DB() *gorm.DB <span class="cov0" title="0">{
        return c.db
}</span>

func (c *connection) CarRepository() repositories.CarRepository <span class="cov0" title="0">{
        return c.get((*repositories.CarRepository)(nil),
                func(db *gorm.DB) interface{} </span><span class="cov0" title="0">{
                        return NewCarRepository(db)
                }</span>,
        ).(repositories.CarRepository)
}

func (c *connection) ParkingRepository() repositories.ParkingRepository <span class="cov0" title="0">{
        return c.get((*repositories.ParkingRepository)(nil),
                func(db *gorm.DB) interface{} </span><span class="cov0" title="0">{ return NewParkingRepository(db) }</span>,
        ).(repositories.ParkingRepository)
}

func (c *connection) TariffRepository() repositories.TariffRepository <span class="cov0" title="0">{
        return c.get((*repositories.TariffRepository)(nil),
                func(db *gorm.DB) interface{} </span><span class="cov0" title="0">{ return NewTariffRepository(db) }</span>,
        ).(repositories.TariffRepository)
}

func (c *connection) UnitRepository() repositories.UnitRepository <span class="cov0" title="0">{
        return c.get((*repositories.UnitRepository)(nil),
                func(db *gorm.DB) interface{} </span><span class="cov0" title="0">{ return NewUnitRepository(db) }</span>,
        ).(repositories.UnitRepository)
}

func (c *connection) SessionRepository() repositories.SessionRepository <span class="cov0" title="0">{
        return c.get((*repositories.SessionRepository)(nil),
                func(db *gorm.DB) interface{} </span><span class="cov0" title="0">{ return NewSessionRepository(db) }</span>,
        ).(repositories.SessionRepository)
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package repositories

import (
        "gorm.io/gorm"
        "k071123/internal/services/parking_service/domain/models"
)

type ParkingRepository struct {
        db *gorm.DB
}

func NewParkingRepository(db *gorm.DB) *ParkingRepository <span class="cov0" title="0">{
        return &amp;ParkingRepository{
                db: db,
        }
}</span>

func (r *ParkingRepository) Add(model *models.Parking) error <span class="cov0" title="0">{
        return r.db.Create(model).Error
}</span>

func (r *ParkingRepository) GetByUUID(uuid string) (*models.Parking, error) <span class="cov0" title="0">{
        var parking models.Parking
        if err := r.db.Where("uuid = ?", uuid).First(&amp;parking).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;parking, nil</span>
}

func (r *ParkingRepository) Update(model *models.Parking) error <span class="cov0" title="0">{
        return r.db.Save(model).Error
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package repositories

import (
        "errors"
        "github.com/google/uuid"
        "gorm.io/gorm"
        "k071123/internal/services/parking_service/domain/models"
        "k071123/internal/services/parking_service/domain/repositories"
        "time"
)

type SessionRepository struct {
        db *gorm.DB
}

func NewSessionRepository(db *gorm.DB) *SessionRepository <span class="cov0" title="0">{
        return &amp;SessionRepository{
                db: db,
        }
}</span>

// ______ REPOSITORY ______

func (r *SessionRepository) Add(model *models.Session) error <span class="cov0" title="0">{
        return r.db.Create(model).Error
}</span>

func (r *SessionRepository) GetByUUID(uuid string) (*models.Session, error) <span class="cov0" title="0">{
        var car models.Session
        if err := r.db.Where("uuid = ?", uuid).First(&amp;car).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;car, nil</span>
}

func (r *SessionRepository) WhereFilter(filter repositories.SessionFilter) ([]models.Session, error) <span class="cov0" title="0">{
        var sessions []models.Session
        f, ok := filter.(*sessionFilter)
        if !ok </span><span class="cov0" title="0">{
                return []models.Session{}, errors.New("wrong filter type")
        }</span>
        <span class="cov0" title="0">query := f.query(r.db)
        if err := r.db.Where(query).Find(&amp;sessions).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return []models.Session{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return sessions, nil</span>
}

func (r *SessionRepository) Update(uuid uuid.UUID, updates repositories.SessionUpdates) error <span class="cov0" title="0">{
        var session models.Session
        if err := r.db.Where("uuid = ?", uuid).First(&amp;session).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.db.Model(&amp;session).Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *SessionRepository) Filter() repositories.SessionFilter <span class="cov0" title="0">{
        return &amp;sessionFilter{}
}</span>

func (r *SessionRepository) Updates() repositories.SessionUpdates <span class="cov0" title="0">{
        return &amp;sessionUpdates{}
}</span>

// ______ FILTER ______
type sessionFilter struct {
        carUUIDs []string
        statuses []string
        uuids    []string
}

func (f *sessionFilter) SetCarUUIDs(carUUIDs []string) repositories.SessionFilter <span class="cov0" title="0">{
        f.carUUIDs = carUUIDs
        return f
}</span>

func (f *sessionFilter) SetStatuses(statuses []string) repositories.SessionFilter <span class="cov0" title="0">{
        f.statuses = statuses
        return f
}</span>

func (f *sessionFilter) SetUUIDs(uuids []string) repositories.SessionFilter <span class="cov0" title="0">{
        f.uuids = uuids
        return f
}</span>

func (f *sessionFilter) query(tx *gorm.DB) *gorm.DB <span class="cov0" title="0">{
        if len(f.carUUIDs) &gt; 0 </span><span class="cov0" title="0">{
                tx.Where("car_uuid IN (?)", f.carUUIDs)
        }</span>
        <span class="cov0" title="0">if len(f.statuses) &gt; 0 </span><span class="cov0" title="0">{
                tx.Where("status IN (?)", f.statuses)
        }</span>
        <span class="cov0" title="0">if len(f.uuids) &gt; 0 </span><span class="cov0" title="0">{
                tx.Where("uuid IN (?)", f.uuids)
        }</span>
        <span class="cov0" title="0">return tx</span>
}

// ______ UPDATES ______
type sessionUpdates struct {
        parkingUUID *uuid.UUID
        unitUUID    *uuid.UUID
        carUUID     *uuid.UUID
        userUUID    *uuid.UUID
        status      *string
        finishAt    *time.Time
        cost        *float64
}

func (u *sessionUpdates) toMap() map[string]interface{} <span class="cov0" title="0">{
        out := make(map[string]interface{})
        if u.parkingUUID != nil </span><span class="cov0" title="0">{
                out["parking_uuid"] = u.parkingUUID
        }</span>
        <span class="cov0" title="0">if u.unitUUID != nil </span><span class="cov0" title="0">{
                out["unit_uuid"] = u.unitUUID
        }</span>
        <span class="cov0" title="0">if u.carUUID != nil </span><span class="cov0" title="0">{
                out["car_uuid"] = u.carUUID
        }</span>
        <span class="cov0" title="0">if u.userUUID != nil </span><span class="cov0" title="0">{
                out["user_uuid"] = u.userUUID
        }</span>
        <span class="cov0" title="0">if u.finishAt != nil </span><span class="cov0" title="0">{
                out["finish_at"] = u.finishAt
        }</span>
        <span class="cov0" title="0">if u.status != nil </span><span class="cov0" title="0">{
                out["status"] = u.status
        }</span>
        <span class="cov0" title="0">if u.cost != nil </span><span class="cov0" title="0">{
                out["cost"] = u.cost
        }</span>
        <span class="cov0" title="0">return out</span>
}

func (u *sessionUpdates) SetParkingUUID(parkingUUID uuid.UUID) repositories.SessionUpdates <span class="cov0" title="0">{
        u.parkingUUID = &amp;parkingUUID
        return u
}</span>

func (u *sessionUpdates) SetUnitUUID(unitUUID uuid.UUID) repositories.SessionUpdates <span class="cov0" title="0">{
        u.unitUUID = &amp;unitUUID
        return u
}</span>

func (u *sessionUpdates) SetCarUUID(carUUID uuid.UUID) repositories.SessionUpdates <span class="cov0" title="0">{
        u.carUUID = &amp;carUUID
        return u
}</span>

func (u *sessionUpdates) SetUserUUID(userUUID uuid.UUID) repositories.SessionUpdates <span class="cov0" title="0">{
        u.userUUID = &amp;userUUID
        return u
}</span>

func (u *sessionUpdates) SetFinishAt(finishAt *time.Time) repositories.SessionUpdates <span class="cov0" title="0">{
        u.finishAt = finishAt
        return u
}</span>

func (u *sessionUpdates) SetStatus(status string) repositories.SessionUpdates <span class="cov0" title="0">{
        u.status = &amp;status
        return u
}</span>

func (u *sessionUpdates) SetCost(cost float64) repositories.SessionUpdates <span class="cov0" title="0">{
        u.cost = &amp;cost
        return u
}</span>

func (u *sessionUpdates) HaveUpdates() bool <span class="cov0" title="0">{
        return len(u.toMap()) &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package repositories

import (
        "gorm.io/gorm"
        "k071123/internal/services/parking_service/domain/models"
)

type TariffRepository struct {
        db *gorm.DB
}

func NewTariffRepository(db *gorm.DB) *TariffRepository <span class="cov0" title="0">{
        return &amp;TariffRepository{
                db: db,
        }
}</span>

func (r *TariffRepository) Add(model *models.Tariff) error <span class="cov0" title="0">{
        return r.db.Create(model).Error
}</span>

func (r *TariffRepository) GetByUUID(uuid string) (*models.Tariff, error) <span class="cov0" title="0">{
        var tariff models.Tariff
        if err := r.db.Where("uuid = ?", uuid).First(&amp;tariff).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;tariff, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package repositories

import (
        "gorm.io/gorm"
        "k071123/internal/services/parking_service/domain/models"
)

type UnitRepository struct {
        db *gorm.DB
}

func NewUnitRepository(db *gorm.DB) *UnitRepository <span class="cov0" title="0">{
        return &amp;UnitRepository{
                db: db,
        }
}</span>

func (r *UnitRepository) Add(model *models.Unit) error <span class="cov0" title="0">{
        return r.db.Create(model).Error
}</span>

func (r *UnitRepository) GetByUUID(uuid string) (*models.Unit, error) <span class="cov0" title="0">{
        var Unit models.Unit
        if err := r.db.Where("uuid = ?", uuid).First(&amp;Unit).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Unit, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package k071123

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package k071123

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const getParkingByUUID = `-- name: GetParkingByUUID :one
select uuid, user_uuid, gos_number, is_active, settings_uuid, created_at, updated_at, deleted_at from cars where uuid = $1 LIMIT 1
`

func (q *Queries) GetParkingByUUID(ctx context.Context, uuid pgtype.UUID) (Car, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getParkingByUUID, uuid)
        var i Car
        err := row.Scan(
                &amp;i.Uuid,
                &amp;i.UserUuid,
                &amp;i.GosNumber,
                &amp;i.IsActive,
                &amp;i.SettingsUuid,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.DeletedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain/repositories.CarRepository -o car_repository_mock_test.go -n CarRepositoryMock -p mocks

import (
        "k071123/internal/services/parking_service/domain/models"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// CarRepositoryMock implements mm_repositories.CarRepository
type CarRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAdd          func(model *models.Car) (err error)
        funcAddOrigin    string
        inspectFuncAdd   func(model *models.Car)
        afterAddCounter  uint64
        beforeAddCounter uint64
        AddMock          mCarRepositoryMockAdd

        funcGetByGosNumber          func(number string) (cp1 *models.Car, err error)
        funcGetByGosNumberOrigin    string
        inspectFuncGetByGosNumber   func(number string)
        afterGetByGosNumberCounter  uint64
        beforeGetByGosNumberCounter uint64
        GetByGosNumberMock          mCarRepositoryMockGetByGosNumber

        funcGetByUUID          func(uuid string) (cp1 *models.Car, err error)
        funcGetByUUIDOrigin    string
        inspectFuncGetByUUID   func(uuid string)
        afterGetByUUIDCounter  uint64
        beforeGetByUUIDCounter uint64
        GetByUUIDMock          mCarRepositoryMockGetByUUID
}

// NewCarRepositoryMock returns a mock for mm_repositories.CarRepository
func NewCarRepositoryMock(t minimock.Tester) *CarRepositoryMock <span class="cov8" title="1">{
        m := &amp;CarRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.AddMock = mCarRepositoryMockAdd{mock: m}
        m.AddMock.callArgs = []*CarRepositoryMockAddParams{}

        m.GetByGosNumberMock = mCarRepositoryMockGetByGosNumber{mock: m}
        m.GetByGosNumberMock.callArgs = []*CarRepositoryMockGetByGosNumberParams{}

        m.GetByUUIDMock = mCarRepositoryMockGetByUUID{mock: m}
        m.GetByUUIDMock.callArgs = []*CarRepositoryMockGetByUUIDParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mCarRepositoryMockAdd struct {
        optional           bool
        mock               *CarRepositoryMock
        defaultExpectation *CarRepositoryMockAddExpectation
        expectations       []*CarRepositoryMockAddExpectation

        callArgs []*CarRepositoryMockAddParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// CarRepositoryMockAddExpectation specifies expectation struct of the CarRepository.Add
type CarRepositoryMockAddExpectation struct {
        mock               *CarRepositoryMock
        params             *CarRepositoryMockAddParams
        paramPtrs          *CarRepositoryMockAddParamPtrs
        expectationOrigins CarRepositoryMockAddExpectationOrigins
        results            *CarRepositoryMockAddResults
        returnOrigin       string
        Counter            uint64
}

// CarRepositoryMockAddParams contains parameters of the CarRepository.Add
type CarRepositoryMockAddParams struct {
        model *models.Car
}

// CarRepositoryMockAddParamPtrs contains pointers to parameters of the CarRepository.Add
type CarRepositoryMockAddParamPtrs struct {
        model **models.Car
}

// CarRepositoryMockAddResults contains results of the CarRepository.Add
type CarRepositoryMockAddResults struct {
        err error
}

// CarRepositoryMockAddOrigins contains origins of expectations of the CarRepository.Add
type CarRepositoryMockAddExpectationOrigins struct {
        origin      string
        originModel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mCarRepositoryMockAdd) Optional() *mCarRepositoryMockAdd <span class="cov0" title="0">{
        mmAdd.optional = true
        return mmAdd
}</span>

// Expect sets up expected params for CarRepository.Add
func (mmAdd *mCarRepositoryMockAdd) Expect(model *models.Car) *mCarRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("CarRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;CarRepositoryMockAddExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("CarRepositoryMock.Add mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmAdd.defaultExpectation.params = &amp;CarRepositoryMockAddParams{model}
        mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmAdd.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAdd.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmAdd</span>
}

// ExpectModelParam1 sets up expected param model for CarRepository.Add
func (mmAdd *mCarRepositoryMockAdd) ExpectModelParam1(model *models.Car) *mCarRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("CarRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;CarRepositoryMockAddExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("CarRepositoryMock.Add mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation.paramPtrs = &amp;CarRepositoryMockAddParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAdd.defaultExpectation.paramPtrs.model = &amp;model
        mmAdd.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

        return mmAdd</span>
}

// Inspect accepts an inspector function that has same arguments as the CarRepository.Add
func (mmAdd *mCarRepositoryMockAdd) Inspect(f func(model *models.Car)) *mCarRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.inspectFuncAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Inspect function is already set for CarRepositoryMock.Add")
        }</span>

        <span class="cov0" title="0">mmAdd.mock.inspectFuncAdd = f

        return mmAdd</span>
}

// Return sets up results that will be returned by CarRepository.Add
func (mmAdd *mCarRepositoryMockAdd) Return(err error) *CarRepositoryMock <span class="cov8" title="1">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("CarRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmAdd.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmAdd.defaultExpectation = &amp;CarRepositoryMockAddExpectation{mock: mmAdd.mock}
        }</span>
        <span class="cov8" title="1">mmAdd.defaultExpectation.results = &amp;CarRepositoryMockAddResults{err}
        mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmAdd.mock</span>
}

// Set uses given function f to mock the CarRepository.Add method
func (mmAdd *mCarRepositoryMockAdd) Set(f func(model *models.Car) (err error)) *CarRepositoryMock <span class="cov0" title="0">{
        if mmAdd.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Default expectation is already set for the CarRepository.Add method")
        }</span>

        <span class="cov0" title="0">if len(mmAdd.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Some expectations are already set for the CarRepository.Add method")
        }</span>

        <span class="cov0" title="0">mmAdd.mock.funcAdd = f
        mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
        return mmAdd.mock</span>
}

// When sets expectation for the CarRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mCarRepositoryMockAdd) When(model *models.Car) *CarRepositoryMockAddExpectation <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("CarRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CarRepositoryMockAddExpectation{
                mock:               mmAdd.mock,
                params:             &amp;CarRepositoryMockAddParams{model},
                expectationOrigins: CarRepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmAdd.expectations = append(mmAdd.expectations, expectation)
        return expectation</span>
}

// Then sets up CarRepository.Add return parameters for the expectation previously defined by the When method
func (e *CarRepositoryMockAddExpectation) Then(err error) *CarRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CarRepositoryMockAddResults{err}
        return e.mock
}</span>

// Times sets number of times CarRepository.Add should be invoked
func (mmAdd *mCarRepositoryMockAdd) Times(n uint64) *mCarRepositoryMockAdd <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Times of CarRepositoryMock.Add mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAdd.expectedInvocations, n)
        mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmAdd</span>
}

func (mmAdd *mCarRepositoryMockAdd) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmAdd.expectations) == 0 &amp;&amp; mmAdd.defaultExpectation == nil &amp;&amp; mmAdd.mock.funcAdd == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmAdd.mock.afterAddCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAdd.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Add implements mm_repositories.CarRepository
func (mmAdd *CarRepositoryMock) Add(model *models.Car) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmAdd.beforeAddCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAdd.afterAddCounter, 1)

        mmAdd.t.Helper()

        if mmAdd.inspectFuncAdd != nil </span><span class="cov0" title="0">{
                mmAdd.inspectFuncAdd(model)
        }</span>

        <span class="cov8" title="1">mm_params := CarRepositoryMockAddParams{model}

        // Record call args
        mmAdd.AddMock.mutex.Lock()
        mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &amp;mm_params)
        mmAdd.AddMock.mutex.Unlock()

        for _, e := range mmAdd.AddMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmAdd.AddMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmAdd.AddMock.defaultExpectation.Counter, 1)
                mm_want := mmAdd.AddMock.defaultExpectation.params
                mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

                mm_got := CarRepositoryMockAddParams{model}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.model != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.model, mm_got.model) </span><span class="cov0" title="0">{
                                mmAdd.t.Errorf("CarRepositoryMock.Add got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAdd.AddMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAdd.t.Errorf("CarRepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmAdd.AddMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAdd.t.Fatal("No results are set for the CarRepositoryMock.Add")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAdd.funcAdd != nil </span><span class="cov0" title="0">{
                return mmAdd.funcAdd(model)
        }</span>
        <span class="cov0" title="0">mmAdd.t.Fatalf("Unexpected call to CarRepositoryMock.Add. %v", model)
        return</span>
}

// AddAfterCounter returns a count of finished CarRepositoryMock.Add invocations
func (mmAdd *CarRepositoryMock) AddAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAdd.afterAddCounter)
}</span>

// AddBeforeCounter returns a count of CarRepositoryMock.Add invocations
func (mmAdd *CarRepositoryMock) AddBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAdd.beforeAddCounter)
}</span>

// Calls returns a list of arguments used in each call to CarRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mCarRepositoryMockAdd) Calls() []*CarRepositoryMockAddParams <span class="cov0" title="0">{
        mmAdd.mutex.RLock()

        argCopy := make([]*CarRepositoryMockAddParams, len(mmAdd.callArgs))
        copy(argCopy, mmAdd.callArgs)

        mmAdd.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *CarRepositoryMock) MinimockAddDone() bool <span class="cov8" title="1">{
        if m.AddMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.AddMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.AddMock.invocationsDone()</span>
}

// MinimockAddInspect logs each unmet expectation
func (m *CarRepositoryMock) MinimockAddInspect() <span class="cov0" title="0">{
        for _, e := range m.AddMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CarRepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddCounter := mm_atomic.LoadUint64(&amp;m.afterAddCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddMock.defaultExpectation != nil &amp;&amp; afterAddCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CarRepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CarRepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAdd != nil &amp;&amp; afterAddCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to CarRepositoryMock.Add at\n%s", m.funcAddOrigin)
        }</span>

        <span class="cov0" title="0">if !m.AddMock.invocationsDone() &amp;&amp; afterAddCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CarRepositoryMock.Add at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
        }</span>
}

type mCarRepositoryMockGetByGosNumber struct {
        optional           bool
        mock               *CarRepositoryMock
        defaultExpectation *CarRepositoryMockGetByGosNumberExpectation
        expectations       []*CarRepositoryMockGetByGosNumberExpectation

        callArgs []*CarRepositoryMockGetByGosNumberParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// CarRepositoryMockGetByGosNumberExpectation specifies expectation struct of the CarRepository.GetByGosNumber
type CarRepositoryMockGetByGosNumberExpectation struct {
        mock               *CarRepositoryMock
        params             *CarRepositoryMockGetByGosNumberParams
        paramPtrs          *CarRepositoryMockGetByGosNumberParamPtrs
        expectationOrigins CarRepositoryMockGetByGosNumberExpectationOrigins
        results            *CarRepositoryMockGetByGosNumberResults
        returnOrigin       string
        Counter            uint64
}

// CarRepositoryMockGetByGosNumberParams contains parameters of the CarRepository.GetByGosNumber
type CarRepositoryMockGetByGosNumberParams struct {
        number string
}

// CarRepositoryMockGetByGosNumberParamPtrs contains pointers to parameters of the CarRepository.GetByGosNumber
type CarRepositoryMockGetByGosNumberParamPtrs struct {
        number *string
}

// CarRepositoryMockGetByGosNumberResults contains results of the CarRepository.GetByGosNumber
type CarRepositoryMockGetByGosNumberResults struct {
        cp1 *models.Car
        err error
}

// CarRepositoryMockGetByGosNumberOrigins contains origins of expectations of the CarRepository.GetByGosNumber
type CarRepositoryMockGetByGosNumberExpectationOrigins struct {
        origin       string
        originNumber string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) Optional() *mCarRepositoryMockGetByGosNumber <span class="cov0" title="0">{
        mmGetByGosNumber.optional = true
        return mmGetByGosNumber
}</span>

// Expect sets up expected params for CarRepository.GetByGosNumber
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) Expect(number string) *mCarRepositoryMockGetByGosNumber <span class="cov0" title="0">{
        if mmGetByGosNumber.mock.funcGetByGosNumber != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("CarRepositoryMock.GetByGosNumber mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByGosNumber.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.defaultExpectation = &amp;CarRepositoryMockGetByGosNumberExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByGosNumber.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("CarRepositoryMock.GetByGosNumber mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetByGosNumber.defaultExpectation.params = &amp;CarRepositoryMockGetByGosNumberParams{number}
        mmGetByGosNumber.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetByGosNumber.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetByGosNumber.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetByGosNumber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByGosNumber.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetByGosNumber</span>
}

// ExpectNumberParam1 sets up expected param number for CarRepository.GetByGosNumber
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) ExpectNumberParam1(number string) *mCarRepositoryMockGetByGosNumber <span class="cov0" title="0">{
        if mmGetByGosNumber.mock.funcGetByGosNumber != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("CarRepositoryMock.GetByGosNumber mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByGosNumber.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.defaultExpectation = &amp;CarRepositoryMockGetByGosNumberExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByGosNumber.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("CarRepositoryMock.GetByGosNumber mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByGosNumber.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.defaultExpectation.paramPtrs = &amp;CarRepositoryMockGetByGosNumberParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByGosNumber.defaultExpectation.paramPtrs.number = &amp;number
        mmGetByGosNumber.defaultExpectation.expectationOrigins.originNumber = minimock.CallerInfo(1)

        return mmGetByGosNumber</span>
}

// Inspect accepts an inspector function that has same arguments as the CarRepository.GetByGosNumber
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) Inspect(f func(number string)) *mCarRepositoryMockGetByGosNumber <span class="cov0" title="0">{
        if mmGetByGosNumber.mock.inspectFuncGetByGosNumber != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("Inspect function is already set for CarRepositoryMock.GetByGosNumber")
        }</span>

        <span class="cov0" title="0">mmGetByGosNumber.mock.inspectFuncGetByGosNumber = f

        return mmGetByGosNumber</span>
}

// Return sets up results that will be returned by CarRepository.GetByGosNumber
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) Return(cp1 *models.Car, err error) *CarRepositoryMock <span class="cov0" title="0">{
        if mmGetByGosNumber.mock.funcGetByGosNumber != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("CarRepositoryMock.GetByGosNumber mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByGosNumber.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.defaultExpectation = &amp;CarRepositoryMockGetByGosNumberExpectation{mock: mmGetByGosNumber.mock}
        }</span>
        <span class="cov0" title="0">mmGetByGosNumber.defaultExpectation.results = &amp;CarRepositoryMockGetByGosNumberResults{cp1, err}
        mmGetByGosNumber.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetByGosNumber.mock</span>
}

// Set uses given function f to mock the CarRepository.GetByGosNumber method
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) Set(f func(number string) (cp1 *models.Car, err error)) *CarRepositoryMock <span class="cov0" title="0">{
        if mmGetByGosNumber.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("Default expectation is already set for the CarRepository.GetByGosNumber method")
        }</span>

        <span class="cov0" title="0">if len(mmGetByGosNumber.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("Some expectations are already set for the CarRepository.GetByGosNumber method")
        }</span>

        <span class="cov0" title="0">mmGetByGosNumber.mock.funcGetByGosNumber = f
        mmGetByGosNumber.mock.funcGetByGosNumberOrigin = minimock.CallerInfo(1)
        return mmGetByGosNumber.mock</span>
}

// When sets expectation for the CarRepository.GetByGosNumber which will trigger the result defined by the following
// Then helper
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) When(number string) *CarRepositoryMockGetByGosNumberExpectation <span class="cov0" title="0">{
        if mmGetByGosNumber.mock.funcGetByGosNumber != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("CarRepositoryMock.GetByGosNumber mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CarRepositoryMockGetByGosNumberExpectation{
                mock:               mmGetByGosNumber.mock,
                params:             &amp;CarRepositoryMockGetByGosNumberParams{number},
                expectationOrigins: CarRepositoryMockGetByGosNumberExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetByGosNumber.expectations = append(mmGetByGosNumber.expectations, expectation)
        return expectation</span>
}

// Then sets up CarRepository.GetByGosNumber return parameters for the expectation previously defined by the When method
func (e *CarRepositoryMockGetByGosNumberExpectation) Then(cp1 *models.Car, err error) *CarRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CarRepositoryMockGetByGosNumberResults{cp1, err}
        return e.mock
}</span>

// Times sets number of times CarRepository.GetByGosNumber should be invoked
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) Times(n uint64) *mCarRepositoryMockGetByGosNumber <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetByGosNumber.mock.t.Fatalf("Times of CarRepositoryMock.GetByGosNumber mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetByGosNumber.expectedInvocations, n)
        mmGetByGosNumber.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetByGosNumber</span>
}

func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetByGosNumber.expectations) == 0 &amp;&amp; mmGetByGosNumber.defaultExpectation == nil &amp;&amp; mmGetByGosNumber.mock.funcGetByGosNumber == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetByGosNumber.mock.afterGetByGosNumberCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetByGosNumber.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetByGosNumber implements mm_repositories.CarRepository
func (mmGetByGosNumber *CarRepositoryMock) GetByGosNumber(number string) (cp1 *models.Car, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetByGosNumber.beforeGetByGosNumberCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetByGosNumber.afterGetByGosNumberCounter, 1)

        mmGetByGosNumber.t.Helper()

        if mmGetByGosNumber.inspectFuncGetByGosNumber != nil </span><span class="cov0" title="0">{
                mmGetByGosNumber.inspectFuncGetByGosNumber(number)
        }</span>

        <span class="cov0" title="0">mm_params := CarRepositoryMockGetByGosNumberParams{number}

        // Record call args
        mmGetByGosNumber.GetByGosNumberMock.mutex.Lock()
        mmGetByGosNumber.GetByGosNumberMock.callArgs = append(mmGetByGosNumber.GetByGosNumberMock.callArgs, &amp;mm_params)
        mmGetByGosNumber.GetByGosNumberMock.mutex.Unlock()

        for _, e := range mmGetByGosNumber.GetByGosNumberMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.cp1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetByGosNumber.GetByGosNumberMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetByGosNumber.GetByGosNumberMock.defaultExpectation.Counter, 1)
                mm_want := mmGetByGosNumber.GetByGosNumberMock.defaultExpectation.params
                mm_want_ptrs := mmGetByGosNumber.GetByGosNumberMock.defaultExpectation.paramPtrs

                mm_got := CarRepositoryMockGetByGosNumberParams{number}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.number != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.number, mm_got.number) </span><span class="cov0" title="0">{
                                mmGetByGosNumber.t.Errorf("CarRepositoryMock.GetByGosNumber got unexpected parameter number, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByGosNumber.GetByGosNumberMock.defaultExpectation.expectationOrigins.originNumber, *mm_want_ptrs.number, mm_got.number, minimock.Diff(*mm_want_ptrs.number, mm_got.number))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetByGosNumber.t.Errorf("CarRepositoryMock.GetByGosNumber got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetByGosNumber.GetByGosNumberMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetByGosNumber.GetByGosNumberMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetByGosNumber.t.Fatal("No results are set for the CarRepositoryMock.GetByGosNumber")
                }</span>
                <span class="cov0" title="0">return (*mm_results).cp1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetByGosNumber.funcGetByGosNumber != nil </span><span class="cov0" title="0">{
                return mmGetByGosNumber.funcGetByGosNumber(number)
        }</span>
        <span class="cov0" title="0">mmGetByGosNumber.t.Fatalf("Unexpected call to CarRepositoryMock.GetByGosNumber. %v", number)
        return</span>
}

// GetByGosNumberAfterCounter returns a count of finished CarRepositoryMock.GetByGosNumber invocations
func (mmGetByGosNumber *CarRepositoryMock) GetByGosNumberAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByGosNumber.afterGetByGosNumberCounter)
}</span>

// GetByGosNumberBeforeCounter returns a count of CarRepositoryMock.GetByGosNumber invocations
func (mmGetByGosNumber *CarRepositoryMock) GetByGosNumberBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByGosNumber.beforeGetByGosNumberCounter)
}</span>

// Calls returns a list of arguments used in each call to CarRepositoryMock.GetByGosNumber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByGosNumber *mCarRepositoryMockGetByGosNumber) Calls() []*CarRepositoryMockGetByGosNumberParams <span class="cov0" title="0">{
        mmGetByGosNumber.mutex.RLock()

        argCopy := make([]*CarRepositoryMockGetByGosNumberParams, len(mmGetByGosNumber.callArgs))
        copy(argCopy, mmGetByGosNumber.callArgs)

        mmGetByGosNumber.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetByGosNumberDone returns true if the count of the GetByGosNumber invocations corresponds
// the number of defined expectations
func (m *CarRepositoryMock) MinimockGetByGosNumberDone() bool <span class="cov8" title="1">{
        if m.GetByGosNumberMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetByGosNumberMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetByGosNumberMock.invocationsDone()</span>
}

// MinimockGetByGosNumberInspect logs each unmet expectation
func (m *CarRepositoryMock) MinimockGetByGosNumberInspect() <span class="cov0" title="0">{
        for _, e := range m.GetByGosNumberMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CarRepositoryMock.GetByGosNumber at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetByGosNumberCounter := mm_atomic.LoadUint64(&amp;m.afterGetByGosNumberCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetByGosNumberMock.defaultExpectation != nil &amp;&amp; afterGetByGosNumberCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetByGosNumberMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CarRepositoryMock.GetByGosNumber at\n%s", m.GetByGosNumberMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CarRepositoryMock.GetByGosNumber at\n%s with params: %#v", m.GetByGosNumberMock.defaultExpectation.expectationOrigins.origin, *m.GetByGosNumberMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetByGosNumber != nil &amp;&amp; afterGetByGosNumberCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to CarRepositoryMock.GetByGosNumber at\n%s", m.funcGetByGosNumberOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetByGosNumberMock.invocationsDone() &amp;&amp; afterGetByGosNumberCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CarRepositoryMock.GetByGosNumber at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetByGosNumberMock.expectedInvocations), m.GetByGosNumberMock.expectedInvocationsOrigin, afterGetByGosNumberCounter)
        }</span>
}

type mCarRepositoryMockGetByUUID struct {
        optional           bool
        mock               *CarRepositoryMock
        defaultExpectation *CarRepositoryMockGetByUUIDExpectation
        expectations       []*CarRepositoryMockGetByUUIDExpectation

        callArgs []*CarRepositoryMockGetByUUIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// CarRepositoryMockGetByUUIDExpectation specifies expectation struct of the CarRepository.GetByUUID
type CarRepositoryMockGetByUUIDExpectation struct {
        mock               *CarRepositoryMock
        params             *CarRepositoryMockGetByUUIDParams
        paramPtrs          *CarRepositoryMockGetByUUIDParamPtrs
        expectationOrigins CarRepositoryMockGetByUUIDExpectationOrigins
        results            *CarRepositoryMockGetByUUIDResults
        returnOrigin       string
        Counter            uint64
}

// CarRepositoryMockGetByUUIDParams contains parameters of the CarRepository.GetByUUID
type CarRepositoryMockGetByUUIDParams struct {
        uuid string
}

// CarRepositoryMockGetByUUIDParamPtrs contains pointers to parameters of the CarRepository.GetByUUID
type CarRepositoryMockGetByUUIDParamPtrs struct {
        uuid *string
}

// CarRepositoryMockGetByUUIDResults contains results of the CarRepository.GetByUUID
type CarRepositoryMockGetByUUIDResults struct {
        cp1 *models.Car
        err error
}

// CarRepositoryMockGetByUUIDOrigins contains origins of expectations of the CarRepository.GetByUUID
type CarRepositoryMockGetByUUIDExpectationOrigins struct {
        origin     string
        originUuid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByUUID *mCarRepositoryMockGetByUUID) Optional() *mCarRepositoryMockGetByUUID <span class="cov0" title="0">{
        mmGetByUUID.optional = true
        return mmGetByUUID
}</span>

// Expect sets up expected params for CarRepository.GetByUUID
func (mmGetByUUID *mCarRepositoryMockGetByUUID) Expect(uuid string) *mCarRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("CarRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;CarRepositoryMockGetByUUIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("CarRepositoryMock.GetByUUID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.params = &amp;CarRepositoryMockGetByUUIDParams{uuid}
        mmGetByUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetByUUID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetByUUID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetByUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByUUID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetByUUID</span>
}

// ExpectUuidParam1 sets up expected param uuid for CarRepository.GetByUUID
func (mmGetByUUID *mCarRepositoryMockGetByUUID) ExpectUuidParam1(uuid string) *mCarRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("CarRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;CarRepositoryMockGetByUUIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("CarRepositoryMock.GetByUUID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation.paramPtrs = &amp;CarRepositoryMockGetByUUIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.paramPtrs.uuid = &amp;uuid
        mmGetByUUID.defaultExpectation.expectationOrigins.originUuid = minimock.CallerInfo(1)

        return mmGetByUUID</span>
}

// Inspect accepts an inspector function that has same arguments as the CarRepository.GetByUUID
func (mmGetByUUID *mCarRepositoryMockGetByUUID) Inspect(f func(uuid string)) *mCarRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.inspectFuncGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Inspect function is already set for CarRepositoryMock.GetByUUID")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.mock.inspectFuncGetByUUID = f

        return mmGetByUUID</span>
}

// Return sets up results that will be returned by CarRepository.GetByUUID
func (mmGetByUUID *mCarRepositoryMockGetByUUID) Return(cp1 *models.Car, err error) *CarRepositoryMock <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("CarRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;CarRepositoryMockGetByUUIDExpectation{mock: mmGetByUUID.mock}
        }</span>
        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.results = &amp;CarRepositoryMockGetByUUIDResults{cp1, err}
        mmGetByUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetByUUID.mock</span>
}

// Set uses given function f to mock the CarRepository.GetByUUID method
func (mmGetByUUID *mCarRepositoryMockGetByUUID) Set(f func(uuid string) (cp1 *models.Car, err error)) *CarRepositoryMock <span class="cov0" title="0">{
        if mmGetByUUID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Default expectation is already set for the CarRepository.GetByUUID method")
        }</span>

        <span class="cov0" title="0">if len(mmGetByUUID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Some expectations are already set for the CarRepository.GetByUUID method")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.mock.funcGetByUUID = f
        mmGetByUUID.mock.funcGetByUUIDOrigin = minimock.CallerInfo(1)
        return mmGetByUUID.mock</span>
}

// When sets expectation for the CarRepository.GetByUUID which will trigger the result defined by the following
// Then helper
func (mmGetByUUID *mCarRepositoryMockGetByUUID) When(uuid string) *CarRepositoryMockGetByUUIDExpectation <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("CarRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CarRepositoryMockGetByUUIDExpectation{
                mock:               mmGetByUUID.mock,
                params:             &amp;CarRepositoryMockGetByUUIDParams{uuid},
                expectationOrigins: CarRepositoryMockGetByUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetByUUID.expectations = append(mmGetByUUID.expectations, expectation)
        return expectation</span>
}

// Then sets up CarRepository.GetByUUID return parameters for the expectation previously defined by the When method
func (e *CarRepositoryMockGetByUUIDExpectation) Then(cp1 *models.Car, err error) *CarRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CarRepositoryMockGetByUUIDResults{cp1, err}
        return e.mock
}</span>

// Times sets number of times CarRepository.GetByUUID should be invoked
func (mmGetByUUID *mCarRepositoryMockGetByUUID) Times(n uint64) *mCarRepositoryMockGetByUUID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Times of CarRepositoryMock.GetByUUID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetByUUID.expectedInvocations, n)
        mmGetByUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetByUUID</span>
}

func (mmGetByUUID *mCarRepositoryMockGetByUUID) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetByUUID.expectations) == 0 &amp;&amp; mmGetByUUID.defaultExpectation == nil &amp;&amp; mmGetByUUID.mock.funcGetByUUID == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetByUUID.mock.afterGetByUUIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetByUUID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetByUUID implements mm_repositories.CarRepository
func (mmGetByUUID *CarRepositoryMock) GetByUUID(uuid string) (cp1 *models.Car, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetByUUID.beforeGetByUUIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetByUUID.afterGetByUUIDCounter, 1)

        mmGetByUUID.t.Helper()

        if mmGetByUUID.inspectFuncGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.inspectFuncGetByUUID(uuid)
        }</span>

        <span class="cov0" title="0">mm_params := CarRepositoryMockGetByUUIDParams{uuid}

        // Record call args
        mmGetByUUID.GetByUUIDMock.mutex.Lock()
        mmGetByUUID.GetByUUIDMock.callArgs = append(mmGetByUUID.GetByUUIDMock.callArgs, &amp;mm_params)
        mmGetByUUID.GetByUUIDMock.mutex.Unlock()

        for _, e := range mmGetByUUID.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.cp1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetByUUID.GetByUUIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetByUUID.GetByUUIDMock.defaultExpectation.Counter, 1)
                mm_want := mmGetByUUID.GetByUUIDMock.defaultExpectation.params
                mm_want_ptrs := mmGetByUUID.GetByUUIDMock.defaultExpectation.paramPtrs

                mm_got := CarRepositoryMockGetByUUIDParams{uuid}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.uuid != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.uuid, mm_got.uuid) </span><span class="cov0" title="0">{
                                mmGetByUUID.t.Errorf("CarRepositoryMock.GetByUUID got unexpected parameter uuid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByUUID.GetByUUIDMock.defaultExpectation.expectationOrigins.originUuid, *mm_want_ptrs.uuid, mm_got.uuid, minimock.Diff(*mm_want_ptrs.uuid, mm_got.uuid))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetByUUID.t.Errorf("CarRepositoryMock.GetByUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetByUUID.GetByUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetByUUID.GetByUUIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetByUUID.t.Fatal("No results are set for the CarRepositoryMock.GetByUUID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).cp1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetByUUID.funcGetByUUID != nil </span><span class="cov0" title="0">{
                return mmGetByUUID.funcGetByUUID(uuid)
        }</span>
        <span class="cov0" title="0">mmGetByUUID.t.Fatalf("Unexpected call to CarRepositoryMock.GetByUUID. %v", uuid)
        return</span>
}

// GetByUUIDAfterCounter returns a count of finished CarRepositoryMock.GetByUUID invocations
func (mmGetByUUID *CarRepositoryMock) GetByUUIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByUUID.afterGetByUUIDCounter)
}</span>

// GetByUUIDBeforeCounter returns a count of CarRepositoryMock.GetByUUID invocations
func (mmGetByUUID *CarRepositoryMock) GetByUUIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByUUID.beforeGetByUUIDCounter)
}</span>

// Calls returns a list of arguments used in each call to CarRepositoryMock.GetByUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByUUID *mCarRepositoryMockGetByUUID) Calls() []*CarRepositoryMockGetByUUIDParams <span class="cov0" title="0">{
        mmGetByUUID.mutex.RLock()

        argCopy := make([]*CarRepositoryMockGetByUUIDParams, len(mmGetByUUID.callArgs))
        copy(argCopy, mmGetByUUID.callArgs)

        mmGetByUUID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetByUUIDDone returns true if the count of the GetByUUID invocations corresponds
// the number of defined expectations
func (m *CarRepositoryMock) MinimockGetByUUIDDone() bool <span class="cov8" title="1">{
        if m.GetByUUIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetByUUIDMock.invocationsDone()</span>
}

// MinimockGetByUUIDInspect logs each unmet expectation
func (m *CarRepositoryMock) MinimockGetByUUIDInspect() <span class="cov0" title="0">{
        for _, e := range m.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CarRepositoryMock.GetByUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetByUUIDCounter := mm_atomic.LoadUint64(&amp;m.afterGetByUUIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetByUUIDMock.defaultExpectation != nil &amp;&amp; afterGetByUUIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetByUUIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CarRepositoryMock.GetByUUID at\n%s", m.GetByUUIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CarRepositoryMock.GetByUUID at\n%s with params: %#v", m.GetByUUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByUUIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetByUUID != nil &amp;&amp; afterGetByUUIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to CarRepositoryMock.GetByUUID at\n%s", m.funcGetByUUIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetByUUIDMock.invocationsDone() &amp;&amp; afterGetByUUIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CarRepositoryMock.GetByUUID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetByUUIDMock.expectedInvocations), m.GetByUUIDMock.expectedInvocationsOrigin, afterGetByUUIDCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CarRepositoryMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddInspect()

                        m.MinimockGetByGosNumberInspect()

                        m.MinimockGetByUUIDInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CarRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *CarRepositoryMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockAddDone() &amp;&amp;
                m.MinimockGetByGosNumberDone() &amp;&amp;
                m.MinimockGetByUUIDDone()
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain/repositories.ParkingRepository -o parking_repository_mock_test.go -n ParkingRepositoryMock -p mocks

import (
        "k071123/internal/services/parking_service/domain/models"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// ParkingRepositoryMock implements mm_repositories.ParkingRepository
type ParkingRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAdd          func(model *models.Parking) (err error)
        funcAddOrigin    string
        inspectFuncAdd   func(model *models.Parking)
        afterAddCounter  uint64
        beforeAddCounter uint64
        AddMock          mParkingRepositoryMockAdd

        funcGetByUUID          func(uuid string) (pp1 *models.Parking, err error)
        funcGetByUUIDOrigin    string
        inspectFuncGetByUUID   func(uuid string)
        afterGetByUUIDCounter  uint64
        beforeGetByUUIDCounter uint64
        GetByUUIDMock          mParkingRepositoryMockGetByUUID
}

// NewParkingRepositoryMock returns a mock for mm_repositories.ParkingRepository
func NewParkingRepositoryMock(t minimock.Tester) *ParkingRepositoryMock <span class="cov0" title="0">{
        m := &amp;ParkingRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.AddMock = mParkingRepositoryMockAdd{mock: m}
        m.AddMock.callArgs = []*ParkingRepositoryMockAddParams{}

        m.GetByUUIDMock = mParkingRepositoryMockGetByUUID{mock: m}
        m.GetByUUIDMock.callArgs = []*ParkingRepositoryMockGetByUUIDParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mParkingRepositoryMockAdd struct {
        optional           bool
        mock               *ParkingRepositoryMock
        defaultExpectation *ParkingRepositoryMockAddExpectation
        expectations       []*ParkingRepositoryMockAddExpectation

        callArgs []*ParkingRepositoryMockAddParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ParkingRepositoryMockAddExpectation specifies expectation struct of the ParkingRepository.Add
type ParkingRepositoryMockAddExpectation struct {
        mock               *ParkingRepositoryMock
        params             *ParkingRepositoryMockAddParams
        paramPtrs          *ParkingRepositoryMockAddParamPtrs
        expectationOrigins ParkingRepositoryMockAddExpectationOrigins
        results            *ParkingRepositoryMockAddResults
        returnOrigin       string
        Counter            uint64
}

// ParkingRepositoryMockAddParams contains parameters of the ParkingRepository.Add
type ParkingRepositoryMockAddParams struct {
        model *models.Parking
}

// ParkingRepositoryMockAddParamPtrs contains pointers to parameters of the ParkingRepository.Add
type ParkingRepositoryMockAddParamPtrs struct {
        model **models.Parking
}

// ParkingRepositoryMockAddResults contains results of the ParkingRepository.Add
type ParkingRepositoryMockAddResults struct {
        err error
}

// ParkingRepositoryMockAddOrigins contains origins of expectations of the ParkingRepository.Add
type ParkingRepositoryMockAddExpectationOrigins struct {
        origin      string
        originModel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mParkingRepositoryMockAdd) Optional() *mParkingRepositoryMockAdd <span class="cov0" title="0">{
        mmAdd.optional = true
        return mmAdd
}</span>

// Expect sets up expected params for ParkingRepository.Add
func (mmAdd *mParkingRepositoryMockAdd) Expect(model *models.Parking) *mParkingRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("ParkingRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;ParkingRepositoryMockAddExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("ParkingRepositoryMock.Add mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmAdd.defaultExpectation.params = &amp;ParkingRepositoryMockAddParams{model}
        mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmAdd.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAdd.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmAdd</span>
}

// ExpectModelParam1 sets up expected param model for ParkingRepository.Add
func (mmAdd *mParkingRepositoryMockAdd) ExpectModelParam1(model *models.Parking) *mParkingRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("ParkingRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;ParkingRepositoryMockAddExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("ParkingRepositoryMock.Add mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation.paramPtrs = &amp;ParkingRepositoryMockAddParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAdd.defaultExpectation.paramPtrs.model = &amp;model
        mmAdd.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

        return mmAdd</span>
}

// Inspect accepts an inspector function that has same arguments as the ParkingRepository.Add
func (mmAdd *mParkingRepositoryMockAdd) Inspect(f func(model *models.Parking)) *mParkingRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.inspectFuncAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Inspect function is already set for ParkingRepositoryMock.Add")
        }</span>

        <span class="cov0" title="0">mmAdd.mock.inspectFuncAdd = f

        return mmAdd</span>
}

// Return sets up results that will be returned by ParkingRepository.Add
func (mmAdd *mParkingRepositoryMockAdd) Return(err error) *ParkingRepositoryMock <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("ParkingRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;ParkingRepositoryMockAddExpectation{mock: mmAdd.mock}
        }</span>
        <span class="cov0" title="0">mmAdd.defaultExpectation.results = &amp;ParkingRepositoryMockAddResults{err}
        mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmAdd.mock</span>
}

// Set uses given function f to mock the ParkingRepository.Add method
func (mmAdd *mParkingRepositoryMockAdd) Set(f func(model *models.Parking) (err error)) *ParkingRepositoryMock <span class="cov0" title="0">{
        if mmAdd.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Default expectation is already set for the ParkingRepository.Add method")
        }</span>

        <span class="cov0" title="0">if len(mmAdd.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Some expectations are already set for the ParkingRepository.Add method")
        }</span>

        <span class="cov0" title="0">mmAdd.mock.funcAdd = f
        mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
        return mmAdd.mock</span>
}

// When sets expectation for the ParkingRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mParkingRepositoryMockAdd) When(model *models.Parking) *ParkingRepositoryMockAddExpectation <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("ParkingRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ParkingRepositoryMockAddExpectation{
                mock:               mmAdd.mock,
                params:             &amp;ParkingRepositoryMockAddParams{model},
                expectationOrigins: ParkingRepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmAdd.expectations = append(mmAdd.expectations, expectation)
        return expectation</span>
}

// Then sets up ParkingRepository.Add return parameters for the expectation previously defined by the When method
func (e *ParkingRepositoryMockAddExpectation) Then(err error) *ParkingRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;ParkingRepositoryMockAddResults{err}
        return e.mock
}</span>

// Times sets number of times ParkingRepository.Add should be invoked
func (mmAdd *mParkingRepositoryMockAdd) Times(n uint64) *mParkingRepositoryMockAdd <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Times of ParkingRepositoryMock.Add mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAdd.expectedInvocations, n)
        mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmAdd</span>
}

func (mmAdd *mParkingRepositoryMockAdd) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmAdd.expectations) == 0 &amp;&amp; mmAdd.defaultExpectation == nil &amp;&amp; mmAdd.mock.funcAdd == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmAdd.mock.afterAddCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAdd.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Add implements mm_repositories.ParkingRepository
func (mmAdd *ParkingRepositoryMock) Add(model *models.Parking) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmAdd.beforeAddCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAdd.afterAddCounter, 1)

        mmAdd.t.Helper()

        if mmAdd.inspectFuncAdd != nil </span><span class="cov0" title="0">{
                mmAdd.inspectFuncAdd(model)
        }</span>

        <span class="cov0" title="0">mm_params := ParkingRepositoryMockAddParams{model}

        // Record call args
        mmAdd.AddMock.mutex.Lock()
        mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &amp;mm_params)
        mmAdd.AddMock.mutex.Unlock()

        for _, e := range mmAdd.AddMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmAdd.AddMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmAdd.AddMock.defaultExpectation.Counter, 1)
                mm_want := mmAdd.AddMock.defaultExpectation.params
                mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

                mm_got := ParkingRepositoryMockAddParams{model}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.model != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.model, mm_got.model) </span><span class="cov0" title="0">{
                                mmAdd.t.Errorf("ParkingRepositoryMock.Add got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAdd.AddMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAdd.t.Errorf("ParkingRepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmAdd.AddMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAdd.t.Fatal("No results are set for the ParkingRepositoryMock.Add")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAdd.funcAdd != nil </span><span class="cov0" title="0">{
                return mmAdd.funcAdd(model)
        }</span>
        <span class="cov0" title="0">mmAdd.t.Fatalf("Unexpected call to ParkingRepositoryMock.Add. %v", model)
        return</span>
}

// AddAfterCounter returns a count of finished ParkingRepositoryMock.Add invocations
func (mmAdd *ParkingRepositoryMock) AddAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAdd.afterAddCounter)
}</span>

// AddBeforeCounter returns a count of ParkingRepositoryMock.Add invocations
func (mmAdd *ParkingRepositoryMock) AddBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAdd.beforeAddCounter)
}</span>

// Calls returns a list of arguments used in each call to ParkingRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mParkingRepositoryMockAdd) Calls() []*ParkingRepositoryMockAddParams <span class="cov0" title="0">{
        mmAdd.mutex.RLock()

        argCopy := make([]*ParkingRepositoryMockAddParams, len(mmAdd.callArgs))
        copy(argCopy, mmAdd.callArgs)

        mmAdd.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *ParkingRepositoryMock) MinimockAddDone() bool <span class="cov0" title="0">{
        if m.AddMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.AddMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.AddMock.invocationsDone()</span>
}

// MinimockAddInspect logs each unmet expectation
func (m *ParkingRepositoryMock) MinimockAddInspect() <span class="cov0" title="0">{
        for _, e := range m.AddMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ParkingRepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddCounter := mm_atomic.LoadUint64(&amp;m.afterAddCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddMock.defaultExpectation != nil &amp;&amp; afterAddCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ParkingRepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ParkingRepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAdd != nil &amp;&amp; afterAddCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ParkingRepositoryMock.Add at\n%s", m.funcAddOrigin)
        }</span>

        <span class="cov0" title="0">if !m.AddMock.invocationsDone() &amp;&amp; afterAddCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ParkingRepositoryMock.Add at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
        }</span>
}

type mParkingRepositoryMockGetByUUID struct {
        optional           bool
        mock               *ParkingRepositoryMock
        defaultExpectation *ParkingRepositoryMockGetByUUIDExpectation
        expectations       []*ParkingRepositoryMockGetByUUIDExpectation

        callArgs []*ParkingRepositoryMockGetByUUIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ParkingRepositoryMockGetByUUIDExpectation specifies expectation struct of the ParkingRepository.GetByUUID
type ParkingRepositoryMockGetByUUIDExpectation struct {
        mock               *ParkingRepositoryMock
        params             *ParkingRepositoryMockGetByUUIDParams
        paramPtrs          *ParkingRepositoryMockGetByUUIDParamPtrs
        expectationOrigins ParkingRepositoryMockGetByUUIDExpectationOrigins
        results            *ParkingRepositoryMockGetByUUIDResults
        returnOrigin       string
        Counter            uint64
}

// ParkingRepositoryMockGetByUUIDParams contains parameters of the ParkingRepository.GetByUUID
type ParkingRepositoryMockGetByUUIDParams struct {
        uuid string
}

// ParkingRepositoryMockGetByUUIDParamPtrs contains pointers to parameters of the ParkingRepository.GetByUUID
type ParkingRepositoryMockGetByUUIDParamPtrs struct {
        uuid *string
}

// ParkingRepositoryMockGetByUUIDResults contains results of the ParkingRepository.GetByUUID
type ParkingRepositoryMockGetByUUIDResults struct {
        pp1 *models.Parking
        err error
}

// ParkingRepositoryMockGetByUUIDOrigins contains origins of expectations of the ParkingRepository.GetByUUID
type ParkingRepositoryMockGetByUUIDExpectationOrigins struct {
        origin     string
        originUuid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) Optional() *mParkingRepositoryMockGetByUUID <span class="cov0" title="0">{
        mmGetByUUID.optional = true
        return mmGetByUUID
}</span>

// Expect sets up expected params for ParkingRepository.GetByUUID
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) Expect(uuid string) *mParkingRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("ParkingRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;ParkingRepositoryMockGetByUUIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("ParkingRepositoryMock.GetByUUID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.params = &amp;ParkingRepositoryMockGetByUUIDParams{uuid}
        mmGetByUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetByUUID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetByUUID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetByUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByUUID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetByUUID</span>
}

// ExpectUuidParam1 sets up expected param uuid for ParkingRepository.GetByUUID
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) ExpectUuidParam1(uuid string) *mParkingRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("ParkingRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;ParkingRepositoryMockGetByUUIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("ParkingRepositoryMock.GetByUUID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation.paramPtrs = &amp;ParkingRepositoryMockGetByUUIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.paramPtrs.uuid = &amp;uuid
        mmGetByUUID.defaultExpectation.expectationOrigins.originUuid = minimock.CallerInfo(1)

        return mmGetByUUID</span>
}

// Inspect accepts an inspector function that has same arguments as the ParkingRepository.GetByUUID
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) Inspect(f func(uuid string)) *mParkingRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.inspectFuncGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Inspect function is already set for ParkingRepositoryMock.GetByUUID")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.mock.inspectFuncGetByUUID = f

        return mmGetByUUID</span>
}

// Return sets up results that will be returned by ParkingRepository.GetByUUID
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) Return(pp1 *models.Parking, err error) *ParkingRepositoryMock <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("ParkingRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;ParkingRepositoryMockGetByUUIDExpectation{mock: mmGetByUUID.mock}
        }</span>
        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.results = &amp;ParkingRepositoryMockGetByUUIDResults{pp1, err}
        mmGetByUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetByUUID.mock</span>
}

// Set uses given function f to mock the ParkingRepository.GetByUUID method
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) Set(f func(uuid string) (pp1 *models.Parking, err error)) *ParkingRepositoryMock <span class="cov0" title="0">{
        if mmGetByUUID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Default expectation is already set for the ParkingRepository.GetByUUID method")
        }</span>

        <span class="cov0" title="0">if len(mmGetByUUID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Some expectations are already set for the ParkingRepository.GetByUUID method")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.mock.funcGetByUUID = f
        mmGetByUUID.mock.funcGetByUUIDOrigin = minimock.CallerInfo(1)
        return mmGetByUUID.mock</span>
}

// When sets expectation for the ParkingRepository.GetByUUID which will trigger the result defined by the following
// Then helper
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) When(uuid string) *ParkingRepositoryMockGetByUUIDExpectation <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("ParkingRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ParkingRepositoryMockGetByUUIDExpectation{
                mock:               mmGetByUUID.mock,
                params:             &amp;ParkingRepositoryMockGetByUUIDParams{uuid},
                expectationOrigins: ParkingRepositoryMockGetByUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetByUUID.expectations = append(mmGetByUUID.expectations, expectation)
        return expectation</span>
}

// Then sets up ParkingRepository.GetByUUID return parameters for the expectation previously defined by the When method
func (e *ParkingRepositoryMockGetByUUIDExpectation) Then(pp1 *models.Parking, err error) *ParkingRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;ParkingRepositoryMockGetByUUIDResults{pp1, err}
        return e.mock
}</span>

// Times sets number of times ParkingRepository.GetByUUID should be invoked
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) Times(n uint64) *mParkingRepositoryMockGetByUUID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Times of ParkingRepositoryMock.GetByUUID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetByUUID.expectedInvocations, n)
        mmGetByUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetByUUID</span>
}

func (mmGetByUUID *mParkingRepositoryMockGetByUUID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGetByUUID.expectations) == 0 &amp;&amp; mmGetByUUID.defaultExpectation == nil &amp;&amp; mmGetByUUID.mock.funcGetByUUID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetByUUID.mock.afterGetByUUIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetByUUID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetByUUID implements mm_repositories.ParkingRepository
func (mmGetByUUID *ParkingRepositoryMock) GetByUUID(uuid string) (pp1 *models.Parking, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetByUUID.beforeGetByUUIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetByUUID.afterGetByUUIDCounter, 1)

        mmGetByUUID.t.Helper()

        if mmGetByUUID.inspectFuncGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.inspectFuncGetByUUID(uuid)
        }</span>

        <span class="cov0" title="0">mm_params := ParkingRepositoryMockGetByUUIDParams{uuid}

        // Record call args
        mmGetByUUID.GetByUUIDMock.mutex.Lock()
        mmGetByUUID.GetByUUIDMock.callArgs = append(mmGetByUUID.GetByUUIDMock.callArgs, &amp;mm_params)
        mmGetByUUID.GetByUUIDMock.mutex.Unlock()

        for _, e := range mmGetByUUID.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.pp1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetByUUID.GetByUUIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetByUUID.GetByUUIDMock.defaultExpectation.Counter, 1)
                mm_want := mmGetByUUID.GetByUUIDMock.defaultExpectation.params
                mm_want_ptrs := mmGetByUUID.GetByUUIDMock.defaultExpectation.paramPtrs

                mm_got := ParkingRepositoryMockGetByUUIDParams{uuid}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.uuid != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.uuid, mm_got.uuid) </span><span class="cov0" title="0">{
                                mmGetByUUID.t.Errorf("ParkingRepositoryMock.GetByUUID got unexpected parameter uuid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByUUID.GetByUUIDMock.defaultExpectation.expectationOrigins.originUuid, *mm_want_ptrs.uuid, mm_got.uuid, minimock.Diff(*mm_want_ptrs.uuid, mm_got.uuid))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetByUUID.t.Errorf("ParkingRepositoryMock.GetByUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetByUUID.GetByUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetByUUID.GetByUUIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetByUUID.t.Fatal("No results are set for the ParkingRepositoryMock.GetByUUID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).pp1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetByUUID.funcGetByUUID != nil </span><span class="cov0" title="0">{
                return mmGetByUUID.funcGetByUUID(uuid)
        }</span>
        <span class="cov0" title="0">mmGetByUUID.t.Fatalf("Unexpected call to ParkingRepositoryMock.GetByUUID. %v", uuid)
        return</span>
}

// GetByUUIDAfterCounter returns a count of finished ParkingRepositoryMock.GetByUUID invocations
func (mmGetByUUID *ParkingRepositoryMock) GetByUUIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByUUID.afterGetByUUIDCounter)
}</span>

// GetByUUIDBeforeCounter returns a count of ParkingRepositoryMock.GetByUUID invocations
func (mmGetByUUID *ParkingRepositoryMock) GetByUUIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByUUID.beforeGetByUUIDCounter)
}</span>

// Calls returns a list of arguments used in each call to ParkingRepositoryMock.GetByUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByUUID *mParkingRepositoryMockGetByUUID) Calls() []*ParkingRepositoryMockGetByUUIDParams <span class="cov0" title="0">{
        mmGetByUUID.mutex.RLock()

        argCopy := make([]*ParkingRepositoryMockGetByUUIDParams, len(mmGetByUUID.callArgs))
        copy(argCopy, mmGetByUUID.callArgs)

        mmGetByUUID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetByUUIDDone returns true if the count of the GetByUUID invocations corresponds
// the number of defined expectations
func (m *ParkingRepositoryMock) MinimockGetByUUIDDone() bool <span class="cov0" title="0">{
        if m.GetByUUIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetByUUIDMock.invocationsDone()</span>
}

// MinimockGetByUUIDInspect logs each unmet expectation
func (m *ParkingRepositoryMock) MinimockGetByUUIDInspect() <span class="cov0" title="0">{
        for _, e := range m.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ParkingRepositoryMock.GetByUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetByUUIDCounter := mm_atomic.LoadUint64(&amp;m.afterGetByUUIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetByUUIDMock.defaultExpectation != nil &amp;&amp; afterGetByUUIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetByUUIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ParkingRepositoryMock.GetByUUID at\n%s", m.GetByUUIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ParkingRepositoryMock.GetByUUID at\n%s with params: %#v", m.GetByUUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByUUIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetByUUID != nil &amp;&amp; afterGetByUUIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ParkingRepositoryMock.GetByUUID at\n%s", m.funcGetByUUIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetByUUIDMock.invocationsDone() &amp;&amp; afterGetByUUIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ParkingRepositoryMock.GetByUUID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetByUUIDMock.expectedInvocations), m.GetByUUIDMock.expectedInvocationsOrigin, afterGetByUUIDCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ParkingRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddInspect()

                        m.MinimockGetByUUIDInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ParkingRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ParkingRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockAddDone() &amp;&amp;
                m.MinimockGetByUUIDDone()
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain/repositories.SessionRepository -o session_repository_mock_test.go -n SessionRepositoryMock -p mocks

import (
        "k071123/internal/services/parking_service/domain/models"
        mm_repositories "k071123/internal/services/parking_service/domain/repositories"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "github.com/google/uuid"
)

// SessionRepositoryMock implements mm_repositories.SessionRepository
type SessionRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAdd          func(model *models.Session) (err error)
        funcAddOrigin    string
        inspectFuncAdd   func(model *models.Session)
        afterAddCounter  uint64
        beforeAddCounter uint64
        AddMock          mSessionRepositoryMockAdd

        funcFilter          func() (s1 mm_repositories.SessionFilter)
        funcFilterOrigin    string
        inspectFuncFilter   func()
        afterFilterCounter  uint64
        beforeFilterCounter uint64
        FilterMock          mSessionRepositoryMockFilter

        funcGetByUUID          func(uuid string) (sp1 *models.Session, err error)
        funcGetByUUIDOrigin    string
        inspectFuncGetByUUID   func(uuid string)
        afterGetByUUIDCounter  uint64
        beforeGetByUUIDCounter uint64
        GetByUUIDMock          mSessionRepositoryMockGetByUUID

        funcUpdate          func(uuid uuid.UUID, updates mm_repositories.SessionUpdates) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(uuid uuid.UUID, updates mm_repositories.SessionUpdates)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mSessionRepositoryMockUpdate

        funcUpdates          func() (s1 mm_repositories.SessionUpdates)
        funcUpdatesOrigin    string
        inspectFuncUpdates   func()
        afterUpdatesCounter  uint64
        beforeUpdatesCounter uint64
        UpdatesMock          mSessionRepositoryMockUpdates

        funcWhereFilter          func(filter mm_repositories.SessionFilter) (sa1 []models.Session, err error)
        funcWhereFilterOrigin    string
        inspectFuncWhereFilter   func(filter mm_repositories.SessionFilter)
        afterWhereFilterCounter  uint64
        beforeWhereFilterCounter uint64
        WhereFilterMock          mSessionRepositoryMockWhereFilter
}

// NewSessionRepositoryMock returns a mock for mm_repositories.SessionRepository
func NewSessionRepositoryMock(t minimock.Tester) *SessionRepositoryMock <span class="cov0" title="0">{
        m := &amp;SessionRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.AddMock = mSessionRepositoryMockAdd{mock: m}
        m.AddMock.callArgs = []*SessionRepositoryMockAddParams{}

        m.FilterMock = mSessionRepositoryMockFilter{mock: m}

        m.GetByUUIDMock = mSessionRepositoryMockGetByUUID{mock: m}
        m.GetByUUIDMock.callArgs = []*SessionRepositoryMockGetByUUIDParams{}

        m.UpdateMock = mSessionRepositoryMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*SessionRepositoryMockUpdateParams{}

        m.UpdatesMock = mSessionRepositoryMockUpdates{mock: m}

        m.WhereFilterMock = mSessionRepositoryMockWhereFilter{mock: m}
        m.WhereFilterMock.callArgs = []*SessionRepositoryMockWhereFilterParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mSessionRepositoryMockAdd struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockAddExpectation
        expectations       []*SessionRepositoryMockAddExpectation

        callArgs []*SessionRepositoryMockAddParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockAddExpectation specifies expectation struct of the SessionRepository.Add
type SessionRepositoryMockAddExpectation struct {
        mock               *SessionRepositoryMock
        params             *SessionRepositoryMockAddParams
        paramPtrs          *SessionRepositoryMockAddParamPtrs
        expectationOrigins SessionRepositoryMockAddExpectationOrigins
        results            *SessionRepositoryMockAddResults
        returnOrigin       string
        Counter            uint64
}

// SessionRepositoryMockAddParams contains parameters of the SessionRepository.Add
type SessionRepositoryMockAddParams struct {
        model *models.Session
}

// SessionRepositoryMockAddParamPtrs contains pointers to parameters of the SessionRepository.Add
type SessionRepositoryMockAddParamPtrs struct {
        model **models.Session
}

// SessionRepositoryMockAddResults contains results of the SessionRepository.Add
type SessionRepositoryMockAddResults struct {
        err error
}

// SessionRepositoryMockAddOrigins contains origins of expectations of the SessionRepository.Add
type SessionRepositoryMockAddExpectationOrigins struct {
        origin      string
        originModel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mSessionRepositoryMockAdd) Optional() *mSessionRepositoryMockAdd <span class="cov0" title="0">{
        mmAdd.optional = true
        return mmAdd
}</span>

// Expect sets up expected params for SessionRepository.Add
func (mmAdd *mSessionRepositoryMockAdd) Expect(model *models.Session) *mSessionRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("SessionRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;SessionRepositoryMockAddExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("SessionRepositoryMock.Add mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmAdd.defaultExpectation.params = &amp;SessionRepositoryMockAddParams{model}
        mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmAdd.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAdd.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmAdd</span>
}

// ExpectModelParam1 sets up expected param model for SessionRepository.Add
func (mmAdd *mSessionRepositoryMockAdd) ExpectModelParam1(model *models.Session) *mSessionRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("SessionRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;SessionRepositoryMockAddExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("SessionRepositoryMock.Add mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockAddParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAdd.defaultExpectation.paramPtrs.model = &amp;model
        mmAdd.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

        return mmAdd</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.Add
func (mmAdd *mSessionRepositoryMockAdd) Inspect(f func(model *models.Session)) *mSessionRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.inspectFuncAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.Add")
        }</span>

        <span class="cov0" title="0">mmAdd.mock.inspectFuncAdd = f

        return mmAdd</span>
}

// Return sets up results that will be returned by SessionRepository.Add
func (mmAdd *mSessionRepositoryMockAdd) Return(err error) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("SessionRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;SessionRepositoryMockAddExpectation{mock: mmAdd.mock}
        }</span>
        <span class="cov0" title="0">mmAdd.defaultExpectation.results = &amp;SessionRepositoryMockAddResults{err}
        mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmAdd.mock</span>
}

// Set uses given function f to mock the SessionRepository.Add method
func (mmAdd *mSessionRepositoryMockAdd) Set(f func(model *models.Session) (err error)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmAdd.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Default expectation is already set for the SessionRepository.Add method")
        }</span>

        <span class="cov0" title="0">if len(mmAdd.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Some expectations are already set for the SessionRepository.Add method")
        }</span>

        <span class="cov0" title="0">mmAdd.mock.funcAdd = f
        mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
        return mmAdd.mock</span>
}

// When sets expectation for the SessionRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mSessionRepositoryMockAdd) When(model *models.Session) *SessionRepositoryMockAddExpectation <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("SessionRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionRepositoryMockAddExpectation{
                mock:               mmAdd.mock,
                params:             &amp;SessionRepositoryMockAddParams{model},
                expectationOrigins: SessionRepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmAdd.expectations = append(mmAdd.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionRepository.Add return parameters for the expectation previously defined by the When method
func (e *SessionRepositoryMockAddExpectation) Then(err error) *SessionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;SessionRepositoryMockAddResults{err}
        return e.mock
}</span>

// Times sets number of times SessionRepository.Add should be invoked
func (mmAdd *mSessionRepositoryMockAdd) Times(n uint64) *mSessionRepositoryMockAdd <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Times of SessionRepositoryMock.Add mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAdd.expectedInvocations, n)
        mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmAdd</span>
}

func (mmAdd *mSessionRepositoryMockAdd) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmAdd.expectations) == 0 &amp;&amp; mmAdd.defaultExpectation == nil &amp;&amp; mmAdd.mock.funcAdd == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmAdd.mock.afterAddCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAdd.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Add implements mm_repositories.SessionRepository
func (mmAdd *SessionRepositoryMock) Add(model *models.Session) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmAdd.beforeAddCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAdd.afterAddCounter, 1)

        mmAdd.t.Helper()

        if mmAdd.inspectFuncAdd != nil </span><span class="cov0" title="0">{
                mmAdd.inspectFuncAdd(model)
        }</span>

        <span class="cov0" title="0">mm_params := SessionRepositoryMockAddParams{model}

        // Record call args
        mmAdd.AddMock.mutex.Lock()
        mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &amp;mm_params)
        mmAdd.AddMock.mutex.Unlock()

        for _, e := range mmAdd.AddMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmAdd.AddMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmAdd.AddMock.defaultExpectation.Counter, 1)
                mm_want := mmAdd.AddMock.defaultExpectation.params
                mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

                mm_got := SessionRepositoryMockAddParams{model}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.model != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.model, mm_got.model) </span><span class="cov0" title="0">{
                                mmAdd.t.Errorf("SessionRepositoryMock.Add got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAdd.AddMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAdd.t.Errorf("SessionRepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmAdd.AddMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAdd.t.Fatal("No results are set for the SessionRepositoryMock.Add")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAdd.funcAdd != nil </span><span class="cov0" title="0">{
                return mmAdd.funcAdd(model)
        }</span>
        <span class="cov0" title="0">mmAdd.t.Fatalf("Unexpected call to SessionRepositoryMock.Add. %v", model)
        return</span>
}

// AddAfterCounter returns a count of finished SessionRepositoryMock.Add invocations
func (mmAdd *SessionRepositoryMock) AddAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAdd.afterAddCounter)
}</span>

// AddBeforeCounter returns a count of SessionRepositoryMock.Add invocations
func (mmAdd *SessionRepositoryMock) AddBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAdd.beforeAddCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mSessionRepositoryMockAdd) Calls() []*SessionRepositoryMockAddParams <span class="cov0" title="0">{
        mmAdd.mutex.RLock()

        argCopy := make([]*SessionRepositoryMockAddParams, len(mmAdd.callArgs))
        copy(argCopy, mmAdd.callArgs)

        mmAdd.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockAddDone() bool <span class="cov0" title="0">{
        if m.AddMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.AddMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.AddMock.invocationsDone()</span>
}

// MinimockAddInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockAddInspect() <span class="cov0" title="0">{
        for _, e := range m.AddMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddCounter := mm_atomic.LoadUint64(&amp;m.afterAddCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddMock.defaultExpectation != nil &amp;&amp; afterAddCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionRepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAdd != nil &amp;&amp; afterAddCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.Add at\n%s", m.funcAddOrigin)
        }</span>

        <span class="cov0" title="0">if !m.AddMock.invocationsDone() &amp;&amp; afterAddCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.Add at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
        }</span>
}

type mSessionRepositoryMockFilter struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockFilterExpectation
        expectations       []*SessionRepositoryMockFilterExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockFilterExpectation specifies expectation struct of the SessionRepository.Filter
type SessionRepositoryMockFilterExpectation struct {
        mock *SessionRepositoryMock

        results      *SessionRepositoryMockFilterResults
        returnOrigin string
        Counter      uint64
}

// SessionRepositoryMockFilterResults contains results of the SessionRepository.Filter
type SessionRepositoryMockFilterResults struct {
        s1 mm_repositories.SessionFilter
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFilter *mSessionRepositoryMockFilter) Optional() *mSessionRepositoryMockFilter <span class="cov0" title="0">{
        mmFilter.optional = true
        return mmFilter
}</span>

// Expect sets up expected params for SessionRepository.Filter
func (mmFilter *mSessionRepositoryMockFilter) Expect() *mSessionRepositoryMockFilter <span class="cov0" title="0">{
        if mmFilter.mock.funcFilter != nil </span><span class="cov0" title="0">{
                mmFilter.mock.t.Fatalf("SessionRepositoryMock.Filter mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFilter.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFilter.defaultExpectation = &amp;SessionRepositoryMockFilterExpectation{}
        }</span>

        <span class="cov0" title="0">return mmFilter</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.Filter
func (mmFilter *mSessionRepositoryMockFilter) Inspect(f func()) *mSessionRepositoryMockFilter <span class="cov0" title="0">{
        if mmFilter.mock.inspectFuncFilter != nil </span><span class="cov0" title="0">{
                mmFilter.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.Filter")
        }</span>

        <span class="cov0" title="0">mmFilter.mock.inspectFuncFilter = f

        return mmFilter</span>
}

// Return sets up results that will be returned by SessionRepository.Filter
func (mmFilter *mSessionRepositoryMockFilter) Return(s1 mm_repositories.SessionFilter) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmFilter.mock.funcFilter != nil </span><span class="cov0" title="0">{
                mmFilter.mock.t.Fatalf("SessionRepositoryMock.Filter mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmFilter.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmFilter.defaultExpectation = &amp;SessionRepositoryMockFilterExpectation{mock: mmFilter.mock}
        }</span>
        <span class="cov0" title="0">mmFilter.defaultExpectation.results = &amp;SessionRepositoryMockFilterResults{s1}
        mmFilter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmFilter.mock</span>
}

// Set uses given function f to mock the SessionRepository.Filter method
func (mmFilter *mSessionRepositoryMockFilter) Set(f func() (s1 mm_repositories.SessionFilter)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmFilter.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmFilter.mock.t.Fatalf("Default expectation is already set for the SessionRepository.Filter method")
        }</span>

        <span class="cov0" title="0">if len(mmFilter.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmFilter.mock.t.Fatalf("Some expectations are already set for the SessionRepository.Filter method")
        }</span>

        <span class="cov0" title="0">mmFilter.mock.funcFilter = f
        mmFilter.mock.funcFilterOrigin = minimock.CallerInfo(1)
        return mmFilter.mock</span>
}

// Times sets number of times SessionRepository.Filter should be invoked
func (mmFilter *mSessionRepositoryMockFilter) Times(n uint64) *mSessionRepositoryMockFilter <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmFilter.mock.t.Fatalf("Times of SessionRepositoryMock.Filter mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmFilter.expectedInvocations, n)
        mmFilter.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmFilter</span>
}

func (mmFilter *mSessionRepositoryMockFilter) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmFilter.expectations) == 0 &amp;&amp; mmFilter.defaultExpectation == nil &amp;&amp; mmFilter.mock.funcFilter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmFilter.mock.afterFilterCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmFilter.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Filter implements mm_repositories.SessionRepository
func (mmFilter *SessionRepositoryMock) Filter() (s1 mm_repositories.SessionFilter) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmFilter.beforeFilterCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmFilter.afterFilterCounter, 1)

        mmFilter.t.Helper()

        if mmFilter.inspectFuncFilter != nil </span><span class="cov0" title="0">{
                mmFilter.inspectFuncFilter()
        }</span>

        <span class="cov0" title="0">if mmFilter.FilterMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmFilter.FilterMock.defaultExpectation.Counter, 1)

                mm_results := mmFilter.FilterMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmFilter.t.Fatal("No results are set for the SessionRepositoryMock.Filter")
                }</span>
                <span class="cov0" title="0">return (*mm_results).s1</span>
        }
        <span class="cov0" title="0">if mmFilter.funcFilter != nil </span><span class="cov0" title="0">{
                return mmFilter.funcFilter()
        }</span>
        <span class="cov0" title="0">mmFilter.t.Fatalf("Unexpected call to SessionRepositoryMock.Filter.")
        return</span>
}

// FilterAfterCounter returns a count of finished SessionRepositoryMock.Filter invocations
func (mmFilter *SessionRepositoryMock) FilterAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFilter.afterFilterCounter)
}</span>

// FilterBeforeCounter returns a count of SessionRepositoryMock.Filter invocations
func (mmFilter *SessionRepositoryMock) FilterBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmFilter.beforeFilterCounter)
}</span>

// MinimockFilterDone returns true if the count of the Filter invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockFilterDone() bool <span class="cov0" title="0">{
        if m.FilterMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.FilterMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.FilterMock.invocationsDone()</span>
}

// MinimockFilterInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockFilterInspect() <span class="cov0" title="0">{
        for _, e := range m.FilterMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to SessionRepositoryMock.Filter")
                }</span>
        }

        <span class="cov0" title="0">afterFilterCounter := mm_atomic.LoadUint64(&amp;m.afterFilterCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.FilterMock.defaultExpectation != nil &amp;&amp; afterFilterCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.Filter at\n%s", m.FilterMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcFilter != nil &amp;&amp; afterFilterCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.Filter at\n%s", m.funcFilterOrigin)
        }</span>

        <span class="cov0" title="0">if !m.FilterMock.invocationsDone() &amp;&amp; afterFilterCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.Filter at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.FilterMock.expectedInvocations), m.FilterMock.expectedInvocationsOrigin, afterFilterCounter)
        }</span>
}

type mSessionRepositoryMockGetByUUID struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockGetByUUIDExpectation
        expectations       []*SessionRepositoryMockGetByUUIDExpectation

        callArgs []*SessionRepositoryMockGetByUUIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockGetByUUIDExpectation specifies expectation struct of the SessionRepository.GetByUUID
type SessionRepositoryMockGetByUUIDExpectation struct {
        mock               *SessionRepositoryMock
        params             *SessionRepositoryMockGetByUUIDParams
        paramPtrs          *SessionRepositoryMockGetByUUIDParamPtrs
        expectationOrigins SessionRepositoryMockGetByUUIDExpectationOrigins
        results            *SessionRepositoryMockGetByUUIDResults
        returnOrigin       string
        Counter            uint64
}

// SessionRepositoryMockGetByUUIDParams contains parameters of the SessionRepository.GetByUUID
type SessionRepositoryMockGetByUUIDParams struct {
        uuid string
}

// SessionRepositoryMockGetByUUIDParamPtrs contains pointers to parameters of the SessionRepository.GetByUUID
type SessionRepositoryMockGetByUUIDParamPtrs struct {
        uuid *string
}

// SessionRepositoryMockGetByUUIDResults contains results of the SessionRepository.GetByUUID
type SessionRepositoryMockGetByUUIDResults struct {
        sp1 *models.Session
        err error
}

// SessionRepositoryMockGetByUUIDOrigins contains origins of expectations of the SessionRepository.GetByUUID
type SessionRepositoryMockGetByUUIDExpectationOrigins struct {
        origin     string
        originUuid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) Optional() *mSessionRepositoryMockGetByUUID <span class="cov0" title="0">{
        mmGetByUUID.optional = true
        return mmGetByUUID
}</span>

// Expect sets up expected params for SessionRepository.GetByUUID
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) Expect(uuid string) *mSessionRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("SessionRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;SessionRepositoryMockGetByUUIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("SessionRepositoryMock.GetByUUID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.params = &amp;SessionRepositoryMockGetByUUIDParams{uuid}
        mmGetByUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetByUUID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetByUUID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetByUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByUUID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetByUUID</span>
}

// ExpectUuidParam1 sets up expected param uuid for SessionRepository.GetByUUID
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) ExpectUuidParam1(uuid string) *mSessionRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("SessionRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;SessionRepositoryMockGetByUUIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("SessionRepositoryMock.GetByUUID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockGetByUUIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.paramPtrs.uuid = &amp;uuid
        mmGetByUUID.defaultExpectation.expectationOrigins.originUuid = minimock.CallerInfo(1)

        return mmGetByUUID</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.GetByUUID
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) Inspect(f func(uuid string)) *mSessionRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.inspectFuncGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.GetByUUID")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.mock.inspectFuncGetByUUID = f

        return mmGetByUUID</span>
}

// Return sets up results that will be returned by SessionRepository.GetByUUID
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) Return(sp1 *models.Session, err error) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("SessionRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;SessionRepositoryMockGetByUUIDExpectation{mock: mmGetByUUID.mock}
        }</span>
        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.results = &amp;SessionRepositoryMockGetByUUIDResults{sp1, err}
        mmGetByUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetByUUID.mock</span>
}

// Set uses given function f to mock the SessionRepository.GetByUUID method
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) Set(f func(uuid string) (sp1 *models.Session, err error)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmGetByUUID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Default expectation is already set for the SessionRepository.GetByUUID method")
        }</span>

        <span class="cov0" title="0">if len(mmGetByUUID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Some expectations are already set for the SessionRepository.GetByUUID method")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.mock.funcGetByUUID = f
        mmGetByUUID.mock.funcGetByUUIDOrigin = minimock.CallerInfo(1)
        return mmGetByUUID.mock</span>
}

// When sets expectation for the SessionRepository.GetByUUID which will trigger the result defined by the following
// Then helper
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) When(uuid string) *SessionRepositoryMockGetByUUIDExpectation <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("SessionRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionRepositoryMockGetByUUIDExpectation{
                mock:               mmGetByUUID.mock,
                params:             &amp;SessionRepositoryMockGetByUUIDParams{uuid},
                expectationOrigins: SessionRepositoryMockGetByUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetByUUID.expectations = append(mmGetByUUID.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionRepository.GetByUUID return parameters for the expectation previously defined by the When method
func (e *SessionRepositoryMockGetByUUIDExpectation) Then(sp1 *models.Session, err error) *SessionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;SessionRepositoryMockGetByUUIDResults{sp1, err}
        return e.mock
}</span>

// Times sets number of times SessionRepository.GetByUUID should be invoked
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) Times(n uint64) *mSessionRepositoryMockGetByUUID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Times of SessionRepositoryMock.GetByUUID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetByUUID.expectedInvocations, n)
        mmGetByUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetByUUID</span>
}

func (mmGetByUUID *mSessionRepositoryMockGetByUUID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGetByUUID.expectations) == 0 &amp;&amp; mmGetByUUID.defaultExpectation == nil &amp;&amp; mmGetByUUID.mock.funcGetByUUID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetByUUID.mock.afterGetByUUIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetByUUID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetByUUID implements mm_repositories.SessionRepository
func (mmGetByUUID *SessionRepositoryMock) GetByUUID(uuid string) (sp1 *models.Session, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetByUUID.beforeGetByUUIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetByUUID.afterGetByUUIDCounter, 1)

        mmGetByUUID.t.Helper()

        if mmGetByUUID.inspectFuncGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.inspectFuncGetByUUID(uuid)
        }</span>

        <span class="cov0" title="0">mm_params := SessionRepositoryMockGetByUUIDParams{uuid}

        // Record call args
        mmGetByUUID.GetByUUIDMock.mutex.Lock()
        mmGetByUUID.GetByUUIDMock.callArgs = append(mmGetByUUID.GetByUUIDMock.callArgs, &amp;mm_params)
        mmGetByUUID.GetByUUIDMock.mutex.Unlock()

        for _, e := range mmGetByUUID.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.sp1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetByUUID.GetByUUIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetByUUID.GetByUUIDMock.defaultExpectation.Counter, 1)
                mm_want := mmGetByUUID.GetByUUIDMock.defaultExpectation.params
                mm_want_ptrs := mmGetByUUID.GetByUUIDMock.defaultExpectation.paramPtrs

                mm_got := SessionRepositoryMockGetByUUIDParams{uuid}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.uuid != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.uuid, mm_got.uuid) </span><span class="cov0" title="0">{
                                mmGetByUUID.t.Errorf("SessionRepositoryMock.GetByUUID got unexpected parameter uuid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByUUID.GetByUUIDMock.defaultExpectation.expectationOrigins.originUuid, *mm_want_ptrs.uuid, mm_got.uuid, minimock.Diff(*mm_want_ptrs.uuid, mm_got.uuid))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetByUUID.t.Errorf("SessionRepositoryMock.GetByUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetByUUID.GetByUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetByUUID.GetByUUIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetByUUID.t.Fatal("No results are set for the SessionRepositoryMock.GetByUUID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).sp1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetByUUID.funcGetByUUID != nil </span><span class="cov0" title="0">{
                return mmGetByUUID.funcGetByUUID(uuid)
        }</span>
        <span class="cov0" title="0">mmGetByUUID.t.Fatalf("Unexpected call to SessionRepositoryMock.GetByUUID. %v", uuid)
        return</span>
}

// GetByUUIDAfterCounter returns a count of finished SessionRepositoryMock.GetByUUID invocations
func (mmGetByUUID *SessionRepositoryMock) GetByUUIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByUUID.afterGetByUUIDCounter)
}</span>

// GetByUUIDBeforeCounter returns a count of SessionRepositoryMock.GetByUUID invocations
func (mmGetByUUID *SessionRepositoryMock) GetByUUIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByUUID.beforeGetByUUIDCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionRepositoryMock.GetByUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByUUID *mSessionRepositoryMockGetByUUID) Calls() []*SessionRepositoryMockGetByUUIDParams <span class="cov0" title="0">{
        mmGetByUUID.mutex.RLock()

        argCopy := make([]*SessionRepositoryMockGetByUUIDParams, len(mmGetByUUID.callArgs))
        copy(argCopy, mmGetByUUID.callArgs)

        mmGetByUUID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetByUUIDDone returns true if the count of the GetByUUID invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockGetByUUIDDone() bool <span class="cov0" title="0">{
        if m.GetByUUIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetByUUIDMock.invocationsDone()</span>
}

// MinimockGetByUUIDInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockGetByUUIDInspect() <span class="cov0" title="0">{
        for _, e := range m.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.GetByUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetByUUIDCounter := mm_atomic.LoadUint64(&amp;m.afterGetByUUIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetByUUIDMock.defaultExpectation != nil &amp;&amp; afterGetByUUIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetByUUIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.GetByUUID at\n%s", m.GetByUUIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionRepositoryMock.GetByUUID at\n%s with params: %#v", m.GetByUUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByUUIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetByUUID != nil &amp;&amp; afterGetByUUIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.GetByUUID at\n%s", m.funcGetByUUIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetByUUIDMock.invocationsDone() &amp;&amp; afterGetByUUIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.GetByUUID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetByUUIDMock.expectedInvocations), m.GetByUUIDMock.expectedInvocationsOrigin, afterGetByUUIDCounter)
        }</span>
}

type mSessionRepositoryMockUpdate struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockUpdateExpectation
        expectations       []*SessionRepositoryMockUpdateExpectation

        callArgs []*SessionRepositoryMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockUpdateExpectation specifies expectation struct of the SessionRepository.Update
type SessionRepositoryMockUpdateExpectation struct {
        mock               *SessionRepositoryMock
        params             *SessionRepositoryMockUpdateParams
        paramPtrs          *SessionRepositoryMockUpdateParamPtrs
        expectationOrigins SessionRepositoryMockUpdateExpectationOrigins
        results            *SessionRepositoryMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// SessionRepositoryMockUpdateParams contains parameters of the SessionRepository.Update
type SessionRepositoryMockUpdateParams struct {
        uuid    uuid.UUID
        updates mm_repositories.SessionUpdates
}

// SessionRepositoryMockUpdateParamPtrs contains pointers to parameters of the SessionRepository.Update
type SessionRepositoryMockUpdateParamPtrs struct {
        uuid    *uuid.UUID
        updates *mm_repositories.SessionUpdates
}

// SessionRepositoryMockUpdateResults contains results of the SessionRepository.Update
type SessionRepositoryMockUpdateResults struct {
        err error
}

// SessionRepositoryMockUpdateOrigins contains origins of expectations of the SessionRepository.Update
type SessionRepositoryMockUpdateExpectationOrigins struct {
        origin        string
        originUuid    string
        originUpdates string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mSessionRepositoryMockUpdate) Optional() *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) Expect(uuid uuid.UUID, updates mm_repositories.SessionUpdates) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdate.defaultExpectation.params = &amp;SessionRepositoryMockUpdateParams{uuid, updates}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdate</span>
}

// ExpectUuidParam1 sets up expected param uuid for SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) ExpectUuidParam1(uuid uuid.UUID) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.uuid = &amp;uuid
        mmUpdate.defaultExpectation.expectationOrigins.originUuid = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectUpdatesParam2 sets up expected param updates for SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) ExpectUpdatesParam2(updates mm_repositories.SessionUpdates) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.updates = &amp;updates
        mmUpdate.defaultExpectation.expectationOrigins.originUpdates = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) Inspect(f func(uuid uuid.UUID, updates mm_repositories.SessionUpdates)) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by SessionRepository.Update
func (mmUpdate *mSessionRepositoryMockUpdate) Return(err error) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;SessionRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.results = &amp;SessionRepositoryMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the SessionRepository.Update method
func (mmUpdate *mSessionRepositoryMockUpdate) Set(f func(uuid uuid.UUID, updates mm_repositories.SessionUpdates) (err error)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the SessionRepository.Update method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the SessionRepository.Update method")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the SessionRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mSessionRepositoryMockUpdate) When(uuid uuid.UUID, updates mm_repositories.SessionUpdates) *SessionRepositoryMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("SessionRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionRepositoryMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;SessionRepositoryMockUpdateParams{uuid, updates},
                expectationOrigins: SessionRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionRepository.Update return parameters for the expectation previously defined by the When method
func (e *SessionRepositoryMockUpdateExpectation) Then(err error) *SessionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;SessionRepositoryMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times SessionRepository.Update should be invoked
func (mmUpdate *mSessionRepositoryMockUpdate) Times(n uint64) *mSessionRepositoryMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of SessionRepositoryMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mSessionRepositoryMockUpdate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_repositories.SessionRepository
func (mmUpdate *SessionRepositoryMock) Update(uuid uuid.UUID, updates mm_repositories.SessionUpdates) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(uuid, updates)
        }</span>

        <span class="cov0" title="0">mm_params := SessionRepositoryMockUpdateParams{uuid, updates}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := SessionRepositoryMockUpdateParams{uuid, updates}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.uuid != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.uuid, mm_got.uuid) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("SessionRepositoryMock.Update got unexpected parameter uuid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUuid, *mm_want_ptrs.uuid, mm_got.uuid, minimock.Diff(*mm_want_ptrs.uuid, mm_got.uuid))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.updates != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.updates, mm_got.updates) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("SessionRepositoryMock.Update got unexpected parameter updates, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdates, *mm_want_ptrs.updates, mm_got.updates, minimock.Diff(*mm_want_ptrs.updates, mm_got.updates))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("SessionRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the SessionRepositoryMock.Update")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdate.funcUpdate != nil </span><span class="cov0" title="0">{
                return mmUpdate.funcUpdate(uuid, updates)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to SessionRepositoryMock.Update. %v %v", uuid, updates)
        return</span>
}

// UpdateAfterCounter returns a count of finished SessionRepositoryMock.Update invocations
func (mmUpdate *SessionRepositoryMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of SessionRepositoryMock.Update invocations
func (mmUpdate *SessionRepositoryMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mSessionRepositoryMockUpdate) Calls() []*SessionRepositoryMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*SessionRepositoryMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockUpdateDone() bool <span class="cov0" title="0">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

type mSessionRepositoryMockUpdates struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockUpdatesExpectation
        expectations       []*SessionRepositoryMockUpdatesExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockUpdatesExpectation specifies expectation struct of the SessionRepository.Updates
type SessionRepositoryMockUpdatesExpectation struct {
        mock *SessionRepositoryMock

        results      *SessionRepositoryMockUpdatesResults
        returnOrigin string
        Counter      uint64
}

// SessionRepositoryMockUpdatesResults contains results of the SessionRepository.Updates
type SessionRepositoryMockUpdatesResults struct {
        s1 mm_repositories.SessionUpdates
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdates *mSessionRepositoryMockUpdates) Optional() *mSessionRepositoryMockUpdates <span class="cov0" title="0">{
        mmUpdates.optional = true
        return mmUpdates
}</span>

// Expect sets up expected params for SessionRepository.Updates
func (mmUpdates *mSessionRepositoryMockUpdates) Expect() *mSessionRepositoryMockUpdates <span class="cov0" title="0">{
        if mmUpdates.mock.funcUpdates != nil </span><span class="cov0" title="0">{
                mmUpdates.mock.t.Fatalf("SessionRepositoryMock.Updates mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdates.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdates.defaultExpectation = &amp;SessionRepositoryMockUpdatesExpectation{}
        }</span>

        <span class="cov0" title="0">return mmUpdates</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.Updates
func (mmUpdates *mSessionRepositoryMockUpdates) Inspect(f func()) *mSessionRepositoryMockUpdates <span class="cov0" title="0">{
        if mmUpdates.mock.inspectFuncUpdates != nil </span><span class="cov0" title="0">{
                mmUpdates.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.Updates")
        }</span>

        <span class="cov0" title="0">mmUpdates.mock.inspectFuncUpdates = f

        return mmUpdates</span>
}

// Return sets up results that will be returned by SessionRepository.Updates
func (mmUpdates *mSessionRepositoryMockUpdates) Return(s1 mm_repositories.SessionUpdates) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmUpdates.mock.funcUpdates != nil </span><span class="cov0" title="0">{
                mmUpdates.mock.t.Fatalf("SessionRepositoryMock.Updates mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdates.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdates.defaultExpectation = &amp;SessionRepositoryMockUpdatesExpectation{mock: mmUpdates.mock}
        }</span>
        <span class="cov0" title="0">mmUpdates.defaultExpectation.results = &amp;SessionRepositoryMockUpdatesResults{s1}
        mmUpdates.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdates.mock</span>
}

// Set uses given function f to mock the SessionRepository.Updates method
func (mmUpdates *mSessionRepositoryMockUpdates) Set(f func() (s1 mm_repositories.SessionUpdates)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmUpdates.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdates.mock.t.Fatalf("Default expectation is already set for the SessionRepository.Updates method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdates.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdates.mock.t.Fatalf("Some expectations are already set for the SessionRepository.Updates method")
        }</span>

        <span class="cov0" title="0">mmUpdates.mock.funcUpdates = f
        mmUpdates.mock.funcUpdatesOrigin = minimock.CallerInfo(1)
        return mmUpdates.mock</span>
}

// Times sets number of times SessionRepository.Updates should be invoked
func (mmUpdates *mSessionRepositoryMockUpdates) Times(n uint64) *mSessionRepositoryMockUpdates <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdates.mock.t.Fatalf("Times of SessionRepositoryMock.Updates mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdates.expectedInvocations, n)
        mmUpdates.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdates</span>
}

func (mmUpdates *mSessionRepositoryMockUpdates) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdates.expectations) == 0 &amp;&amp; mmUpdates.defaultExpectation == nil &amp;&amp; mmUpdates.mock.funcUpdates == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdates.mock.afterUpdatesCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdates.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Updates implements mm_repositories.SessionRepository
func (mmUpdates *SessionRepositoryMock) Updates() (s1 mm_repositories.SessionUpdates) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdates.beforeUpdatesCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdates.afterUpdatesCounter, 1)

        mmUpdates.t.Helper()

        if mmUpdates.inspectFuncUpdates != nil </span><span class="cov0" title="0">{
                mmUpdates.inspectFuncUpdates()
        }</span>

        <span class="cov0" title="0">if mmUpdates.UpdatesMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdates.UpdatesMock.defaultExpectation.Counter, 1)

                mm_results := mmUpdates.UpdatesMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdates.t.Fatal("No results are set for the SessionRepositoryMock.Updates")
                }</span>
                <span class="cov0" title="0">return (*mm_results).s1</span>
        }
        <span class="cov0" title="0">if mmUpdates.funcUpdates != nil </span><span class="cov0" title="0">{
                return mmUpdates.funcUpdates()
        }</span>
        <span class="cov0" title="0">mmUpdates.t.Fatalf("Unexpected call to SessionRepositoryMock.Updates.")
        return</span>
}

// UpdatesAfterCounter returns a count of finished SessionRepositoryMock.Updates invocations
func (mmUpdates *SessionRepositoryMock) UpdatesAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdates.afterUpdatesCounter)
}</span>

// UpdatesBeforeCounter returns a count of SessionRepositoryMock.Updates invocations
func (mmUpdates *SessionRepositoryMock) UpdatesBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdates.beforeUpdatesCounter)
}</span>

// MinimockUpdatesDone returns true if the count of the Updates invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockUpdatesDone() bool <span class="cov0" title="0">{
        if m.UpdatesMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdatesMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdatesMock.invocationsDone()</span>
}

// MinimockUpdatesInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockUpdatesInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdatesMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to SessionRepositoryMock.Updates")
                }</span>
        }

        <span class="cov0" title="0">afterUpdatesCounter := mm_atomic.LoadUint64(&amp;m.afterUpdatesCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdatesMock.defaultExpectation != nil &amp;&amp; afterUpdatesCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.Updates at\n%s", m.UpdatesMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdates != nil &amp;&amp; afterUpdatesCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.Updates at\n%s", m.funcUpdatesOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdatesMock.invocationsDone() &amp;&amp; afterUpdatesCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.Updates at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdatesMock.expectedInvocations), m.UpdatesMock.expectedInvocationsOrigin, afterUpdatesCounter)
        }</span>
}

type mSessionRepositoryMockWhereFilter struct {
        optional           bool
        mock               *SessionRepositoryMock
        defaultExpectation *SessionRepositoryMockWhereFilterExpectation
        expectations       []*SessionRepositoryMockWhereFilterExpectation

        callArgs []*SessionRepositoryMockWhereFilterParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// SessionRepositoryMockWhereFilterExpectation specifies expectation struct of the SessionRepository.WhereFilter
type SessionRepositoryMockWhereFilterExpectation struct {
        mock               *SessionRepositoryMock
        params             *SessionRepositoryMockWhereFilterParams
        paramPtrs          *SessionRepositoryMockWhereFilterParamPtrs
        expectationOrigins SessionRepositoryMockWhereFilterExpectationOrigins
        results            *SessionRepositoryMockWhereFilterResults
        returnOrigin       string
        Counter            uint64
}

// SessionRepositoryMockWhereFilterParams contains parameters of the SessionRepository.WhereFilter
type SessionRepositoryMockWhereFilterParams struct {
        filter mm_repositories.SessionFilter
}

// SessionRepositoryMockWhereFilterParamPtrs contains pointers to parameters of the SessionRepository.WhereFilter
type SessionRepositoryMockWhereFilterParamPtrs struct {
        filter *mm_repositories.SessionFilter
}

// SessionRepositoryMockWhereFilterResults contains results of the SessionRepository.WhereFilter
type SessionRepositoryMockWhereFilterResults struct {
        sa1 []models.Session
        err error
}

// SessionRepositoryMockWhereFilterOrigins contains origins of expectations of the SessionRepository.WhereFilter
type SessionRepositoryMockWhereFilterExpectationOrigins struct {
        origin       string
        originFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) Optional() *mSessionRepositoryMockWhereFilter <span class="cov0" title="0">{
        mmWhereFilter.optional = true
        return mmWhereFilter
}</span>

// Expect sets up expected params for SessionRepository.WhereFilter
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) Expect(filter mm_repositories.SessionFilter) *mSessionRepositoryMockWhereFilter <span class="cov0" title="0">{
        if mmWhereFilter.mock.funcWhereFilter != nil </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("SessionRepositoryMock.WhereFilter mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWhereFilter.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWhereFilter.defaultExpectation = &amp;SessionRepositoryMockWhereFilterExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWhereFilter.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("SessionRepositoryMock.WhereFilter mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmWhereFilter.defaultExpectation.params = &amp;SessionRepositoryMockWhereFilterParams{filter}
        mmWhereFilter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmWhereFilter.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmWhereFilter.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmWhereFilter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWhereFilter.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmWhereFilter</span>
}

// ExpectFilterParam1 sets up expected param filter for SessionRepository.WhereFilter
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) ExpectFilterParam1(filter mm_repositories.SessionFilter) *mSessionRepositoryMockWhereFilter <span class="cov0" title="0">{
        if mmWhereFilter.mock.funcWhereFilter != nil </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("SessionRepositoryMock.WhereFilter mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWhereFilter.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWhereFilter.defaultExpectation = &amp;SessionRepositoryMockWhereFilterExpectation{}
        }</span>

        <span class="cov0" title="0">if mmWhereFilter.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("SessionRepositoryMock.WhereFilter mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmWhereFilter.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmWhereFilter.defaultExpectation.paramPtrs = &amp;SessionRepositoryMockWhereFilterParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmWhereFilter.defaultExpectation.paramPtrs.filter = &amp;filter
        mmWhereFilter.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

        return mmWhereFilter</span>
}

// Inspect accepts an inspector function that has same arguments as the SessionRepository.WhereFilter
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) Inspect(f func(filter mm_repositories.SessionFilter)) *mSessionRepositoryMockWhereFilter <span class="cov0" title="0">{
        if mmWhereFilter.mock.inspectFuncWhereFilter != nil </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("Inspect function is already set for SessionRepositoryMock.WhereFilter")
        }</span>

        <span class="cov0" title="0">mmWhereFilter.mock.inspectFuncWhereFilter = f

        return mmWhereFilter</span>
}

// Return sets up results that will be returned by SessionRepository.WhereFilter
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) Return(sa1 []models.Session, err error) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmWhereFilter.mock.funcWhereFilter != nil </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("SessionRepositoryMock.WhereFilter mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWhereFilter.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWhereFilter.defaultExpectation = &amp;SessionRepositoryMockWhereFilterExpectation{mock: mmWhereFilter.mock}
        }</span>
        <span class="cov0" title="0">mmWhereFilter.defaultExpectation.results = &amp;SessionRepositoryMockWhereFilterResults{sa1, err}
        mmWhereFilter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmWhereFilter.mock</span>
}

// Set uses given function f to mock the SessionRepository.WhereFilter method
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) Set(f func(filter mm_repositories.SessionFilter) (sa1 []models.Session, err error)) *SessionRepositoryMock <span class="cov0" title="0">{
        if mmWhereFilter.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("Default expectation is already set for the SessionRepository.WhereFilter method")
        }</span>

        <span class="cov0" title="0">if len(mmWhereFilter.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("Some expectations are already set for the SessionRepository.WhereFilter method")
        }</span>

        <span class="cov0" title="0">mmWhereFilter.mock.funcWhereFilter = f
        mmWhereFilter.mock.funcWhereFilterOrigin = minimock.CallerInfo(1)
        return mmWhereFilter.mock</span>
}

// When sets expectation for the SessionRepository.WhereFilter which will trigger the result defined by the following
// Then helper
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) When(filter mm_repositories.SessionFilter) *SessionRepositoryMockWhereFilterExpectation <span class="cov0" title="0">{
        if mmWhereFilter.mock.funcWhereFilter != nil </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("SessionRepositoryMock.WhereFilter mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;SessionRepositoryMockWhereFilterExpectation{
                mock:               mmWhereFilter.mock,
                params:             &amp;SessionRepositoryMockWhereFilterParams{filter},
                expectationOrigins: SessionRepositoryMockWhereFilterExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmWhereFilter.expectations = append(mmWhereFilter.expectations, expectation)
        return expectation</span>
}

// Then sets up SessionRepository.WhereFilter return parameters for the expectation previously defined by the When method
func (e *SessionRepositoryMockWhereFilterExpectation) Then(sa1 []models.Session, err error) *SessionRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;SessionRepositoryMockWhereFilterResults{sa1, err}
        return e.mock
}</span>

// Times sets number of times SessionRepository.WhereFilter should be invoked
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) Times(n uint64) *mSessionRepositoryMockWhereFilter <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmWhereFilter.mock.t.Fatalf("Times of SessionRepositoryMock.WhereFilter mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmWhereFilter.expectedInvocations, n)
        mmWhereFilter.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmWhereFilter</span>
}

func (mmWhereFilter *mSessionRepositoryMockWhereFilter) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmWhereFilter.expectations) == 0 &amp;&amp; mmWhereFilter.defaultExpectation == nil &amp;&amp; mmWhereFilter.mock.funcWhereFilter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmWhereFilter.mock.afterWhereFilterCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmWhereFilter.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// WhereFilter implements mm_repositories.SessionRepository
func (mmWhereFilter *SessionRepositoryMock) WhereFilter(filter mm_repositories.SessionFilter) (sa1 []models.Session, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmWhereFilter.beforeWhereFilterCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmWhereFilter.afterWhereFilterCounter, 1)

        mmWhereFilter.t.Helper()

        if mmWhereFilter.inspectFuncWhereFilter != nil </span><span class="cov0" title="0">{
                mmWhereFilter.inspectFuncWhereFilter(filter)
        }</span>

        <span class="cov0" title="0">mm_params := SessionRepositoryMockWhereFilterParams{filter}

        // Record call args
        mmWhereFilter.WhereFilterMock.mutex.Lock()
        mmWhereFilter.WhereFilterMock.callArgs = append(mmWhereFilter.WhereFilterMock.callArgs, &amp;mm_params)
        mmWhereFilter.WhereFilterMock.mutex.Unlock()

        for _, e := range mmWhereFilter.WhereFilterMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.sa1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmWhereFilter.WhereFilterMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmWhereFilter.WhereFilterMock.defaultExpectation.Counter, 1)
                mm_want := mmWhereFilter.WhereFilterMock.defaultExpectation.params
                mm_want_ptrs := mmWhereFilter.WhereFilterMock.defaultExpectation.paramPtrs

                mm_got := SessionRepositoryMockWhereFilterParams{filter}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.filter != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) </span><span class="cov0" title="0">{
                                mmWhereFilter.t.Errorf("SessionRepositoryMock.WhereFilter got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmWhereFilter.WhereFilterMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmWhereFilter.t.Errorf("SessionRepositoryMock.WhereFilter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmWhereFilter.WhereFilterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmWhereFilter.WhereFilterMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmWhereFilter.t.Fatal("No results are set for the SessionRepositoryMock.WhereFilter")
                }</span>
                <span class="cov0" title="0">return (*mm_results).sa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmWhereFilter.funcWhereFilter != nil </span><span class="cov0" title="0">{
                return mmWhereFilter.funcWhereFilter(filter)
        }</span>
        <span class="cov0" title="0">mmWhereFilter.t.Fatalf("Unexpected call to SessionRepositoryMock.WhereFilter. %v", filter)
        return</span>
}

// WhereFilterAfterCounter returns a count of finished SessionRepositoryMock.WhereFilter invocations
func (mmWhereFilter *SessionRepositoryMock) WhereFilterAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWhereFilter.afterWhereFilterCounter)
}</span>

// WhereFilterBeforeCounter returns a count of SessionRepositoryMock.WhereFilter invocations
func (mmWhereFilter *SessionRepositoryMock) WhereFilterBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWhereFilter.beforeWhereFilterCounter)
}</span>

// Calls returns a list of arguments used in each call to SessionRepositoryMock.WhereFilter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWhereFilter *mSessionRepositoryMockWhereFilter) Calls() []*SessionRepositoryMockWhereFilterParams <span class="cov0" title="0">{
        mmWhereFilter.mutex.RLock()

        argCopy := make([]*SessionRepositoryMockWhereFilterParams, len(mmWhereFilter.callArgs))
        copy(argCopy, mmWhereFilter.callArgs)

        mmWhereFilter.mutex.RUnlock()

        return argCopy
}</span>

// MinimockWhereFilterDone returns true if the count of the WhereFilter invocations corresponds
// the number of defined expectations
func (m *SessionRepositoryMock) MinimockWhereFilterDone() bool <span class="cov0" title="0">{
        if m.WhereFilterMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.WhereFilterMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.WhereFilterMock.invocationsDone()</span>
}

// MinimockWhereFilterInspect logs each unmet expectation
func (m *SessionRepositoryMock) MinimockWhereFilterInspect() <span class="cov0" title="0">{
        for _, e := range m.WhereFilterMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.WhereFilter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterWhereFilterCounter := mm_atomic.LoadUint64(&amp;m.afterWhereFilterCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.WhereFilterMock.defaultExpectation != nil &amp;&amp; afterWhereFilterCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.WhereFilterMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to SessionRepositoryMock.WhereFilter at\n%s", m.WhereFilterMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to SessionRepositoryMock.WhereFilter at\n%s with params: %#v", m.WhereFilterMock.defaultExpectation.expectationOrigins.origin, *m.WhereFilterMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcWhereFilter != nil &amp;&amp; afterWhereFilterCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to SessionRepositoryMock.WhereFilter at\n%s", m.funcWhereFilterOrigin)
        }</span>

        <span class="cov0" title="0">if !m.WhereFilterMock.invocationsDone() &amp;&amp; afterWhereFilterCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to SessionRepositoryMock.WhereFilter at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.WhereFilterMock.expectedInvocations), m.WhereFilterMock.expectedInvocationsOrigin, afterWhereFilterCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SessionRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddInspect()

                        m.MinimockFilterInspect()

                        m.MinimockGetByUUIDInspect()

                        m.MinimockUpdateInspect()

                        m.MinimockUpdatesInspect()

                        m.MinimockWhereFilterInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SessionRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *SessionRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockAddDone() &amp;&amp;
                m.MinimockFilterDone() &amp;&amp;
                m.MinimockGetByUUIDDone() &amp;&amp;
                m.MinimockUpdateDone() &amp;&amp;
                m.MinimockUpdatesDone() &amp;&amp;
                m.MinimockWhereFilterDone()
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i k071123/internal/services/parking_service/domain/repositories.UnitRepository -o unit_repository_mock_test.go -n UnitRepositoryMock -p mocks

import (
        "k071123/internal/services/parking_service/domain/models"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// UnitRepositoryMock implements mm_repositories.UnitRepository
type UnitRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAdd          func(model *models.Unit) (err error)
        funcAddOrigin    string
        inspectFuncAdd   func(model *models.Unit)
        afterAddCounter  uint64
        beforeAddCounter uint64
        AddMock          mUnitRepositoryMockAdd

        funcGetByUUID          func(uuid string) (up1 *models.Unit, err error)
        funcGetByUUIDOrigin    string
        inspectFuncGetByUUID   func(uuid string)
        afterGetByUUIDCounter  uint64
        beforeGetByUUIDCounter uint64
        GetByUUIDMock          mUnitRepositoryMockGetByUUID
}

// NewUnitRepositoryMock returns a mock for mm_repositories.UnitRepository
func NewUnitRepositoryMock(t minimock.Tester) *UnitRepositoryMock <span class="cov0" title="0">{
        m := &amp;UnitRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.AddMock = mUnitRepositoryMockAdd{mock: m}
        m.AddMock.callArgs = []*UnitRepositoryMockAddParams{}

        m.GetByUUIDMock = mUnitRepositoryMockGetByUUID{mock: m}
        m.GetByUUIDMock.callArgs = []*UnitRepositoryMockGetByUUIDParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mUnitRepositoryMockAdd struct {
        optional           bool
        mock               *UnitRepositoryMock
        defaultExpectation *UnitRepositoryMockAddExpectation
        expectations       []*UnitRepositoryMockAddExpectation

        callArgs []*UnitRepositoryMockAddParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// UnitRepositoryMockAddExpectation specifies expectation struct of the UnitRepository.Add
type UnitRepositoryMockAddExpectation struct {
        mock               *UnitRepositoryMock
        params             *UnitRepositoryMockAddParams
        paramPtrs          *UnitRepositoryMockAddParamPtrs
        expectationOrigins UnitRepositoryMockAddExpectationOrigins
        results            *UnitRepositoryMockAddResults
        returnOrigin       string
        Counter            uint64
}

// UnitRepositoryMockAddParams contains parameters of the UnitRepository.Add
type UnitRepositoryMockAddParams struct {
        model *models.Unit
}

// UnitRepositoryMockAddParamPtrs contains pointers to parameters of the UnitRepository.Add
type UnitRepositoryMockAddParamPtrs struct {
        model **models.Unit
}

// UnitRepositoryMockAddResults contains results of the UnitRepository.Add
type UnitRepositoryMockAddResults struct {
        err error
}

// UnitRepositoryMockAddOrigins contains origins of expectations of the UnitRepository.Add
type UnitRepositoryMockAddExpectationOrigins struct {
        origin      string
        originModel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mUnitRepositoryMockAdd) Optional() *mUnitRepositoryMockAdd <span class="cov0" title="0">{
        mmAdd.optional = true
        return mmAdd
}</span>

// Expect sets up expected params for UnitRepository.Add
func (mmAdd *mUnitRepositoryMockAdd) Expect(model *models.Unit) *mUnitRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("UnitRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;UnitRepositoryMockAddExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("UnitRepositoryMock.Add mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmAdd.defaultExpectation.params = &amp;UnitRepositoryMockAddParams{model}
        mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmAdd.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAdd.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmAdd</span>
}

// ExpectModelParam1 sets up expected param model for UnitRepository.Add
func (mmAdd *mUnitRepositoryMockAdd) ExpectModelParam1(model *models.Unit) *mUnitRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("UnitRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;UnitRepositoryMockAddExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("UnitRepositoryMock.Add mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation.paramPtrs = &amp;UnitRepositoryMockAddParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAdd.defaultExpectation.paramPtrs.model = &amp;model
        mmAdd.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

        return mmAdd</span>
}

// Inspect accepts an inspector function that has same arguments as the UnitRepository.Add
func (mmAdd *mUnitRepositoryMockAdd) Inspect(f func(model *models.Unit)) *mUnitRepositoryMockAdd <span class="cov0" title="0">{
        if mmAdd.mock.inspectFuncAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Inspect function is already set for UnitRepositoryMock.Add")
        }</span>

        <span class="cov0" title="0">mmAdd.mock.inspectFuncAdd = f

        return mmAdd</span>
}

// Return sets up results that will be returned by UnitRepository.Add
func (mmAdd *mUnitRepositoryMockAdd) Return(err error) *UnitRepositoryMock <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("UnitRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAdd.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAdd.defaultExpectation = &amp;UnitRepositoryMockAddExpectation{mock: mmAdd.mock}
        }</span>
        <span class="cov0" title="0">mmAdd.defaultExpectation.results = &amp;UnitRepositoryMockAddResults{err}
        mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmAdd.mock</span>
}

// Set uses given function f to mock the UnitRepository.Add method
func (mmAdd *mUnitRepositoryMockAdd) Set(f func(model *models.Unit) (err error)) *UnitRepositoryMock <span class="cov0" title="0">{
        if mmAdd.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Default expectation is already set for the UnitRepository.Add method")
        }</span>

        <span class="cov0" title="0">if len(mmAdd.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Some expectations are already set for the UnitRepository.Add method")
        }</span>

        <span class="cov0" title="0">mmAdd.mock.funcAdd = f
        mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
        return mmAdd.mock</span>
}

// When sets expectation for the UnitRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mUnitRepositoryMockAdd) When(model *models.Unit) *UnitRepositoryMockAddExpectation <span class="cov0" title="0">{
        if mmAdd.mock.funcAdd != nil </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("UnitRepositoryMock.Add mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UnitRepositoryMockAddExpectation{
                mock:               mmAdd.mock,
                params:             &amp;UnitRepositoryMockAddParams{model},
                expectationOrigins: UnitRepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmAdd.expectations = append(mmAdd.expectations, expectation)
        return expectation</span>
}

// Then sets up UnitRepository.Add return parameters for the expectation previously defined by the When method
func (e *UnitRepositoryMockAddExpectation) Then(err error) *UnitRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;UnitRepositoryMockAddResults{err}
        return e.mock
}</span>

// Times sets number of times UnitRepository.Add should be invoked
func (mmAdd *mUnitRepositoryMockAdd) Times(n uint64) *mUnitRepositoryMockAdd <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAdd.mock.t.Fatalf("Times of UnitRepositoryMock.Add mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAdd.expectedInvocations, n)
        mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmAdd</span>
}

func (mmAdd *mUnitRepositoryMockAdd) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmAdd.expectations) == 0 &amp;&amp; mmAdd.defaultExpectation == nil &amp;&amp; mmAdd.mock.funcAdd == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmAdd.mock.afterAddCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAdd.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Add implements mm_repositories.UnitRepository
func (mmAdd *UnitRepositoryMock) Add(model *models.Unit) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmAdd.beforeAddCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAdd.afterAddCounter, 1)

        mmAdd.t.Helper()

        if mmAdd.inspectFuncAdd != nil </span><span class="cov0" title="0">{
                mmAdd.inspectFuncAdd(model)
        }</span>

        <span class="cov0" title="0">mm_params := UnitRepositoryMockAddParams{model}

        // Record call args
        mmAdd.AddMock.mutex.Lock()
        mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &amp;mm_params)
        mmAdd.AddMock.mutex.Unlock()

        for _, e := range mmAdd.AddMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmAdd.AddMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmAdd.AddMock.defaultExpectation.Counter, 1)
                mm_want := mmAdd.AddMock.defaultExpectation.params
                mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

                mm_got := UnitRepositoryMockAddParams{model}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.model != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.model, mm_got.model) </span><span class="cov0" title="0">{
                                mmAdd.t.Errorf("UnitRepositoryMock.Add got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAdd.AddMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAdd.t.Errorf("UnitRepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmAdd.AddMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAdd.t.Fatal("No results are set for the UnitRepositoryMock.Add")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAdd.funcAdd != nil </span><span class="cov0" title="0">{
                return mmAdd.funcAdd(model)
        }</span>
        <span class="cov0" title="0">mmAdd.t.Fatalf("Unexpected call to UnitRepositoryMock.Add. %v", model)
        return</span>
}

// AddAfterCounter returns a count of finished UnitRepositoryMock.Add invocations
func (mmAdd *UnitRepositoryMock) AddAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAdd.afterAddCounter)
}</span>

// AddBeforeCounter returns a count of UnitRepositoryMock.Add invocations
func (mmAdd *UnitRepositoryMock) AddBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAdd.beforeAddCounter)
}</span>

// Calls returns a list of arguments used in each call to UnitRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mUnitRepositoryMockAdd) Calls() []*UnitRepositoryMockAddParams <span class="cov0" title="0">{
        mmAdd.mutex.RLock()

        argCopy := make([]*UnitRepositoryMockAddParams, len(mmAdd.callArgs))
        copy(argCopy, mmAdd.callArgs)

        mmAdd.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *UnitRepositoryMock) MinimockAddDone() bool <span class="cov0" title="0">{
        if m.AddMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.AddMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.AddMock.invocationsDone()</span>
}

// MinimockAddInspect logs each unmet expectation
func (m *UnitRepositoryMock) MinimockAddInspect() <span class="cov0" title="0">{
        for _, e := range m.AddMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UnitRepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddCounter := mm_atomic.LoadUint64(&amp;m.afterAddCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddMock.defaultExpectation != nil &amp;&amp; afterAddCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UnitRepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UnitRepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAdd != nil &amp;&amp; afterAddCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to UnitRepositoryMock.Add at\n%s", m.funcAddOrigin)
        }</span>

        <span class="cov0" title="0">if !m.AddMock.invocationsDone() &amp;&amp; afterAddCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UnitRepositoryMock.Add at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
        }</span>
}

type mUnitRepositoryMockGetByUUID struct {
        optional           bool
        mock               *UnitRepositoryMock
        defaultExpectation *UnitRepositoryMockGetByUUIDExpectation
        expectations       []*UnitRepositoryMockGetByUUIDExpectation

        callArgs []*UnitRepositoryMockGetByUUIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// UnitRepositoryMockGetByUUIDExpectation specifies expectation struct of the UnitRepository.GetByUUID
type UnitRepositoryMockGetByUUIDExpectation struct {
        mock               *UnitRepositoryMock
        params             *UnitRepositoryMockGetByUUIDParams
        paramPtrs          *UnitRepositoryMockGetByUUIDParamPtrs
        expectationOrigins UnitRepositoryMockGetByUUIDExpectationOrigins
        results            *UnitRepositoryMockGetByUUIDResults
        returnOrigin       string
        Counter            uint64
}

// UnitRepositoryMockGetByUUIDParams contains parameters of the UnitRepository.GetByUUID
type UnitRepositoryMockGetByUUIDParams struct {
        uuid string
}

// UnitRepositoryMockGetByUUIDParamPtrs contains pointers to parameters of the UnitRepository.GetByUUID
type UnitRepositoryMockGetByUUIDParamPtrs struct {
        uuid *string
}

// UnitRepositoryMockGetByUUIDResults contains results of the UnitRepository.GetByUUID
type UnitRepositoryMockGetByUUIDResults struct {
        up1 *models.Unit
        err error
}

// UnitRepositoryMockGetByUUIDOrigins contains origins of expectations of the UnitRepository.GetByUUID
type UnitRepositoryMockGetByUUIDExpectationOrigins struct {
        origin     string
        originUuid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) Optional() *mUnitRepositoryMockGetByUUID <span class="cov0" title="0">{
        mmGetByUUID.optional = true
        return mmGetByUUID
}</span>

// Expect sets up expected params for UnitRepository.GetByUUID
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) Expect(uuid string) *mUnitRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("UnitRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;UnitRepositoryMockGetByUUIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("UnitRepositoryMock.GetByUUID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.params = &amp;UnitRepositoryMockGetByUUIDParams{uuid}
        mmGetByUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetByUUID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetByUUID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetByUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByUUID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetByUUID</span>
}

// ExpectUuidParam1 sets up expected param uuid for UnitRepository.GetByUUID
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) ExpectUuidParam1(uuid string) *mUnitRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("UnitRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;UnitRepositoryMockGetByUUIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("UnitRepositoryMock.GetByUUID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation.paramPtrs = &amp;UnitRepositoryMockGetByUUIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.paramPtrs.uuid = &amp;uuid
        mmGetByUUID.defaultExpectation.expectationOrigins.originUuid = minimock.CallerInfo(1)

        return mmGetByUUID</span>
}

// Inspect accepts an inspector function that has same arguments as the UnitRepository.GetByUUID
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) Inspect(f func(uuid string)) *mUnitRepositoryMockGetByUUID <span class="cov0" title="0">{
        if mmGetByUUID.mock.inspectFuncGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Inspect function is already set for UnitRepositoryMock.GetByUUID")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.mock.inspectFuncGetByUUID = f

        return mmGetByUUID</span>
}

// Return sets up results that will be returned by UnitRepository.GetByUUID
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) Return(up1 *models.Unit, err error) *UnitRepositoryMock <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("UnitRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByUUID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByUUID.defaultExpectation = &amp;UnitRepositoryMockGetByUUIDExpectation{mock: mmGetByUUID.mock}
        }</span>
        <span class="cov0" title="0">mmGetByUUID.defaultExpectation.results = &amp;UnitRepositoryMockGetByUUIDResults{up1, err}
        mmGetByUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetByUUID.mock</span>
}

// Set uses given function f to mock the UnitRepository.GetByUUID method
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) Set(f func(uuid string) (up1 *models.Unit, err error)) *UnitRepositoryMock <span class="cov0" title="0">{
        if mmGetByUUID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Default expectation is already set for the UnitRepository.GetByUUID method")
        }</span>

        <span class="cov0" title="0">if len(mmGetByUUID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Some expectations are already set for the UnitRepository.GetByUUID method")
        }</span>

        <span class="cov0" title="0">mmGetByUUID.mock.funcGetByUUID = f
        mmGetByUUID.mock.funcGetByUUIDOrigin = minimock.CallerInfo(1)
        return mmGetByUUID.mock</span>
}

// When sets expectation for the UnitRepository.GetByUUID which will trigger the result defined by the following
// Then helper
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) When(uuid string) *UnitRepositoryMockGetByUUIDExpectation <span class="cov0" title="0">{
        if mmGetByUUID.mock.funcGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("UnitRepositoryMock.GetByUUID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UnitRepositoryMockGetByUUIDExpectation{
                mock:               mmGetByUUID.mock,
                params:             &amp;UnitRepositoryMockGetByUUIDParams{uuid},
                expectationOrigins: UnitRepositoryMockGetByUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetByUUID.expectations = append(mmGetByUUID.expectations, expectation)
        return expectation</span>
}

// Then sets up UnitRepository.GetByUUID return parameters for the expectation previously defined by the When method
func (e *UnitRepositoryMockGetByUUIDExpectation) Then(up1 *models.Unit, err error) *UnitRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;UnitRepositoryMockGetByUUIDResults{up1, err}
        return e.mock
}</span>

// Times sets number of times UnitRepository.GetByUUID should be invoked
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) Times(n uint64) *mUnitRepositoryMockGetByUUID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetByUUID.mock.t.Fatalf("Times of UnitRepositoryMock.GetByUUID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetByUUID.expectedInvocations, n)
        mmGetByUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetByUUID</span>
}

func (mmGetByUUID *mUnitRepositoryMockGetByUUID) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGetByUUID.expectations) == 0 &amp;&amp; mmGetByUUID.defaultExpectation == nil &amp;&amp; mmGetByUUID.mock.funcGetByUUID == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetByUUID.mock.afterGetByUUIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetByUUID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetByUUID implements mm_repositories.UnitRepository
func (mmGetByUUID *UnitRepositoryMock) GetByUUID(uuid string) (up1 *models.Unit, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGetByUUID.beforeGetByUUIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetByUUID.afterGetByUUIDCounter, 1)

        mmGetByUUID.t.Helper()

        if mmGetByUUID.inspectFuncGetByUUID != nil </span><span class="cov0" title="0">{
                mmGetByUUID.inspectFuncGetByUUID(uuid)
        }</span>

        <span class="cov0" title="0">mm_params := UnitRepositoryMockGetByUUIDParams{uuid}

        // Record call args
        mmGetByUUID.GetByUUIDMock.mutex.Lock()
        mmGetByUUID.GetByUUIDMock.callArgs = append(mmGetByUUID.GetByUUIDMock.callArgs, &amp;mm_params)
        mmGetByUUID.GetByUUIDMock.mutex.Unlock()

        for _, e := range mmGetByUUID.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.up1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGetByUUID.GetByUUIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetByUUID.GetByUUIDMock.defaultExpectation.Counter, 1)
                mm_want := mmGetByUUID.GetByUUIDMock.defaultExpectation.params
                mm_want_ptrs := mmGetByUUID.GetByUUIDMock.defaultExpectation.paramPtrs

                mm_got := UnitRepositoryMockGetByUUIDParams{uuid}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.uuid != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.uuid, mm_got.uuid) </span><span class="cov0" title="0">{
                                mmGetByUUID.t.Errorf("UnitRepositoryMock.GetByUUID got unexpected parameter uuid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByUUID.GetByUUIDMock.defaultExpectation.expectationOrigins.originUuid, *mm_want_ptrs.uuid, mm_got.uuid, minimock.Diff(*mm_want_ptrs.uuid, mm_got.uuid))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetByUUID.t.Errorf("UnitRepositoryMock.GetByUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetByUUID.GetByUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetByUUID.GetByUUIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetByUUID.t.Fatal("No results are set for the UnitRepositoryMock.GetByUUID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).up1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetByUUID.funcGetByUUID != nil </span><span class="cov0" title="0">{
                return mmGetByUUID.funcGetByUUID(uuid)
        }</span>
        <span class="cov0" title="0">mmGetByUUID.t.Fatalf("Unexpected call to UnitRepositoryMock.GetByUUID. %v", uuid)
        return</span>
}

// GetByUUIDAfterCounter returns a count of finished UnitRepositoryMock.GetByUUID invocations
func (mmGetByUUID *UnitRepositoryMock) GetByUUIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByUUID.afterGetByUUIDCounter)
}</span>

// GetByUUIDBeforeCounter returns a count of UnitRepositoryMock.GetByUUID invocations
func (mmGetByUUID *UnitRepositoryMock) GetByUUIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByUUID.beforeGetByUUIDCounter)
}</span>

// Calls returns a list of arguments used in each call to UnitRepositoryMock.GetByUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByUUID *mUnitRepositoryMockGetByUUID) Calls() []*UnitRepositoryMockGetByUUIDParams <span class="cov0" title="0">{
        mmGetByUUID.mutex.RLock()

        argCopy := make([]*UnitRepositoryMockGetByUUIDParams, len(mmGetByUUID.callArgs))
        copy(argCopy, mmGetByUUID.callArgs)

        mmGetByUUID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetByUUIDDone returns true if the count of the GetByUUID invocations corresponds
// the number of defined expectations
func (m *UnitRepositoryMock) MinimockGetByUUIDDone() bool <span class="cov0" title="0">{
        if m.GetByUUIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetByUUIDMock.invocationsDone()</span>
}

// MinimockGetByUUIDInspect logs each unmet expectation
func (m *UnitRepositoryMock) MinimockGetByUUIDInspect() <span class="cov0" title="0">{
        for _, e := range m.GetByUUIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UnitRepositoryMock.GetByUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetByUUIDCounter := mm_atomic.LoadUint64(&amp;m.afterGetByUUIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetByUUIDMock.defaultExpectation != nil &amp;&amp; afterGetByUUIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetByUUIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UnitRepositoryMock.GetByUUID at\n%s", m.GetByUUIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UnitRepositoryMock.GetByUUID at\n%s with params: %#v", m.GetByUUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByUUIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetByUUID != nil &amp;&amp; afterGetByUUIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to UnitRepositoryMock.GetByUUID at\n%s", m.funcGetByUUIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetByUUIDMock.invocationsDone() &amp;&amp; afterGetByUUIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UnitRepositoryMock.GetByUUID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetByUUIDMock.expectedInvocations), m.GetByUUIDMock.expectedInvocationsOrigin, afterGetByUUIDCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UnitRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddInspect()

                        m.MinimockGetByUUIDInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UnitRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *UnitRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockAddDone() &amp;&amp;
                m.MinimockGetByUUIDDone()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
